# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-05-18 14:33-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: /usr/src/usr.bin/lex/lex.1:3
#, no-wrap
msgid "FLEX"
msgstr ""

#. type: TH
#: /usr/src/usr.bin/lex/lex.1:3
#, no-wrap
msgid "May 21, 2013"
msgstr ""

#. type: TH
#: /usr/src/usr.bin/lex/lex.1:3
#, no-wrap
msgid "Version 2.5.37"
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:4
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:6
msgid "flex, lex - fast lexical analyzer generator"
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:6
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:11
msgid ""
"B<flex> B<[-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix "
"-Sskeleton]> B<[--help --version]> I<[filename ...]>"
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:11
#, no-wrap
msgid "OVERVIEW"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:16
msgid ""
"This manual describes I<flex,> a tool for generating programs that perform "
"pattern-matching on text.  The manual includes both tutorial and reference "
"sections:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:20
#, no-wrap
msgid ""
"    Description\n"
"        a brief overview of the tool\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:22
#, no-wrap
msgid "    Some Simple Examples\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:24
#, no-wrap
msgid "    Format Of The Input File\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:27
#, no-wrap
msgid ""
"    Patterns\n"
"        the extended regular expressions used by flex\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:30
#, no-wrap
msgid ""
"    How The Input Is Matched\n"
"        the rules for determining what has been matched\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:33
#, no-wrap
msgid ""
"    Actions\n"
"        how to specify what to do when a pattern is matched\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:37
#, no-wrap
msgid ""
"    The Generated Scanner\n"
"        details regarding the scanner that flex produces;\n"
"        how to control the input source\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:41
#, no-wrap
msgid ""
"    Start Conditions\n"
"        introducing context into your scanners, and\n"
"        managing \"mini-scanners\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:45
#, no-wrap
msgid ""
"    Multiple Input Buffers\n"
"        how to manipulate multiple input sources; how to\n"
"        scan from strings instead of files\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:48
#, no-wrap
msgid ""
"    End-of-file Rules\n"
"        special rules for matching the end of the input\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:51
#, no-wrap
msgid ""
"    Miscellaneous Macros\n"
"        a summary of macros available to the actions\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:54
#, no-wrap
msgid ""
"    Values Available To The User\n"
"        a summary of values available to the actions\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:57
#, no-wrap
msgid ""
"    Interfacing With Yacc\n"
"        connecting flex scanners together with yacc parsers\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:61
#, no-wrap
msgid ""
"    Options\n"
"        flex command-line options, and the \"%option\"\n"
"        directive\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:64
#, no-wrap
msgid ""
"    Performance Considerations\n"
"        how to make your scanner go as fast as possible\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:68
#, no-wrap
msgid ""
"    Generating C++ Scanners\n"
"        the (experimental) facility for generating C++\n"
"        scanner classes\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:72
#, no-wrap
msgid ""
"    Incompatibilities With Lex And POSIX\n"
"        how flex differs from AT&T lex and the POSIX lex\n"
"        standard\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:76
#, no-wrap
msgid ""
"    Diagnostics\n"
"        those error messages produced by flex (or scanners\n"
"        it generates) whose meanings might not be apparent\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:79
#, no-wrap
msgid ""
"    Files\n"
"        files used by flex\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:82
#, no-wrap
msgid ""
"    Deficiencies / Bugs\n"
"        known problems with flex\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:85
#, no-wrap
msgid ""
"    See Also\n"
"        other documentation, related tools\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:88
#, no-wrap
msgid ""
"    Author\n"
"        includes contact information\n"
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:90
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:115
msgid ""
"I<flex> is a tool for generating I<scanners:> programs which recognize "
"lexical patterns in text.  I<flex> reads the given input files, or its "
"standard input if no file names are given, for a description of a scanner to "
"generate.  The description is in the form of pairs of regular expressions "
"and C code, called I<rules.> I<flex> generates as output a C source file, "
"B<lex.yy.c,> which defines a routine B<yylex().> This file is compiled and "
"linked with the B<-ll> library to produce an executable.  When the "
"executable is run, it analyzes its input for occurrences of the regular "
"expressions.  Whenever it finds one, it executes the corresponding C code."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:115
#, no-wrap
msgid "SOME SIMPLE EXAMPLES"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:122
msgid ""
"First some simple examples to get the flavor of how one uses I<flex.> The "
"following I<flex> input specifies a scanner which whenever it encounters the "
"string \"username\" will replace it with the user's login name:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:126
#, no-wrap
msgid ""
"    %%\n"
"    username    printf( \"%s\", getlogin() );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:140
msgid ""
"By default, any text not matched by a I<flex> scanner is copied to the "
"output, so the net effect of this scanner is to copy its input file to its "
"output with each occurrence of \"username\" expanded.  In this input, there "
"is just one rule.  \"username\" is the I<pattern> and the \"printf\" is the "
"I<action.> The \"%%\" marks the beginning of the rules."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:142
msgid "Here's another simple example:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:147
#, no-wrap
msgid ""
"    %{\n"
"            int num_lines = 0, num_chars = 0;\n"
"    %}\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:151
#, no-wrap
msgid ""
"    %%\n"
"    \\en      ++num_lines; ++num_chars;\n"
"    .       ++num_chars;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:159
#, no-wrap
msgid ""
"    %%\n"
"    main()\n"
"            {\n"
"            yylex();\n"
"            printf( \"# of lines = %d, # of chars = %d\\en\",\n"
"                    num_lines, num_chars );\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:175
msgid ""
"This scanner counts the number of characters and the number of lines in its "
"input (it produces no output other than the final report on the counts).  "
"The first line declares two globals, \"num_lines\" and \"num_chars\", which "
"are accessible both inside B<yylex()> and in the B<main()> routine declared "
"after the second \"%%\".  There are two rules, one which matches a newline "
"(\"\\en\") and increments both the line count and the character count, and "
"one which matches any character other than a newline (indicated by the \".\" "
"regular expression)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:177
msgid "A somewhat more complicated example:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:180
#, no-wrap
msgid "    /* scanner for a toy Pascal-like language */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:185
#, no-wrap
msgid ""
"    %{\n"
"    /* need this for the call to atof() below */\n"
"    #include E<lt>math.hE<gt>\n"
"    %}\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:188 /usr/src/usr.bin/lex/lex.1:279
#, no-wrap
msgid ""
"    DIGIT    [0-9]\n"
"    ID       [a-z][a-z0-9]*\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:190 /usr/src/usr.bin/lex/lex.1:216 /usr/src/usr.bin/lex/lex.1:608 /usr/src/usr.bin/lex/lex.1:2159 /usr/src/usr.bin/lex/lex.1:3614 /usr/src/usr.bin/lex/lex.1:3644
#, no-wrap
msgid "    %%\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:195
#, no-wrap
msgid ""
"    {DIGIT}+    {\n"
"                printf( \"An integer: %s (%d)\\en\", yytext,\n"
"                        atoi( yytext ) );\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:200
#, no-wrap
msgid ""
"    {DIGIT}+\".\"{DIGIT}*        {\n"
"                printf( \"A float: %s (%g)\\en\", yytext,\n"
"                        atof( yytext ) );\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:204
#, no-wrap
msgid ""
"    if|then|begin|end|procedure|function        {\n"
"                printf( \"A keyword: %s\\en\", yytext );\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:206
#, no-wrap
msgid "    {ID}        printf( \"An identifier: %s\\en\", yytext );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:208
#, no-wrap
msgid "    \"+\"|\"-\"|\"*\"|\"/\"   printf( \"An operator: %s\\en\", yytext );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:210
#, no-wrap
msgid "    \"{\"[^}\\en]*\"}\"     /* eat up one-line comments */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:212
#, no-wrap
msgid "    [ \\et\\en]+          /* eat up whitespace */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:214
#, no-wrap
msgid "    .           printf( \"Unrecognized character: %s\\en\", yytext );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:226
#, no-wrap
msgid ""
"    main( argc, argv )\n"
"    int argc;\n"
"    char **argv;\n"
"        {\n"
"        ++argv, --argc;  /* skip over program name */\n"
"        if ( argc E<gt> 0 )\n"
"                yyin = fopen( argv[0], \"r\" );\n"
"        else\n"
"                yyin = stdin;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:229
#, no-wrap
msgid ""
"        yylex();\n"
"        }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:236
msgid ""
"This is the beginnings of a simple scanner for a language like Pascal.  It "
"identifies different types of I<tokens> and reports on what it has seen."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:239
msgid "The details of this example will be explained in the following sections."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:239
#, no-wrap
msgid "FORMAT OF THE INPUT FILE"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:245
msgid ""
"The I<flex> input file consists of three sections, separated by a line with "
"just B<%%> in it:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:252
#, no-wrap
msgid ""
"    definitions\n"
"    %%\n"
"    rules\n"
"    %%\n"
"    user code\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:261
msgid ""
"The I<definitions> section contains declarations of simple I<name> "
"definitions to simplify the scanner specification, and declarations of "
"I<start conditions,> which are explained in a later section."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:263
msgid "Name definitions have the form:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:266
#, no-wrap
msgid "    name definition\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:275
msgid ""
"The \"name\" is a word beginning with a letter or an underscore ('_')  "
"followed by zero or more letters, digits, '_', or '-' (dash).  The "
"definition is taken to begin at the first non-white-space character "
"following the name and continuing to the end of the line.  The definition "
"can subsequently be referred to using \"{name}\", which will expand to "
"\"(definition)\".  For example,"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:286
msgid ""
"defines \"DIGIT\" to be a regular expression which matches a single digit, "
"and \"ID\" to be a regular expression which matches a letter followed by "
"zero-or-more letters-or-digits.  A subsequent reference to"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:289
#, no-wrap
msgid "    {DIGIT}+\".\"{DIGIT}*\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:292
msgid "is identical to"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:295
#, no-wrap
msgid "    ([0-9])+\".\"([0-9])*\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:299
msgid ""
"and matches one-or-more digits followed by a '.' followed by zero-or-more "
"digits."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:305
msgid ""
"The I<rules> section of the I<flex> input contains a series of rules of the "
"form:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:308
#, no-wrap
msgid "    pattern   action\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:312
msgid ""
"where the pattern must be unindented and the action must begin on the same "
"line."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:314
msgid "See below for a further description of patterns and actions."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:324
msgid ""
"Finally, the user code section is simply copied to B<lex.yy.c> verbatim.  It "
"is used for companion routines which call or are called by the scanner.  The "
"presence of this section is optional; if it is missing, the second B<%%> in "
"the input file may be skipped, too."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:333
msgid ""
"In the definitions and rules sections, any I<indented> text or text enclosed "
"in B<%{> and B<%}> is copied verbatim to the output (with the %{}'s "
"removed).  The %{}'s must appear unindented on lines by themselves."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:344
msgid ""
"In the rules section, any indented or %{} text appearing before the first "
"rule may be used to declare variables which are local to the scanning "
"routine and (after the declarations)  code which is to be executed whenever "
"the scanning routine is entered.  Other indented or %{} text in the rule "
"section is still copied to the output, but its meaning is not well-defined "
"and it may well cause compile-time errors (this feature is present for "
"I<POSIX> compliance; see below for other such features)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:349
msgid ""
"In the definitions section (but not in the rules section), an unindented "
"comment (i.e., a line beginning with \"/*\") is also copied verbatim to the "
"output up to the next \"*/\"."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:349
#, no-wrap
msgid "PATTERNS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:353
msgid ""
"The patterns in the input are written using an extended set of regular "
"expressions.  These are:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:386
#, no-wrap
msgid ""
"    x          match the character 'x'\n"
"    .          any character (byte) except newline\n"
"    [xyz]      a \"character class\"; in this case, the pattern\n"
"                 matches either an 'x', a 'y', or a 'z'\n"
"    [abj-oZ]   a \"character class\" with a range in it; matches\n"
"                 an 'a', a 'b', any letter from 'j' through 'o',\n"
"                 or a 'Z'\n"
"    [^A-Z]     a \"negated character class\", i.e., any character\n"
"                 but those in the class.  In this case, any\n"
"                 character EXCEPT an uppercase letter.\n"
"    [^A-Z\\en]   any character EXCEPT an uppercase letter or\n"
"                 a newline\n"
"    r*         zero or more r's, where r is any regular expression\n"
"    r+         one or more r's\n"
"    r?         zero or one r's (that is, \"an optional r\")\n"
"    r{2,5}     anywhere from two to five r's\n"
"    r{2,}      two or more r's\n"
"    r{4}       exactly 4 r's\n"
"    {name}     the expansion of the \"name\" definition\n"
"               (see above)\n"
"    \"[xyz]\\e\"foo\"\n"
"               the literal string: [xyz]\"foo\n"
"    \\eX         if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v',\n"
"                 then the ANSI-C interpretation of \\ex.\n"
"                 Otherwise, a literal 'X' (used to escape\n"
"                 operators such as '*')\n"
"    \\e0         a NUL character (ASCII code 0)\n"
"    \\e123       the character with octal value 123\n"
"    \\ex2a       the character with hexadecimal value 2a\n"
"    (r)        match an r; parentheses are used to override\n"
"                 precedence (see below)\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:390
#, no-wrap
msgid ""
"    rs         the regular expression r followed by the\n"
"                 regular expression s; called \"concatenation\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:393
#, no-wrap
msgid "    r|s        either an r or an s\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:411
#, no-wrap
msgid ""
"    r/s        an r but only if it is followed by an s.  The\n"
"                 text matched by s is included when determining\n"
"                 whether this rule is the \"longest match\",\n"
"                 but is then returned to the input before\n"
"                 the action is executed.  So the action only\n"
"                 sees the text matched by r.  This type\n"
"                 of pattern is called trailing context\".\n"
"                 (There are some combinations of r/s that flex\n"
"                 cannot match correctly; see notes in the\n"
"                 Deficiencies / Bugs section below regarding\n"
"                 \"dangerous trailing context\".)\n"
"    ^r         an r, but only at the beginning of a line (i.e.,\n"
"                 when just starting to scan, or right after a\n"
"                 newline has been scanned).\n"
"    r$         an r, but only at the end of a line (i.e., just\n"
"                 before a newline).  Equivalent to \"r/\\en\".\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:417
#, no-wrap
msgid ""
"               Note that flex's notion of \"newline\" is exactly\n"
"               whatever the C compiler used to compile flex\n"
"               interprets '\\en' as; in particular, on some DOS\n"
"               systems you must either filter out \\er's in the\n"
"               input yourself, or explicitly use r/\\er\\en for \"r$\".\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:425
#, no-wrap
msgid ""
"    E<lt>sE<gt>r       an r, but only in start condition s (see\n"
"                 below for discussion of start conditions)\n"
"    E<lt>s1,s2,s3E<gt>r\n"
"               same, but in any of start conditions s1,\n"
"                 s2, or s3\n"
"    E<lt>*E<gt>r       an r in any start condition, even an exclusive one.\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:430
#, no-wrap
msgid ""
"    E<lt>E<lt>EOFE<gt>E<gt>    an end-of-file\n"
"    E<lt>s1,s2E<gt>E<lt>E<lt>EOFE<gt>E<gt>\n"
"               an end-of-file when in start condition s1 or s2\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:435
msgid ""
"Note that inside of a character class, all regular expression operators lose "
"their special meaning except escape ('\\e') and the character class "
"operators, '-', ']', and, at the beginning of the class, '^'."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:440
msgid ""
"The regular expressions listed above are grouped according to precedence, "
"from highest precedence at the top to lowest at the bottom.  Those grouped "
"together have equal precedence.  For example,"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:443
#, no-wrap
msgid "    foo|bar*\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:446
msgid "is the same as"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:449
#, no-wrap
msgid "    (foo)|(ba(r*))\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:460
msgid ""
"since the '*' operator has higher precedence than concatenation, and "
"concatenation higher than alternation ('|').  This pattern therefore matches "
"I<either> the string \"foo\" I<or> the string \"ba\" followed by "
"zero-or-more r's.  To match \"foo\" or zero-or-more \"bar\"'s, use:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:463
#, no-wrap
msgid "    foo|(bar)*\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:466
msgid "and to match zero-or-more \"foo\"'s-or-\"bar\"'s:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:469
#, no-wrap
msgid "    (foo|bar)*\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:482
msgid ""
"In addition to characters and ranges of characters, character classes can "
"also contain character class I<expressions.> These are expressions enclosed "
"inside B<[:> and B<:]> delimiters (which themselves must appear between the "
"'[' and ']' of the character class; other elements may occur inside the "
"character class, too).  The valid expressions are:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:488
#, no-wrap
msgid ""
"    [:alnum:] [:alpha:] [:blank:]\n"
"    [:cntrl:] [:digit:] [:graph:]\n"
"    [:lower:] [:print:] [:punct:]\n"
"    [:space:] [:upper:] [:xdigit:]\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:504
msgid ""
"These expressions all designate a set of characters equivalent to the "
"corresponding standard C B<isXXX> function.  For example, B<[:alnum:]> "
"designates those characters for which B<isalnum()> returns true - i.e., any "
"alphabetic or numeric.  Some systems don't provide B<isblank(),> so flex "
"defines B<[:blank:]> as a blank or a tab."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:506
msgid "For example, the following character classes are all equivalent:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:512
#, no-wrap
msgid ""
"    [[:alnum:]]\n"
"    [[:alpha:][:digit:]]\n"
"    [[:alpha:]0-9]\n"
"    [a-zA-Z0-9]\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:522
msgid ""
"If your scanner is case-insensitive (the B<-i> flag), then B<[:upper:]> and "
"B<[:lower:]> are equivalent to B<[:alpha:].>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:524
msgid "Some notes on patterns:"
msgstr ""

#. type: IP
#: /usr/src/usr.bin/lex/lex.1:524 /usr/src/usr.bin/lex/lex.1:536 /usr/src/usr.bin/lex/lex.1:776 /usr/src/usr.bin/lex/lex.1:779 /usr/src/usr.bin/lex/lex.1:783 /usr/src/usr.bin/lex/lex.1:852 /usr/src/usr.bin/lex/lex.1:893 /usr/src/usr.bin/lex/lex.1:928 /usr/src/usr.bin/lex/lex.1:978 /usr/src/usr.bin/lex/lex.1:1022 /usr/src/usr.bin/lex/lex.1:1033 /usr/src/usr.bin/lex/lex.1:1876 /usr/src/usr.bin/lex/lex.1:1883 /usr/src/usr.bin/lex/lex.1:1887 /usr/src/usr.bin/lex/lex.1:1891 /usr/src/usr.bin/lex/lex.1:2029 /usr/src/usr.bin/lex/lex.1:2068 /usr/src/usr.bin/lex/lex.1:2071 /usr/src/usr.bin/lex/lex.1:2087 /usr/src/usr.bin/lex/lex.1:2100 /usr/src/usr.bin/lex/lex.1:2106 /usr/src/usr.bin/lex/lex.1:2111 /usr/src/usr.bin/lex/lex.1:3722 /usr/src/usr.bin/lex/lex.1:3739 /usr/src/usr.bin/lex/lex.1:3766 /usr/src/usr.bin/lex/lex.1:3771 /usr/src/usr.bin/lex/lex.1:3799 /usr/src/usr.bin/lex/lex.1:3811 /usr/src/usr.bin/lex/lex.1:3815 /usr/src/usr.bin/lex/lex.1:3860 /usr/src/usr.bin/lex/lex.1:3874 /usr/src/usr.bin/lex/lex.1:3881 /usr/src/usr.bin/lex/lex.1:3894 /usr/src/usr.bin/lex/lex.1:3905 /usr/src/usr.bin/lex/lex.1:3916 /usr/src/usr.bin/lex/lex.1:3926
#, no-wrap
msgid "-"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:536
msgid ""
"A negated character class such as the example \"[^A-Z]\" above I<will match "
"a newline> unless \"\\en\" (or an equivalent escape sequence) is one of the "
"characters explicitly present in the negated character class (e.g., "
"\"[^A-Z\\en]\").  This is unlike how many other regular expression tools "
"treat negated character classes, but unfortunately the inconsistency is "
"historically entrenched.  Matching newlines means that a pattern like [^\"]* "
"can match the entire input unless there's another quote in the input."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:545
msgid ""
"A rule can have at most one instance of trailing context (the '/' operator "
"or the '$' operator).  The start condition, '^', and "
"\"E<lt>E<lt>EOFE<gt>E<gt>\" patterns can only occur at the beginning of a "
"pattern, and, as well as with '/' and '$', cannot be grouped inside "
"parentheses.  A '^' which does not occur at the beginning of a rule or a '$' "
"which does not occur at the end of a rule loses its special properties and "
"is treated as a normal character."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:547
msgid "The following are illegal:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:551
#, no-wrap
msgid ""
"    foo/bar$\n"
"    E<lt>sc1E<gt>fooE<lt>sc2E<gt>bar\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:554
msgid "Note that the first of these, can be written \"foo/bar\\en\"."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:556
msgid "The following will result in '$' or '^' being treated as a normal character:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:560
#, no-wrap
msgid ""
"    foo|(bar$)\n"
"    foo|^bar\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:564
msgid ""
"If what's wanted is a \"foo\" or a bar-followed-by-a-newline, the following "
"could be used (the special '|' action is explained below):"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:568
#, no-wrap
msgid ""
"    foo      |\n"
"    bar$     /* action goes here */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:572
msgid ""
"A similar trick will work for matching a foo or a "
"bar-at-the-beginning-of-a-line."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:572
#, no-wrap
msgid "HOW THE INPUT IS MATCHED"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:584
msgid ""
"When the generated scanner is run, it analyzes its input looking for strings "
"which match any of its patterns.  If it finds more than one match, it takes "
"the one matching the most text (for trailing context rules, this includes "
"the length of the trailing part, even though it will then be returned to the "
"input).  If it finds two or more matches of the same length, the rule listed "
"first in the I<flex> input file is chosen."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:597
msgid ""
"Once the match is determined, the text corresponding to the match (called "
"the I<token)> is made available in the global character pointer B<yytext,> "
"and its length in the global integer B<yyleng.> The I<action> corresponding "
"to the matched pattern is then executed (a more detailed description of "
"actions follows), and then the remaining input is scanned for another match."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:605
msgid ""
"If no match is found, then the I<default rule> is executed: the next "
"character in the input is considered matched and copied to the standard "
"output.  Thus, the simplest legal I<flex> input is:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:612
msgid ""
"which generates a scanner that simply copies its input (one character at a "
"time) to its output."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:647
msgid ""
"Note that B<yytext> can be defined in two different ways: either as a "
"character I<pointer> or as a character I<array.> You can control which "
"definition I<flex> uses by including one of the special directives "
"B<%pointer> or B<%array> in the first (definitions) section of your flex "
"input.  The default is B<%pointer,> unless you use the B<-l> lex "
"compatibility option, in which case B<yytext> will be an array.  The "
"advantage of using B<%pointer> is substantially faster scanning and no "
"buffer overflow when matching very large tokens (unless you run out of "
"dynamic memory).  The disadvantage is that you are restricted in how your "
"actions can modify B<yytext> (see the next section), and calls to the "
"B<unput()> function destroys the present contents of B<yytext,> which can be "
"a considerable porting headache when moving between different I<lex> "
"versions."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:662
msgid ""
"The advantage of B<%array> is that you can then modify B<yytext> to your "
"heart's content, and calls to B<unput()> do not destroy B<yytext> (see "
"below).  Furthermore, existing I<lex> programs sometimes access B<yytext> "
"externally using declarations of the form:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:664
#, no-wrap
msgid "    extern char yytext[];\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:669
msgid ""
"This definition is erroneous when used with B<%pointer,> but correct for "
"B<%array.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:698
msgid ""
"B<%array> defines B<yytext> to be an array of B<YYLMAX> characters, which "
"defaults to a fairly large value.  You can change the size by simply "
"#define'ing B<YYLMAX> to a different value in the first section of your "
"I<flex> input.  As mentioned above, with B<%pointer> yytext grows "
"dynamically to accommodate large tokens.  While this means your B<%pointer> "
"scanner can accommodate very large tokens (such as matching entire blocks of "
"comments), bear in mind that each time the scanner must resize B<yytext> it "
"also must rescan the entire token from the beginning, so matching such "
"tokens can prove slow.  B<yytext> presently does I<not> dynamically grow if "
"a call to B<unput()> results in too much text being pushed back; instead, a "
"run-time error results."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:705
msgid ""
"Also note that you cannot use B<%array> with C++ scanner classes (the B<c++> "
"option; see below)."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:705
#, no-wrap
msgid "ACTIONS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:715
msgid ""
"Each pattern in a rule has a corresponding action, which can be any "
"arbitrary C statement.  The pattern ends at the first non-escaped whitespace "
"character; the remainder of the line is its action.  If the action is empty, "
"then when the pattern is matched the input token is simply discarded.  For "
"example, here is the specification for a program which deletes all "
"occurrences of \"zap me\" from its input:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:719
#, no-wrap
msgid ""
"    %%\n"
"    \"zap me\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:723
msgid ""
"(It will copy all other characters in the input to the output since they "
"will be matched by the default rule.)"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:726
msgid ""
"Here is a program which compresses multiple blanks and tabs down to a single "
"blank, and throws away whitespace found at the end of a line:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:731
#, no-wrap
msgid ""
"    %%\n"
"    [ \\et]+        putchar( ' ' );\n"
"    [ \\et]+$       /* ignore this token */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:743
msgid ""
"If the action contains a '{', then the action spans till the balancing '}' "
"is found, and the action may cross multiple lines.  I<flex> knows about C "
"strings and comments and won't be fooled by braces found within them, but "
"also allows actions to begin with B<%{> and will consider the action to be "
"all the text up to the next B<%}> (regardless of ordinary braces inside the "
"action)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:746
msgid ""
"An action consisting solely of a vertical bar ('|') means \"same as the "
"action for the next rule.\" See below for an illustration."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:756
msgid ""
"Actions can include arbitrary C code, including B<return> statements to "
"return a value to whatever routine called B<yylex().> Each time B<yylex()> "
"is called it continues processing tokens from where it last left off until "
"it either reaches the end of the file or executes a return."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:767
msgid ""
"Actions are free to modify B<yytext> except for lengthening it (adding "
"characters to its end--these will overwrite later characters in the input "
"stream).  This however does not apply when using B<%array> (see above); in "
"that case, B<yytext> may be freely modified in any way."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:773
msgid ""
"Actions are free to modify B<yyleng> except they should not do so if the "
"action also includes use of B<yymore()> (see below)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:776
msgid ""
"There are a number of special directives which can be included within an "
"action:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:779
msgid "B<ECHO> copies yytext to the scanner's output."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:783
msgid ""
"B<BEGIN> followed by the name of a start condition places the scanner in the "
"corresponding start condition (see below)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:799
msgid ""
"B<REJECT> directs the scanner to proceed on to the \"second best\" rule "
"which matched the input (or a prefix of the input).  The rule is chosen as "
"described above in \"How the Input is Matched\", and B<yytext> and B<yyleng> "
"set up appropriately.  It may either be one which matched as much text as "
"the originally chosen rule but came later in the I<flex> input file, or one "
"which matched less text.  For example, the following will both count the "
"words in the input and call the routine special() whenever \"frob\" is seen:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:803
#, no-wrap
msgid ""
"            int word_count = 0;\n"
"    %%\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:806
#, no-wrap
msgid ""
"    frob        special(); REJECT;\n"
"    [^ \\et\\en]+   ++word_count;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:818
msgid ""
"Without the B<REJECT,> any \"frob\"'s in the input would not be counted as "
"words, since the scanner normally executes only one action per token.  "
"Multiple B<REJECT's> are allowed, each one finding the next best choice to "
"the currently active rule.  For example, when the following scanner scans "
"the token \"abcd\", it will write \"abcdabcaba\" to the output:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:826
#, no-wrap
msgid ""
"    %%\n"
"    a        |\n"
"    ab       |\n"
"    abc      |\n"
"    abcd     ECHO; REJECT;\n"
"    .|\\en     /* eat up any unmatched character */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:844
msgid ""
"(The first three rules share the fourth's action since they use the special "
"'|' action.)  B<REJECT> is a particularly expensive feature in terms of "
"scanner performance; if it is used in I<any> of the scanner's actions it "
"will slow down I<all> of the scanner's matching.  Furthermore, B<REJECT> "
"cannot be used with the I<-Cf> or I<-CF> options (see below)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:852
msgid ""
"Note also that unlike the other special actions, B<REJECT> is a I<branch;> "
"code immediately following it in the action will I<not> be executed."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:862
msgid ""
"B<yymore()> tells the scanner that the next time it matches a rule, the "
"corresponding token should be I<appended> onto the current value of "
"B<yytext> rather than replacing it.  For example, given the input "
"\"mega-kludge\" the following will write \"mega-mega-kludge\" to the output:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:867
#, no-wrap
msgid ""
"    %%\n"
"    mega-    ECHO; yymore();\n"
"    kludge   ECHO;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:877
msgid ""
"First \"mega-\" is matched and echoed to the output.  Then \"kludge\" is "
"matched, but the previous \"mega-\" is still hanging around at the beginning "
"of B<yytext> so the B<ECHO> for the \"kludge\" rule will actually write "
"\"mega-kludge\"."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:893
msgid ""
"Two notes regarding use of B<yymore().> First, B<yymore()> depends on the "
"value of I<yyleng> correctly reflecting the size of the current token, so "
"you must not modify I<yyleng> if you are using B<yymore().> Second, the "
"presence of B<yymore()> in the scanner's action entails a minor performance "
"penalty in the scanner's matching speed."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:909
msgid ""
"B<yyless(n)> returns all but the first I<n> characters of the current token "
"back to the input stream, where they will be rescanned when the scanner "
"looks for the next match.  B<yytext> and B<yyleng> are adjusted "
"appropriately (e.g., B<yyleng> will now be equal to I<n> ).  For example, on "
"the input \"foobar\" the following will write out \"foobarbar\":"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:914
#, no-wrap
msgid ""
"    %%\n"
"    foobar    ECHO; yyless(3);\n"
"    [a-z]+    ECHO;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:923
msgid ""
"An argument of 0 to B<yyless> will cause the entire current input string to "
"be scanned again.  Unless you've changed how the scanner will subsequently "
"process its input (using B<BEGIN,> for example), this will result in an "
"endless loop."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:928
msgid ""
"Note that B<yyless> is a macro and can only be used in the flex input file, "
"not from other source files."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:936
msgid ""
"B<unput(c)> puts the character I<c> back onto the input stream.  It will be "
"the next character scanned.  The following action will take the current "
"token and cause it to be rescanned enclosed in parentheses."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:948
#, no-wrap
msgid ""
"    {\n"
"    int i;\n"
"    /* Copy yytext because unput() trashes yytext */\n"
"    char *yycopy = strdup( yytext );\n"
"    unput( ')' );\n"
"    for ( i = yyleng - 1; i E<gt>= 0; --i )\n"
"        unput( yycopy[i] );\n"
"    unput( '(' );\n"
"    free( yycopy );\n"
"    }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:955
msgid ""
"Note that since each B<unput()> puts the given character back at the "
"I<beginning> of the input stream, pushing back strings must be done "
"back-to-front."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:974
msgid ""
"An important potential problem when using B<unput()> is that if you are "
"using B<%pointer> (the default), a call to B<unput()> I<destroys> the "
"contents of I<yytext,> starting with its rightmost character and devouring "
"one character to the left with each call.  If you need the value of yytext "
"preserved after a call to B<unput()> (as in the above example), you must "
"either first copy it elsewhere, or build your scanner using B<%array> "
"instead (see How The Input Is Matched)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:978
msgid ""
"Finally, note that you cannot put back B<EOF> to attempt to mark the input "
"stream with an end-of-file."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:983
msgid ""
"B<input()> reads the next character from the input stream.  For example, the "
"following is one way to eat up C comments:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:988
#, no-wrap
msgid ""
"    %%\n"
"    \"/*\"        {\n"
"                int c;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:994
#, no-wrap
msgid ""
"                for ( ; ; )\n"
"                    {\n"
"                    while ( (c = input()) != '*' &&\n"
"                            c != EOF )\n"
"                        ;    /* eat up text of comment */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1002
#, no-wrap
msgid ""
"                    if ( c == '*' )\n"
"                        {\n"
"                        while ( (c = input()) == '*' )\n"
"                            ;\n"
"                        if ( c == '/' )\n"
"                            break;    /* found the end */\n"
"                        }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1010
#, no-wrap
msgid ""
"                    if ( c == EOF )\n"
"                        {\n"
"                        error( \"EOF in comment\" );\n"
"                        break;\n"
"                        }\n"
"                    }\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1022
msgid ""
"(Note that if the scanner is compiled using B<C++,> then B<input()> is "
"instead referred to as B<yyinput(),> in order to avoid a name clash with the "
"B<C++> stream by the name of I<input.)>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1033
msgid ""
"B<YY_FLUSH_BUFFER> flushes the scanner's internal buffer so that the next "
"time the scanner attempts to match a token, it will first refill the buffer "
"using B<YY_INPUT> (see The Generated Scanner, below).  This action is a "
"special case of the more general B<yy_flush_buffer()> function, described "
"below in the section Multiple Input Buffers."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1042
msgid ""
"B<yyterminate()> can be used in lieu of a return statement in an action.  It "
"terminates the scanner and returns a 0 to the scanner's caller, indicating "
"\"all done\".  By default, B<yyterminate()> is also called when an "
"end-of-file is encountered.  It is a macro and may be redefined."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:1042
#, no-wrap
msgid "THE GENERATED SCANNER"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1054
msgid ""
"The output of I<flex> is the file B<lex.yy.c,> which contains the scanning "
"routine B<yylex(),> a number of tables used by it for matching tokens, and a "
"number of auxiliary routines and macros.  By default, B<yylex()> is declared "
"as follows:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1060
#, no-wrap
msgid ""
"    int yylex()\n"
"        {\n"
"        ... various definitions and the actions in here ...\n"
"        }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1066
msgid ""
"(If your environment supports function prototypes, then it will be \"int "
"yylex( void )\".)  This definition may be changed by defining the "
"\"YY_DECL\" macro.  For example, you could use:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1069
#, no-wrap
msgid "    #define YY_DECL float lexscan( a, b ) float a, b;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1078
msgid ""
"to give the scanning routine the name I<lexscan,> returning a float, and "
"taking two floats as arguments.  Note that if you give arguments to the "
"scanning routine using a K&R-style/non-prototyped function declaration, you "
"must terminate the definition with a semi-colon (;)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1089
msgid ""
"Whenever B<yylex()> is called, it scans tokens from the global input file "
"I<yyin> (which defaults to stdin).  It continues until it either reaches an "
"end-of-file (at which point it returns the value 0) or one of its actions "
"executes a I<return> statement."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1129
msgid ""
"If the scanner reaches an end-of-file, subsequent calls are undefined unless "
"either I<yyin> is pointed at a new input file (in which case scanning "
"continues from that file), or B<yyrestart()> is called.  B<yyrestart()> "
"takes one argument, a B<FILE *> pointer (which can be nil, if you've set up "
"B<YY_INPUT> to scan from a source other than I<yyin),> and initializes "
"I<yyin> for scanning from that file.  Essentially there is no difference "
"between just assigning I<yyin> to a new input file or using B<yyrestart()> "
"to do so; the latter is available for compatibility with previous versions "
"of I<flex,> and because it can be used to switch input files in the middle "
"of scanning.  It can also be used to throw away the current input buffer, by "
"calling it with an argument of I<yyin;> but better is to use "
"B<YY_FLUSH_BUFFER> (see above).  Note that B<yyrestart()> does I<not> reset "
"the start condition to B<INITIAL> (see Start Conditions, below)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1136
msgid ""
"If B<yylex()> stops scanning due to executing a I<return> statement in one "
"of the actions, the scanner may then be called again and it will resume "
"scanning where it left off."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1157
msgid ""
"By default (and for purposes of efficiency), the scanner uses block-reads "
"rather than simple I<getc()> calls to read characters from I<yyin.> The "
"nature of how it gets its input can be controlled by defining the "
"B<YY_INPUT> macro.  YY_INPUT's calling sequence is "
"\"YY_INPUT(buf,result,max_size)\".  Its action is to place up to I<max_size> "
"characters in the character array I<buf> and return in the integer variable "
"I<result> either the number of characters read or the constant YY_NULL (0 on "
"Unix systems)  to indicate EOF.  The default YY_INPUT reads from the global "
"file-pointer \"yyin\"."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1160
msgid ""
"A sample definition of YY_INPUT (in the definitions section of the input "
"file):"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1169
#, no-wrap
msgid ""
"    %{\n"
"    #define YY_INPUT(buf,result,max_size) \\e\n"
"        { \\e\n"
"        int c = getchar(); \\e\n"
"        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \\e\n"
"        }\n"
"    %}\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1173
msgid ""
"This definition will change the input processing to occur one character at a "
"time."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1192
msgid ""
"When the scanner receives an end-of-file indication from YY_INPUT, it then "
"checks the B<yywrap()> function.  If B<yywrap()> returns false (zero), then "
"it is assumed that the function has gone ahead and set up I<yyin> to point "
"to another input file, and scanning continues.  If it returns true "
"(non-zero), then the scanner terminates, returning 0 to its caller.  Note "
"that in either case, the start condition remains unchanged; it does I<not> "
"revert to B<INITIAL.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1202
msgid ""
"If you do not supply your own version of B<yywrap(),> then you must either "
"use B<%option noyywrap> (in which case the scanner behaves as though "
"B<yywrap()> returned 1), or you must link with B<-ll> to obtain the default "
"version of the routine, which always returns 1."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1209
msgid ""
"Three routines are available for scanning from in-memory buffers rather than "
"files: B<yy_scan_string(), yy_scan_bytes(),> and B<yy_scan_buffer().> See "
"the discussion of them below in the section Multiple Input Buffers."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1218
msgid ""
"The scanner writes its B<ECHO> output to the I<yyout> global (default, "
"stdout), which may be redefined by the user simply by assigning it to some "
"other B<FILE> pointer."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:1218
#, no-wrap
msgid "START CONDITIONS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1225
msgid ""
"I<flex> provides a mechanism for conditionally activating rules.  Any rule "
"whose pattern is prefixed with \"E<lt>scE<gt>\" will only be active when the "
"scanner is in the start condition named \"sc\".  For example,"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1230
#, no-wrap
msgid ""
"    E<lt>STRINGE<gt>[^\"]*        { /* eat up the string body ... */\n"
"                ...\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1234
msgid ""
"will be active only when the scanner is in the \"STRING\" start condition, "
"and"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1239
#, no-wrap
msgid ""
"    E<lt>INITIAL,STRING,QUOTEE<gt>\\e.        { /* handle an escape ... */\n"
"                ...\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1243
msgid ""
"will be active only when the current start condition is either \"INITIAL\", "
"\"STRING\", or \"QUOTE\"."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1280
msgid ""
"Start conditions are declared in the definitions (first) section of the "
"input using unindented lines beginning with either B<%s> or B<%x> followed "
"by a list of names.  The former declares I<inclusive> start conditions, the "
"latter I<exclusive> start conditions.  A start condition is activated using "
"the B<BEGIN> action.  Until the next B<BEGIN> action is executed, rules with "
"the given start condition will be active and rules with other start "
"conditions will be inactive.  If the start condition is I<inclusive,> then "
"rules with no start conditions at all will also be active.  If it is "
"I<exclusive,> then I<only> rules qualified with the start condition will be "
"active.  A set of rules contingent on the same exclusive start condition "
"describe a scanner which is independent of any of the other rules in the "
"I<flex> input.  Because of this, exclusive start conditions make it easy to "
"specify \"mini-scanners\" which scan portions of the input that are "
"syntactically different from the rest (e.g., comments)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1285
msgid ""
"If the distinction between inclusive and exclusive start conditions is still "
"a little vague, here's a simple example illustrating the connection between "
"the two.  The set of rules:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1289
#, no-wrap
msgid ""
"    %s example\n"
"    %%\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1291 /usr/src/usr.bin/lex/lex.1:1302 /usr/src/usr.bin/lex/lex.1:1339
#, no-wrap
msgid "    E<lt>exampleE<gt>foo   do_something();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1293
#, no-wrap
msgid "    bar            something_else();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1296
msgid "is equivalent to"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1300 /usr/src/usr.bin/lex/lex.1:1337
#, no-wrap
msgid ""
"    %x example\n"
"    %%\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1304
#, no-wrap
msgid "    E<lt>INITIAL,exampleE<gt>bar    something_else();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1328
msgid ""
"Without the B<E<lt>INITIAL,exampleE<gt>> qualifier, the I<bar> pattern in "
"the second example wouldn't be active (i.e., couldn't match)  when in start "
"condition B<example.> If we just used B<E<lt>exampleE<gt>> to qualify "
"I<bar,> though, then it would only be active in B<example> and not in "
"B<INITIAL,> while in the first example it's active in both, because in the "
"first example the B<example> start condition is an I<inclusive> B<(%s)> "
"start condition."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1333
msgid ""
"Also note that the special start-condition specifier B<E<lt>*E<gt>> matches "
"every start condition.  Thus, the above example could also have been "
"written;"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1341
#, no-wrap
msgid "    E<lt>*E<gt>bar    something_else();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1349
msgid ""
"The default rule (to B<ECHO> any unmatched character) remains active in "
"start conditions.  It is equivalent to:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1352
#, no-wrap
msgid "    E<lt>*E<gt>.|\\en     ECHO;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1365
msgid ""
"B<BEGIN(0)> returns to the original state where only the rules with no start "
"conditions are active.  This state can also be referred to as the "
"start-condition \"INITIAL\", so B<BEGIN(INITIAL)> is equivalent to "
"B<BEGIN(0).> (The parentheses around the start condition name are not "
"required but are considered good style.)"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1375
msgid ""
"B<BEGIN> actions can also be given as indented code at the beginning of the "
"rules section.  For example, the following will cause the scanner to enter "
"the \"SPECIAL\" start condition whenever B<yylex()> is called and the global "
"variable I<enter_special> is true:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1378
#, no-wrap
msgid "            int enter_special;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1383
#, no-wrap
msgid ""
"    %x SPECIAL\n"
"    %%\n"
"            if ( enter_special )\n"
"                BEGIN(SPECIAL);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1386
#, no-wrap
msgid ""
"    E<lt>SPECIALE<gt>blahblahblah\n"
"    ...more rules follow...\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1398
msgid ""
"To illustrate the uses of start conditions, here is a scanner which provides "
"two different interpretations of a string like \"123.456\".  By default it "
"will treat it as three tokens, the integer \"123\", a dot ('.'), and the "
"integer \"456\".  But if the string is preceded earlier in the line by the "
"string \"expect-floats\" it will treat it as a single token, the "
"floating-point number 123.456:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1404
#, no-wrap
msgid ""
"    %{\n"
"    #include E<lt>math.hE<gt>\n"
"    %}\n"
"    %s expect\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1407
#, no-wrap
msgid ""
"    %%\n"
"    expect-floats        BEGIN(expect);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1420
#, no-wrap
msgid ""
"    E<lt>expectE<gt>[0-9]+\".\"[0-9]+      {\n"
"                printf( \"found a float, = %f\\en\",\n"
"                        atof( yytext ) );\n"
"                }\n"
"    E<lt>expectE<gt>\\en           {\n"
"                /* that's the end of the line, so\n"
"                 * we need another \"expect-number\"\n"
"                 * before we'll recognize any more\n"
"                 * numbers\n"
"                 */\n"
"                BEGIN(INITIAL);\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1425
#, no-wrap
msgid ""
"    [0-9]+      {\n"
"                printf( \"found an integer, = %d\\en\",\n"
"                        atoi( yytext ) );\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1427
#, no-wrap
msgid "    \".\"         printf( \"found a dot\\en\" );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1431
msgid ""
"Here is a scanner which recognizes (and discards) C comments while "
"maintaining a count of the current input line."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1436 /usr/src/usr.bin/lex/lex.1:3229 /usr/src/usr.bin/lex/lex.1:3244
#, no-wrap
msgid ""
"    %x comment\n"
"    %%\n"
"            int line_num = 1;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1438 /usr/src/usr.bin/lex/lex.1:3231 /usr/src/usr.bin/lex/lex.1:3246
#, no-wrap
msgid "    \"/*\"         BEGIN(comment);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1443
#, no-wrap
msgid ""
"    E<lt>commentE<gt>[^*\\en]*        /* eat anything that's not a '*' */\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*   /* eat up '*'s not followed by '/'s "
"*/\n"
"    E<lt>commentE<gt>\\en             ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1450
msgid ""
"This scanner goes to a bit of trouble to match as much text as possible with "
"each rule.  In general, when attempting to write a high-speed scanner try to "
"match as much possible in each rule, as it's a big win."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1455
msgid ""
"Note that start-conditions names are really integer values and can be stored "
"as such.  Thus, the above could be extended in the following fashion:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1461
#, no-wrap
msgid ""
"    %x comment foo\n"
"    %%\n"
"            int line_num = 1;\n"
"            int comment_caller;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1466
#, no-wrap
msgid ""
"    \"/*\"         {\n"
"                 comment_caller = INITIAL;\n"
"                 BEGIN(comment);\n"
"                 }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1468
#, no-wrap
msgid "    ...\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1473
#, no-wrap
msgid ""
"    E<lt>fooE<gt>\"/*\"    {\n"
"                 comment_caller = foo;\n"
"                 BEGIN(comment);\n"
"                 }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1478
#, no-wrap
msgid ""
"    E<lt>commentE<gt>[^*\\en]*        /* eat anything that's not a '*' */\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*   /* eat up '*'s not followed by '/'s "
"*/\n"
"    E<lt>commentE<gt>\\en             ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(comment_caller);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1487
msgid ""
"Furthermore, you can access the current start condition using the "
"integer-valued B<YY_START> macro.  For example, the above assignments to "
"I<comment_caller> could instead be written"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1490
#, no-wrap
msgid "    comment_caller = YY_START;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1498
msgid ""
"Flex provides B<YYSTATE> as an alias for B<YY_START> (since that is what's "
"used by AT&T I<lex).>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1501
msgid ""
"Note that start conditions do not have their own name-space; %s's and %x's "
"declare names in the same fashion as #define's."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1505
msgid ""
"Finally, here's an example of how to match C-style quoted strings using "
"exclusive start conditions, including expanded escape sequences (but not "
"including checking for a string that's too long):"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1508
#, no-wrap
msgid "    %x str\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1512
#, no-wrap
msgid ""
"    %%\n"
"            char string_buf[MAX_STR_CONST];\n"
"            char *string_buf_ptr;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1515
#, no-wrap
msgid "    \\e\"      string_buf_ptr = string_buf; BEGIN(str);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1523
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\e\"        { /* saw closing quote - all done */\n"
"            BEGIN(INITIAL);\n"
"            *string_buf_ptr = '\\e0';\n"
"            /* return string constant token type and\n"
"             * value to parser\n"
"             */\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1528
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\en        {\n"
"            /* error - unterminated string constant */\n"
"            /* generate error message */\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1532
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\e\\e[0-7]{1,3} {\n"
"            /* octal escape sequence */\n"
"            int result;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1534
#, no-wrap
msgid "            (void) sscanf( yytext + 1, \"%o\", &result );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1537
#, no-wrap
msgid ""
"            if ( result E<gt> 0xff )\n"
"                    /* error, constant is out-of-bounds */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1540
#, no-wrap
msgid ""
"            *string_buf_ptr++ = result;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1546
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\e\\e[0-9]+ {\n"
"            /* generate error - bad escape sequence; something\n"
"             * like '\\e48' or '\\e0777777'\n"
"             */\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1552
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\e\\en  *string_buf_ptr++ = '\\en';\n"
"    E<lt>strE<gt>\\e\\et  *string_buf_ptr++ = '\\et';\n"
"    E<lt>strE<gt>\\e\\er  *string_buf_ptr++ = '\\er';\n"
"    E<lt>strE<gt>\\e\\eb  *string_buf_ptr++ = '\\eb';\n"
"    E<lt>strE<gt>\\e\\ef  *string_buf_ptr++ = '\\ef';\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1554
#, no-wrap
msgid "    E<lt>strE<gt>\\e\\e(.|\\en)  *string_buf_ptr++ = yytext[1];\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1557
#, no-wrap
msgid ""
"    E<lt>strE<gt>[^\\e\\e\\en\\e\"]+        {\n"
"            char *yptr = yytext;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1561
#, no-wrap
msgid ""
"            while ( *yptr )\n"
"                    *string_buf_ptr++ = *yptr++;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1570
msgid ""
"Often, such as in some of the examples above, you wind up writing a whole "
"bunch of rules all preceded by the same start condition(s).  Flex makes this "
"a little easier and cleaner by introducing a notion of start condition "
"I<scope.> A start condition scope is begun with:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1573
#, no-wrap
msgid "    E<lt>SCsE<gt>{\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1586
msgid ""
"where I<SCs> is a list of one or more start conditions.  Inside the start "
"condition scope, every rule automatically has the prefix I<E<lt>SCsE<gt>> "
"applied to it, until a I<'}'> which matches the initial I<'{'.> So, for "
"example,"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1594
#, no-wrap
msgid ""
"    E<lt>ESCE<gt>{\n"
"        \"\\e\\en\"   return '\\en';\n"
"        \"\\e\\er\"   return '\\er';\n"
"        \"\\e\\ef\"   return '\\ef';\n"
"        \"\\e\\e0\"   return '\\e0';\n"
"    }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1597
msgid "is equivalent to:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1603
#, no-wrap
msgid ""
"    E<lt>ESCE<gt>\"\\e\\en\"  return '\\en';\n"
"    E<lt>ESCE<gt>\"\\e\\er\"  return '\\er';\n"
"    E<lt>ESCE<gt>\"\\e\\ef\"  return '\\ef';\n"
"    E<lt>ESCE<gt>\"\\e\\e0\"  return '\\e0';\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1606
msgid "Start condition scopes may be nested."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1608
msgid "Three routines are available for manipulating stacks of start conditions:"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:1608
#, no-wrap
msgid "B<void yy_push_state(int new_state)>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1616
msgid ""
"pushes the current start condition onto the top of the start condition stack "
"and switches to I<new_state> as though you had used B<BEGIN new_state> "
"(recall that start condition names are also integers)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:1616
#, no-wrap
msgid "B<void yy_pop_state()>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1620
msgid "pops the top of the stack and switches to it via B<BEGIN.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:1620
#, no-wrap
msgid "B<int yy_top_state()>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1623
msgid "returns the top of the stack without altering the stack's contents."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1627
msgid ""
"The start condition stack grows dynamically and so has no built-in size "
"limitation.  If memory is exhausted, program execution aborts."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1631
msgid ""
"To use start condition stacks, your scanner must include a B<%option stack> "
"directive (see Options below)."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:1631
#, no-wrap
msgid "MULTIPLE INPUT BUFFERS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1644
msgid ""
"Some scanners (such as those which support \"include\" files)  require "
"reading from several input streams.  As I<flex> scanners do a large amount "
"of buffering, one cannot control where the next input will be read from by "
"simply writing a B<YY_INPUT> which is sensitive to the scanning context.  "
"B<YY_INPUT> is only called when the scanner reaches the end of its buffer, "
"which may be a long time after scanning a statement such as an \"include\" "
"which requires switching the input source."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1650
msgid ""
"To negotiate these sorts of problems, I<flex> provides a mechanism for "
"creating and switching between multiple input buffers.  An input buffer is "
"created by using:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1653
#, no-wrap
msgid "    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1692
msgid ""
"which takes a I<FILE> pointer and a size and creates a buffer associated "
"with the given file and large enough to hold I<size> characters (when in "
"doubt, use B<YY_BUF_SIZE> for the size).  It returns a B<YY_BUFFER_STATE> "
"handle, which may then be passed to other routines (see below).  The "
"B<YY_BUFFER_STATE> type is a pointer to an opaque B<struct yy_buffer_state> "
"structure, so you may safely initialize YY_BUFFER_STATE variables to "
"B<((YY_BUFFER_STATE) 0)> if you wish, and also refer to the opaque structure "
"in order to correctly declare input buffers in source files other than that "
"of your scanner.  Note that the I<FILE> pointer in the call to "
"B<yy_create_buffer> is only used as the value of I<yyin> seen by "
"B<YY_INPUT;> if you redefine B<YY_INPUT> so it no longer uses I<yyin,> then "
"you can safely pass a nil I<FILE> pointer to B<yy_create_buffer.> You select "
"a particular buffer to scan from using:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1695
#, no-wrap
msgid "    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1713
msgid ""
"switches the scanner's input buffer so subsequent tokens will come from "
"I<new_buffer.> Note that B<yy_switch_to_buffer()> may be used by yywrap() to "
"set things up for continued scanning, instead of opening a new file and "
"pointing I<yyin> at it.  Note also that switching input sources via either "
"B<yy_switch_to_buffer()> or B<yywrap()> does I<not> change the start "
"condition."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1716
#, no-wrap
msgid "    void yy_delete_buffer( YY_BUFFER_STATE buffer )\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1723
msgid ""
"is used to reclaim the storage associated with a buffer.  ( B<buffer> can be "
"nil, in which case the routine does nothing.)  You can also clear the "
"current contents of a buffer using:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1726
#, no-wrap
msgid "    void yy_flush_buffer( YY_BUFFER_STATE buffer )\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1732
msgid ""
"This function discards the buffer's contents, so the next time the scanner "
"attempts to match a token from the buffer, it will first fill the buffer "
"anew using B<YY_INPUT.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1741
msgid ""
"B<yy_new_buffer()> is an alias for B<yy_create_buffer(),> provided for "
"compatibility with the C++ use of I<new> and I<delete> for creating and "
"destroying dynamic objects."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1747
msgid ""
"Finally, the B<YY_CURRENT_BUFFER> macro returns a B<YY_BUFFER_STATE> handle "
"to the current buffer."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1752
msgid ""
"Here is an example of using these features for writing a scanner which "
"expands include files (the B<E<lt>E<lt>EOFE<gt>E<gt>> feature is discussed "
"below):"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1758
#, no-wrap
msgid ""
"    /* the \"incl\" state is used for picking up the name\n"
"     * of an include file\n"
"     */\n"
"    %x incl\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1764
#, no-wrap
msgid ""
"    %{\n"
"    #define MAX_INCLUDE_DEPTH 10\n"
"    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];\n"
"    int include_stack_ptr = 0;\n"
"    %}\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1767
#, no-wrap
msgid ""
"    %%\n"
"    include             BEGIN(incl);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1770
#, no-wrap
msgid ""
"    [a-z]+              ECHO;\n"
"    [^a-z\\en]*\\en?        ECHO;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1778
#, no-wrap
msgid ""
"    E<lt>inclE<gt>[ \\et]*      /* eat the whitespace */\n"
"    E<lt>inclE<gt>[^ \\et\\en]+   { /* got the include file name */\n"
"            if ( include_stack_ptr E<gt>= MAX_INCLUDE_DEPTH )\n"
"                {\n"
"                fprintf( stderr, \"Includes nested too deeply\" );\n"
"                exit( 1 );\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1781
#, no-wrap
msgid ""
"            include_stack[include_stack_ptr++] =\n"
"                YY_CURRENT_BUFFER;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1783
#, no-wrap
msgid "            yyin = fopen( yytext, \"r\" );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1786
#, no-wrap
msgid ""
"            if ( ! yyin )\n"
"                error( ... );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1789
#, no-wrap
msgid ""
"            yy_switch_to_buffer(\n"
"                yy_create_buffer( yyin, YY_BUF_SIZE ) );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1792
#, no-wrap
msgid ""
"            BEGIN(INITIAL);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1798
#, no-wrap
msgid ""
"    E<lt>E<lt>EOFE<gt>E<gt> {\n"
"            if ( --include_stack_ptr E<lt> 0 )\n"
"                {\n"
"                yyterminate();\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1806
#, no-wrap
msgid ""
"            else\n"
"                {\n"
"                yy_delete_buffer( YY_CURRENT_BUFFER );\n"
"                yy_switch_to_buffer(\n"
"                     include_stack[include_stack_ptr] );\n"
"                }\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1821
msgid ""
"Three routines are available for setting up input buffers for scanning "
"in-memory strings instead of files.  All of them create a new input buffer "
"for scanning the string, and return a corresponding B<YY_BUFFER_STATE> "
"handle (which you should delete with B<yy_delete_buffer()> when done with "
"it).  They also switch to the new buffer using B<yy_switch_to_buffer(),> so "
"the next call to B<yylex()> will start scanning the string."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:1821
#, no-wrap
msgid "B<yy_scan_string(const char *str)>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1824
msgid "scans a NUL-terminated string."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:1824
#, no-wrap
msgid "B<yy_scan_bytes(const char *bytes, int len)>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1831
msgid ""
"scans I<len> bytes (including possibly NUL's)  starting at location "
"I<bytes.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1839
msgid ""
"Note that both of these functions create and scan a I<copy> of the string or "
"bytes.  (This may be desirable, since B<yylex()> modifies the contents of "
"the buffer it is scanning.)  You can avoid the copy by using:"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:1839
#, no-wrap
msgid "B<yy_scan_buffer(char *base, yy_size_t size)>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1856
msgid ""
"which scans in place the buffer starting at I<base,> consisting of I<size> "
"bytes, the last two bytes of which I<must> be B<YY_END_OF_BUFFER_CHAR> "
"(ASCII NUL).  These last two bytes are not scanned; thus, scanning consists "
"of B<base[0]> through B<base[size-2],> inclusive."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1864
msgid ""
"If you fail to set up I<base> in this manner (i.e., forget the final two "
"B<YY_END_OF_BUFFER_CHAR> bytes), then B<yy_scan_buffer()> returns a nil "
"pointer instead of creating a new input buffer."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1869
msgid ""
"The type B<yy_size_t> is an integral type to which you can cast an integer "
"expression reflecting the size of the buffer."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:1869
#, no-wrap
msgid "END-OF-FILE RULES"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1876
msgid ""
"The special rule \"E<lt>E<lt>EOFE<gt>E<gt>\" indicates actions which are to "
"be taken when an end-of-file is encountered and yywrap() returns non-zero "
"(i.e., indicates no further files to process).  The action must finish by "
"doing one of four things:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1883
msgid ""
"assigning I<yyin> to a new input file (in previous versions of flex, after "
"doing the assignment you had to call the special action B<YY_NEW_FILE;> this "
"is no longer necessary);"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1887
msgid "executing a I<return> statement;"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1891
msgid "executing the special B<yyterminate()> action;"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1895
msgid ""
"or, switching to a new buffer using B<yy_switch_to_buffer()> as shown in the "
"example above."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1905
msgid ""
"E<lt>E<lt>EOFE<gt>E<gt> rules may not be used with other patterns; they may "
"only be qualified with a list of start conditions.  If an unqualified "
"E<lt>E<lt>EOFE<gt>E<gt> rule is given, it applies to I<all> start conditions "
"which do not already have E<lt>E<lt>EOFE<gt>E<gt> actions.  To specify an "
"E<lt>E<lt>EOFE<gt>E<gt> rule for only the initial start condition, use"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1908
#, no-wrap
msgid "    E<lt>INITIALE<gt>E<lt>E<lt>EOFE<gt>E<gt>\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1913
msgid ""
"These rules are useful for catching things like unclosed comments.  An "
"example:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1917
#, no-wrap
msgid ""
"    %x quote\n"
"    %%\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1919
#, no-wrap
msgid "    ...other rules for dealing with quotes...\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1930
#, no-wrap
msgid ""
"    E<lt>quoteE<gt>E<lt>E<lt>EOFE<gt>E<gt>   {\n"
"             error( \"unterminated quote\" );\n"
"             yyterminate();\n"
"             }\n"
"    E<lt>E<lt>EOFE<gt>E<gt>  {\n"
"             if ( *++filelist )\n"
"                 yyin = fopen( *filelist, \"r\" );\n"
"             else\n"
"                yyterminate();\n"
"             }\n"
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:1932
#, no-wrap
msgid "MISCELLANEOUS MACROS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1946
msgid ""
"The macro B<YY_USER_ACTION> can be defined to provide an action which is "
"always executed prior to the matched rule's action.  For example, it could "
"be #define'd to call a routine to convert yytext to lower-case.  When "
"B<YY_USER_ACTION> is invoked, the variable I<yy_act> gives the number of the "
"matched rule (rules are numbered starting with 1).  Suppose you want to "
"profile how often each of your rules is matched.  The following would do the "
"trick:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1949
#, no-wrap
msgid "    #define YY_USER_ACTION ++ctr[yy_act]\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1962
msgid ""
"where I<ctr> is an array to hold the counts for the different rules.  Note "
"that the macro B<YY_NUM_RULES> gives the total number of rules (including "
"the default rule, even if you use B<-s),> so a correct declaration for "
"I<ctr> is:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1965
#, no-wrap
msgid "    int ctr[YY_NUM_RULES];\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1974
msgid ""
"The macro B<YY_USER_INIT> may be defined to provide an action which is "
"always executed before the first scan (and before the scanner's internal "
"initializations are done).  For example, it could be used to call a routine "
"to read in a data table or open a logging file."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:1997
msgid ""
"The macro B<yy_set_interactive(is_interactive)> can be used to control "
"whether the current buffer is considered I<interactive.> An interactive "
"buffer is processed more slowly, but must be used when the scanner's input "
"source is indeed interactive to avoid problems due to waiting to fill "
"buffers (see the discussion of the B<-I> flag below).  A non-zero value in "
"the macro invocation marks the buffer as interactive, a zero value as "
"non-interactive.  Note that use of this macro overrides B<%option "
"interactive ,> B<%option always-interactive> or B<%option never-interactive> "
"(see Options below).  B<yy_set_interactive()> must be invoked prior to "
"beginning to scan the buffer that is (or is not) to be considered "
"interactive."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2005
#, no-wrap
msgid ""
"The macro\n"
"B<yy_set_bol(at_bol)>\n"
"can be used to control whether the current buffer's scanning\n"
"context for the next token match is done as though at the\n"
"beginning of a line.\n"
"A non-zero macro argument makes rules anchored with\n"
" '^' active, while a zero argument makes '^' rules inactive.\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2010
msgid ""
"The macro B<YY_AT_BOL()> returns true if the next token scanned from the "
"current buffer will have '^' rules active, false otherwise."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2026
msgid ""
"In the generated scanner, the actions are all gathered in one large switch "
"statement and separated using B<YY_BREAK,> which may be redefined.  By "
"default, it is simply a \"break\", to separate each rule's action from the "
"following rule's.  Redefining B<YY_BREAK> allows, for example, C++ users to "
"#define YY_BREAK to do nothing (while being very careful that every rule "
"ends with a \"break\" or a \"return\"!) to avoid suffering from unreachable "
"statement warnings where because a rule's action ends with \"return\", the "
"B<YY_BREAK> is inaccessible."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:2026
#, no-wrap
msgid "VALUES AVAILABLE TO THE USER"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2029
msgid ""
"This section summarizes the various values available to the user in the rule "
"actions."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2034
msgid ""
"B<char *yytext> holds the text of the current token.  It may be modified but "
"not lengthened (you cannot append characters to the end)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2061
msgid ""
"If the special directive B<%array> appears in the first section of the "
"scanner description, then B<yytext> is instead declared B<char "
"yytext[YYLMAX],> where B<YYLMAX> is a macro definition that you can redefine "
"in the first section if you don't like the default value (generally 8KB).  "
"Using B<%array> results in somewhat slower scanners, but the value of "
"B<yytext> becomes immune to calls to I<input()> and I<unput(),> which "
"potentially destroy its value when B<yytext> is a character pointer.  The "
"opposite of B<%array> is B<%pointer,> which is the default."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2068
msgid ""
"You cannot use B<%array> when generating C++ scanner classes (the B<-+> "
"flag)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2071
msgid "B<int yyleng> holds the length of the current token."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2087
msgid ""
"B<FILE *yyin> is the file which by default I<flex> reads from.  It may be "
"redefined but doing so only makes sense before scanning begins or after an "
"EOF has been encountered.  Changing it in the midst of scanning will have "
"unexpected results since I<flex> buffers its input; use B<yyrestart()> "
"instead.  Once scanning terminates because an end-of-file has been seen, you "
"can assign I<yyin> at the new input file and then call the scanner again to "
"continue scanning."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2100
msgid ""
"B<void yyrestart( FILE *new_file )> may be called to point I<yyin> at the "
"new input file.  The switch-over to the new file is immediate (any "
"previously buffered-up input is lost).  Note that calling B<yyrestart()> "
"with I<yyin> as an argument thus throws away the current input buffer and "
"continues scanning the same input file."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2106
msgid ""
"B<FILE *yyout> is the file to which B<ECHO> actions are done.  It can be "
"reassigned by the user."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2111
msgid ""
"B<YY_CURRENT_BUFFER> returns a B<YY_BUFFER_STATE> handle to the current "
"buffer."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2118
msgid ""
"B<YY_START> returns an integer value corresponding to the current start "
"condition.  You can subsequently use this value with B<BEGIN> to return to "
"that start condition."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:2118
#, no-wrap
msgid "INTERFACING WITH YACC"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2152
msgid ""
"One of the main uses of I<flex> is as a companion to the I<yacc> "
"parser-generator.  I<yacc> parsers expect to call a routine named B<yylex()> "
"to find the next input token.  The routine is supposed to return the type of "
"the next token as well as putting any associated value in the global "
"B<yylval.> To use I<flex> with I<yacc,> one specifies the B<-d> option to "
"I<yacc> to instruct it to generate the file B<y.tab.h> containing "
"definitions of all the B<%tokens> appearing in the I<yacc> input.  This file "
"is then included in the I<flex> scanner.  For example, if one of the tokens "
"is \"TOK_NUMBER\", part of the scanner might look like:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2157
#, no-wrap
msgid ""
"    %{\n"
"    #include \"y.tab.h\"\n"
"    %}\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2161
#, no-wrap
msgid "    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;\n"
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:2163
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2166
msgid "I<flex> has the following options:"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2166
#, no-wrap
msgid "B<-b, --backup>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2186
msgid ""
"Generate backing-up information to I<lex.backup.> This is a list of scanner "
"states which require backing up and the input characters on which they do "
"so.  By adding rules one can remove backing-up states.  If I<all> backing-up "
"states are eliminated and B<-Cf> or B<-CF> is used, the generated scanner "
"will run faster (see the B<-p> flag).  Only users who wish to squeeze every "
"last cycle out of their scanners need worry about this option.  (See the "
"section on Performance Considerations below.)"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2186
#, no-wrap
msgid "B<-c>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2189
msgid "is a do-nothing, deprecated option included for POSIX compliance."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2189
#, no-wrap
msgid "B<-d, --debug>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2200
msgid ""
"makes the generated scanner run in I<debug> mode.  Whenever a pattern is "
"recognized and the global B<yy_flex_debug> is non-zero (which is the "
"default), the scanner will write to I<stderr> a line of the form:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2203
#, no-wrap
msgid "    --accepting rule at line 53 (\"the matched text\")\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2211
msgid ""
"The line number refers to the location of the rule in the file defining the "
"scanner (i.e., the file that was fed to flex).  Messages are also generated "
"when the scanner backs up, accepts the default rule, reaches the end of its "
"input buffer (or encounters a NUL; at this point, the two look the same as "
"far as the scanner's concerned), or reaches an end-of-file."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2211
#, no-wrap
msgid "B<-f, --full>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2220
msgid ""
"specifies I<fast scanner.> No table compression is done and stdio is "
"bypassed.  The result is large but fast.  This option is equivalent to "
"B<-Cfr> (see below)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2220
#, no-wrap
msgid "B<-h, --help>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2232
msgid ""
"generates a \"help\" summary of I<flex's> options to I<stdout> and then "
"exits.  B<-?> and B<--help> are synonyms for B<-h.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2232
#, no-wrap
msgid "B<-i, --case-insensitive>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2246
msgid ""
"instructs I<flex> to generate a I<case-insensitive> scanner.  The case of "
"letters given in the I<flex> input patterns will be ignored, and tokens in "
"the input will be matched regardless of case.  The matched text given in "
"I<yytext> will have the preserved case (i.e., it will not be folded)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2246
#, no-wrap
msgid "B<-l, --lex-compat>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2266
msgid ""
"turns on maximum compatibility with the original AT&T I<lex> "
"implementation.  Note that this does not mean I<full> compatibility.  Use of "
"this option costs a considerable amount of performance, and it cannot be "
"used with the B<-+, -f, -F, -Cf,> or B<-CF> options.  For details on the "
"compatibilities it provides, see the section \"Incompatibilities With Lex "
"And POSIX\" below.  This option also results in the name "
"B<YY_FLEX_LEX_COMPAT> being #define'd in the generated scanner."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2266
#, no-wrap
msgid "B<-n>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2270
msgid "is another do-nothing, deprecated option included only for POSIX compliance."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2270
#, no-wrap
msgid "B<-p, --perf-report>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2279
msgid ""
"generates a performance report to stderr.  The report consists of comments "
"regarding features of the I<flex> input file which will cause a serious loss "
"of performance in the resulting scanner.  If you give the flag twice, you "
"will also get comments regarding features that lead to minor performance "
"losses."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2292
msgid ""
"Note that the use of B<REJECT,> B<%option yylineno,> and variable trailing "
"context (see the Deficiencies / Bugs section below)  entails a substantial "
"performance penalty; use of I<yymore(),> the B<^> operator, and the B<-I> "
"flag entail minor performance penalties."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2292
#, no-wrap
msgid "B<-s, --no-default>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2303
msgid ""
"causes the I<default rule> (that unmatched scanner input is echoed to "
"I<stdout)> to be suppressed.  If the scanner encounters input that does not "
"match any of its rules, it aborts with an error.  This option is useful for "
"finding holes in a scanner's rule set."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2303
#, no-wrap
msgid "B<-t, --stdout>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2310
msgid ""
"instructs I<flex> to write the scanner it generates to standard output "
"instead of B<lex.yy.c.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2310
#, no-wrap
msgid "B<-v, --verbose>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2325
msgid ""
"specifies that I<flex> should write to I<stderr> a summary of statistics "
"regarding the scanner it generates.  Most of the statistics are meaningless "
"to the casual I<flex> user, but the first line identifies the version of "
"I<flex> (same as reported by B<-V),> and the next line the flags used when "
"generating the scanner, including those that are on by default."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2325
#, no-wrap
msgid "B<-w, --nowarn>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2328
msgid "suppresses warning messages."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2328
#, no-wrap
msgid "B<-B, --batch>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2356
msgid ""
"instructs I<flex> to generate a I<batch> scanner, the opposite of "
"I<interactive> scanners generated by B<-I> (see below).  In general, you use "
"B<-B> when you are I<certain> that your scanner will never be used "
"interactively, and you want to squeeze a I<little> more performance out of "
"it.  If your goal is instead to squeeze out a I<lot> more performance, you "
"should be using the B<-Cf> or B<-CF> options (discussed below), which turn "
"on B<-B> automatically anyway."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2356
#, no-wrap
msgid "B<-F, --fast>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2368
msgid ""
"specifies that the I<fast> scanner table representation should be used (and "
"stdio bypassed).  This representation is about as fast as the full table "
"representation B<(-f),> and for some sets of patterns will be considerably "
"smaller (and for others, larger).  In general, if the pattern set contains "
"both \"keywords\" and a catch-all, \"identifier\" rule, such as in the set:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2375
#, no-wrap
msgid ""
"    \"case\"    return TOK_CASE;\n"
"    \"switch\"  return TOK_SWITCH;\n"
"    ...\n"
"    \"default\" return TOK_DEFAULT;\n"
"    [a-z]+    return TOK_ID;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2382
msgid ""
"then you're better off using the full table representation.  If only the "
"\"identifier\" rule is present and you then use a hash table or some such to "
"detect the keywords, you're better off using B<-F.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2388
msgid ""
"This option is equivalent to B<-CFr> (see below).  It cannot be used with "
"B<-+.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2388
#, no-wrap
msgid "B<-I, --interactive>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2406
msgid ""
"instructs I<flex> to generate an I<interactive> scanner.  An interactive "
"scanner is one that only looks ahead to decide what token has been matched "
"if it absolutely must.  It turns out that always looking one extra character "
"ahead, even if the scanner has already seen enough text to disambiguate the "
"current token, is a bit faster than only looking ahead when necessary.  But "
"scanners that always look ahead give dreadful interactive performance; for "
"example, when a user types a newline, it is not recognized as a newline "
"token until they enter I<another> token, which often means typing in another "
"whole line."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2431
msgid ""
"I<Flex> scanners default to I<interactive> unless you use the B<-Cf> or "
"B<-CF> table-compression options (see below).  That's because if you're "
"looking for high-performance you should be using one of these options, so if "
"you didn't, I<flex> assumes you'd rather trade off a bit of run-time "
"performance for intuitive interactive behavior.  Note also that you "
"I<cannot> use B<-I> in conjunction with B<-Cf> or B<-CF.> Thus, this option "
"is not really needed; it is on by default for all those cases in which it is "
"allowed."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2440
msgid ""
"Note that if B<isatty()> returns false for the scanner input, flex will "
"revert to batch mode, even if B<-I> was specified.  To force interactive "
"mode no matter what, use B<%option always-interactive> (see Options below)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2446
msgid "You can force a scanner to I<not> be interactive by using B<-B> (see above)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2446
#, no-wrap
msgid "B<-L, --noline>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2465
msgid ""
"instructs I<flex> not to generate B<#line> directives.  Without this option, "
"I<flex> peppers the generated scanner with #line directives so error "
"messages in the actions will be correctly located with respect to either the "
"original I<flex> input file (if the errors are due to code in the input "
"file), or B<lex.yy.c> (if the errors are I<flex's> fault -- you should "
"report these sorts of errors to the email address given below)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2465
#, no-wrap
msgid "B<-T, --trace>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2479
msgid ""
"makes I<flex> run in I<trace> mode.  It will generate a lot of messages to "
"I<stderr> concerning the form of the input and the resultant "
"non-deterministic and deterministic finite automata.  This option is mostly "
"for use in maintaining I<flex.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2479
#, no-wrap
msgid "B<-V, --version>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2487
msgid ""
"prints the version number to I<stdout> and exits.  B<--version> is a synonym "
"for B<-V.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2487
#, no-wrap
msgid "B<-7, --7bit>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2501
msgid ""
"instructs I<flex> to generate a 7-bit scanner, i.e., one which can only "
"recognize 7-bit characters in its input.  The advantage of using B<-7> is "
"that the scanner's tables can be up to half the size of those generated "
"using the B<-8> option (see below).  The disadvantage is that such scanners "
"often hang or crash if their input contains an 8-bit character."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2524
msgid ""
"Note, however, that unless you generate your scanner using the B<-Cf> or "
"B<-CF> table compression options, use of B<-7> will save only a small amount "
"of table space, and make your scanner considerably less portable.  I<Flex's> "
"default behavior is to generate an 8-bit scanner unless you use the B<-Cf> "
"or B<-CF,> in which case I<flex> defaults to generating 7-bit scanners "
"unless your site was always configured to generate 8-bit scanners (as will "
"often be the case with non-USA sites).  You can tell whether flex generated "
"a 7-bit or an 8-bit scanner by inspecting the flag summary in the B<-v> "
"output as described above."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2533
msgid ""
"Note that if you use B<-Cfe> or B<-CFe> (those table compression options, "
"but also using equivalence classes as discussed see below), flex still "
"defaults to generating an 8-bit scanner, since usually with these "
"compression options full 8-bit tables are not much more expensive than 7-bit "
"tables."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2533
#, no-wrap
msgid "B<-8, --8bit>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2544
msgid ""
"instructs I<flex> to generate an 8-bit scanner, i.e., one which can "
"recognize 8-bit characters.  This flag is only needed for scanners generated "
"using B<-Cf> or B<-CF,> as otherwise flex defaults to generating an 8-bit "
"scanner anyway."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2549
msgid ""
"See the discussion of B<-7> above for flex's default behavior and the "
"tradeoffs between 7-bit and 8-bit scanners."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2549
#, no-wrap
msgid "B<-+, --c++>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2555
msgid ""
"specifies that you want flex to generate a C++ scanner class.  See the "
"section on Generating C++ Scanners below for details."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2555
#, no-wrap
msgid "B<-C[aefFmr]>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2559
msgid ""
"controls the degree of table compression and, more generally, trade-offs "
"between small scanners and fast scanners."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2569
msgid ""
"B<-Ca, --align> (\"align\") instructs flex to trade off larger tables in the "
"generated scanner for faster performance because the elements of the tables "
"are better aligned for memory access and computation.  On some RISC "
"architectures, fetching and manipulating longwords is more efficient than "
"with smaller-sized units such as shortwords.  This option can double the "
"size of the tables used by your scanner."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2586
msgid ""
"B<-Ce, --ecs> directs I<flex> to construct I<equivalence classes,> i.e., "
"sets of characters which have identical lexical properties (for example, if "
"the only appearance of digits in the I<flex> input is in the character class "
"\"[0-9]\" then the digits '0', '1', ..., '9' will all be put in the same "
"equivalence class).  Equivalence classes usually give dramatic reductions in "
"the final table/object file sizes (typically a factor of 2-5) and are pretty "
"cheap performance-wise (one array look-up per character scanned)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2595
msgid ""
"B<-Cf> specifies that the I<full> scanner tables should be generated - "
"I<flex> should not compress the tables by taking advantages of similar "
"transition functions for different states."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2604
msgid ""
"B<-CF> specifies that the alternative fast scanner representation (described "
"above under the B<-F> flag)  should be used.  This option cannot be used "
"with B<-+.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2616
msgid ""
"B<-Cm, --meta-ecs> directs I<flex> to construct I<meta-equivalence classes,> "
"which are sets of equivalence classes (or characters, if equivalence classes "
"are not being used) that are commonly used together.  Meta-equivalence "
"classes are often a big win when using compressed tables, but they have a "
"moderate performance impact (one or two \"if\" tests and one array look-up "
"per character scanned)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2638
msgid ""
"B<-Cr, --read> causes the generated scanner to I<bypass> use of the standard "
"I/O library (stdio) for input.  Instead of calling B<fread()> or B<getc(),> "
"the scanner will use the B<read()> system call, resulting in a performance "
"gain which varies from system to system, but in general is probably "
"negligible unless you are also using B<-Cf> or B<-CF.> Using B<-Cr> can "
"cause strange behavior if, for example, you read from I<yyin> using stdio "
"prior to calling the scanner (because the scanner will miss whatever text "
"your previous reads left in the stdio input buffer)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2643
msgid ""
"B<-Cr> has no effect if you define B<YY_INPUT> (see The Generated Scanner "
"above)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2648
msgid ""
"A lone B<-C> specifies that the scanner tables should be compressed but "
"neither equivalence classes nor meta-equivalence classes should be used."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2659
msgid ""
"The options B<-Cf> or B<-CF> and B<-Cm> do not make sense together - there "
"is no opportunity for meta-equivalence classes if the table is not being "
"compressed.  Otherwise the options may be freely mixed, and are cumulative."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2670
msgid ""
"The default setting is B<-Cem,> which specifies that I<flex> should generate "
"equivalence classes and meta-equivalence classes.  This setting provides the "
"highest degree of table compression.  You can trade off faster-executing "
"scanners at the cost of larger tables with the following generally being "
"true:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2681
#, no-wrap
msgid ""
"    slowest & smallest\n"
"          -Cem\n"
"          -Cm\n"
"          -Ce\n"
"          -C\n"
"          -C{f,F}e\n"
"          -C{f,F}\n"
"          -C{f,F}a\n"
"    fastest & largest\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2687
msgid ""
"Note that scanners with the smallest tables are usually generated and "
"compiled the quickest, so during development you will usually want to use "
"the default, maximal compression."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2691
msgid ""
"B<-Cfe> is often a good compromise between speed and size for production "
"scanners."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2691
#, no-wrap
msgid "B<-ooutput, --outputfile=FILE>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2709
msgid ""
"directs flex to write the scanner to the file B<output> instead of "
"B<lex.yy.c.> If you combine B<-o> with the B<-t> option, then the scanner is "
"written to I<stdout> but its B<#line> directives (see the B<-L> option "
"above) refer to the file B<output.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2709
#, no-wrap
msgid "B<-Pprefix, --prefix=STRING>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2728
msgid ""
"changes the default I<yy> prefix used by I<flex> for all globally-visible "
"variable and function names to instead be I<prefix.> For example, B<-Pfoo> "
"changes the name of B<yytext> to B<footext.> It also changes the name of the "
"default output file from B<lex.yy.c> to B<lex.foo.c.> Here are all of the "
"names affected:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2745
#, no-wrap
msgid ""
"    yy_create_buffer\n"
"    yy_delete_buffer\n"
"    yy_flex_debug\n"
"    yy_init_buffer\n"
"    yy_flush_buffer\n"
"    yy_load_buffer_state\n"
"    yy_switch_to_buffer\n"
"    yyin\n"
"    yyleng\n"
"    yylex\n"
"    yylineno\n"
"    yyout\n"
"    yyrestart\n"
"    yytext\n"
"    yywrap\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2755
msgid ""
"(If you are using a C++ scanner, then only B<yywrap> and B<yyFlexLexer> are "
"affected.)  Within your scanner itself, you can still refer to the global "
"variables and functions using either version of their name; but externally, "
"they have the modified name."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2770
msgid ""
"This option lets you easily link together multiple I<flex> programs into the "
"same executable.  Note, though, that using this option also renames "
"B<yywrap(),> so you now I<must> either provide your own "
"(appropriately-named) version of the routine for your scanner, or use "
"B<%option noyywrap,> as linking with B<-ll> no longer provides one for you "
"by default."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2770
#, no-wrap
msgid "B<-Sskeleton_file, --skel=FILE>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2778
msgid ""
"overrides the default skeleton file from which I<flex> constructs its "
"scanners.  You'll never need this option unless you are doing I<flex> "
"maintenance or development."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2778
#, no-wrap
msgid "B<-X, --posix-compat>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2781
msgid "maximal compatibility with POSIX lex."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2781
#, no-wrap
msgid "B<--yylineno>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2784
msgid "track line count in yylineno."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2784
#, no-wrap
msgid "B<--yyclass=NAME>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2787
msgid "name of C++ class."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2787
#, no-wrap
msgid "B<--header-file=FILE>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2790
msgid "create a C header file in addition to the scanner."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2790
#, no-wrap
msgid "B<--tables-file[=FILE]>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2793
msgid "write tables to FILE."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2793
#, no-wrap
msgid "B<-Dmacro[=defn]>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2796
msgid "#define macro defn (default defn is '1')."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2796
#, no-wrap
msgid "B<-R, --reentrant>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2799
msgid "generate a reentrant C scanner"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2799
#, no-wrap
msgid "B<--bison-bridge>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2802
msgid "scanner for bison pure parser."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2802
#, no-wrap
msgid "B<--bison-locations>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2805
msgid "include yylloc support."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2805
#, no-wrap
msgid "B<--stdinit>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2808
msgid "initialize yyin/yyout to stdin/stdout."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2808
#, no-wrap
msgid "B<--noansi-definitions old-style function definitions.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2810
#, no-wrap
msgid "B<--noansi-prototypes>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2813
msgid "empty parameter list in prototypes."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2813
#, no-wrap
msgid "B<--nounistd>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2816
msgid "do not include E<lt>unistd.hE<gt>."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2816
#, no-wrap
msgid "B<--noFUNCTION>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2819
msgid "do not generate a particular FUNCTION."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2830
msgid ""
"I<flex> also provides a mechanism for controlling options within the scanner "
"specification itself, rather than from the flex command-line.  This is done "
"by including B<%option> directives in the first section of the scanner "
"specification.  You can specify multiple options with a single B<%option> "
"directive, and multiple directives in the first section of your flex input "
"file."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2834
msgid ""
"Most options are given simply as names, optionally preceded by the word "
"\"no\" (with no intervening whitespace) to negate their meaning.  A number "
"are equivalent to flex flags or their negation:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2842
#, no-wrap
msgid ""
"    7bit            -7 option\n"
"    8bit            -8 option\n"
"    align           -Ca option\n"
"    backup          -b option\n"
"    batch           -B option\n"
"    c++             -+ option\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2845
#, no-wrap
msgid ""
"    caseful or\n"
"    case-sensitive  opposite of -i (default)\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2848
#, no-wrap
msgid ""
"    case-insensitive or\n"
"    caseless        -i option\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2863
#, no-wrap
msgid ""
"    debug           -d option\n"
"    default         opposite of -s option\n"
"    ecs             -Ce option\n"
"    fast            -F option\n"
"    full            -f option\n"
"    interactive     -I option\n"
"    lex-compat      -l option\n"
"    meta-ecs        -Cm option\n"
"    perf-report     -p option\n"
"    read            -Cr option\n"
"    stdout          -t option\n"
"    verbose         -v option\n"
"    warn            opposite of -w option\n"
"                    (use \"%option nowarn\" for -w)\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2866
#, no-wrap
msgid ""
"    array           equivalent to \"%array\"\n"
"    pointer         equivalent to \"%pointer\" (default)\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2871
msgid "Some B<%option's> provide features otherwise not available:"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2871
#, no-wrap
msgid "B<always-interactive>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2882
msgid ""
"instructs flex to generate a scanner which always considers its input "
"\"interactive\".  Normally, on each new input file the scanner calls "
"B<isatty()> in an attempt to determine whether the scanner's input source is "
"interactive and thus should be read a character at a time.  When this option "
"is used, however, then no such call is made."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2882
#, no-wrap
msgid "B<main>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2891
msgid ""
"directs flex to provide a default B<main()> program for the scanner, which "
"simply calls B<yylex().> This option implies B<noyywrap> (see below)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2891
#, no-wrap
msgid "B<never-interactive>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2898
msgid ""
"instructs flex to generate a scanner which never considers its input "
"\"interactive\" (again, no call made to B<isatty()).> This is the opposite "
"of B<always-interactive.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2898
#, no-wrap
msgid "B<stack>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2901
msgid "enables the use of start condition stacks (see Start Conditions above)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2901
#, no-wrap
msgid "B<stdinit>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2923
msgid ""
"if set (i.e., B<%option stdinit)> initializes I<yyin> and I<yyout> to "
"I<stdin> and I<stdout,> instead of the default of I<nil.> Some existing "
"I<lex> programs depend on this behavior, even though it is not compliant "
"with ANSI C, which does not require I<stdin> and I<stdout> to be "
"compile-time constant."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2923
#, no-wrap
msgid "B<yylineno>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2932
msgid ""
"directs I<flex> to generate a scanner that maintains the number of the "
"current line read from its input in the global variable B<yylineno.> This "
"option is implied by B<%option lex-compat.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:2932
#, no-wrap
msgid "B<yywrap>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2944
msgid ""
"if unset (i.e., B<%option noyywrap),> makes the scanner not call B<yywrap()> "
"upon an end-of-file, but simply assume that there are no more files to scan "
"(until the user points I<yyin> at a new file and calls B<yylex()> again)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2962
msgid ""
"I<flex> scans your rule actions to determine whether you use the B<REJECT> "
"or B<yymore()> features.  The B<reject> and B<yymore> options are available "
"to override its decision as to whether you use the options, either by "
"setting them (e.g., B<%option reject)> to indicate the feature is indeed "
"used, or unsetting them to indicate it actually is not used (e.g., B<%option "
"noyymore).>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2964
msgid "Three options take string-delimited values, offset with '=':"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2967
#, no-wrap
msgid "    %option outfile=\"ABC\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2972
msgid "is equivalent to B<-oABC,> and"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2975
#, no-wrap
msgid "    %option prefix=\"XYZ\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2980
msgid "is equivalent to B<-PXYZ.> Finally,"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:2983
#, no-wrap
msgid "    %option yyclass=\"foo\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3006
msgid ""
"only applies when generating a C++ scanner ( B<-+> option).  It informs "
"I<flex> that you have derived B<foo> as a subclass of B<yyFlexLexer,> so "
"I<flex> will place your actions in the member function B<foo::yylex()> "
"instead of B<yyFlexLexer::yylex().> It also generates a "
"B<yyFlexLexer::yylex()> member function that emits a run-time error (by "
"invoking B<yyFlexLexer::LexerError())> if called.  See Generating C++ "
"Scanners, below, for additional information."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3014
msgid ""
"A number of options are available for lint purists who want to suppress the "
"appearance of unneeded routines in the generated scanner.  Each of the "
"following, if unset (e.g., B<%option nounput> ), results in the "
"corresponding routine not appearing in the generated scanner:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3019
#, no-wrap
msgid ""
"    input, unput\n"
"    yy_push_state, yy_pop_state, yy_top_state\n"
"    yy_scan_buffer, yy_scan_bytes, yy_scan_string\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3025
msgid ""
"(though B<yy_push_state()> and friends won't appear anyway unless you use "
"B<%option stack).>"
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:3025
#, no-wrap
msgid "PERFORMANCE CONSIDERATIONS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3036
msgid ""
"The main design goal of I<flex> is that it generate high-performance "
"scanners.  It has been optimized for dealing well with large sets of rules.  "
"Aside from the effects on scanner speed of the table compression B<-C> "
"options outlined above, there are a number of options/actions which degrade "
"performance.  These are, from most expensive to least:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3041
#, no-wrap
msgid ""
"    REJECT\n"
"    %option yylineno\n"
"    arbitrary trailing context\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3046
#, no-wrap
msgid ""
"    pattern sets that require backing up\n"
"    %array\n"
"    %option interactive\n"
"    %option always-interactive\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3049
#, no-wrap
msgid ""
"    '^' beginning-of-line operator\n"
"    yymore()\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3061
msgid ""
"with the first three all being quite expensive and the last two being quite "
"cheap.  Note also that B<unput()> is implemented as a routine call that "
"potentially does quite a bit of work, while B<yyless()> is a quite-cheap "
"macro; so if just putting back some excess text you scanned, use "
"B<yyless().>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3065
msgid ""
"B<REJECT> should be avoided at all costs when performance is important.  It "
"is a particularly expensive option."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3074
msgid ""
"Getting rid of backing up is messy and often may be an enormous amount of "
"work for a complicated scanner.  In principal, one begins by using the B<-b> "
"flag to generate a I<lex.backup> file.  For example, on the input"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3079
#, no-wrap
msgid ""
"    %%\n"
"    foo        return TOK_KEYWORD;\n"
"    foobar     return TOK_KEYWORD;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3082
msgid "the file looks like:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3089
#, no-wrap
msgid ""
"    State #6 is non-accepting -\n"
"     associated rule line numbers:\n"
"           2       3\n"
"     out-transitions: [ o ]\n"
"     jam-transitions: EOF [ \\e001-n  p-\\e177 ]\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3095
#, no-wrap
msgid ""
"    State #8 is non-accepting -\n"
"     associated rule line numbers:\n"
"           3\n"
"     out-transitions: [ a ]\n"
"     jam-transitions: EOF [ \\e001-`  b-\\e177 ]\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3101
#, no-wrap
msgid ""
"    State #9 is non-accepting -\n"
"     associated rule line numbers:\n"
"           3\n"
"     out-transitions: [ r ]\n"
"     jam-transitions: EOF [ \\e001-q  s-\\e177 ]\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3103
#, no-wrap
msgid "    Compressed tables always back up.\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3119
msgid ""
"The first few lines tell us that there's a scanner state in which it can "
"make a transition on an 'o' but not on any other character, and that in that "
"state the currently scanned text does not match any rule.  The state occurs "
"when trying to match the rules found at lines 2 and 3 in the input file.  If "
"the scanner is in that state and then reads something other than an 'o', it "
"will have to back up to find a rule which is matched.  With a bit of "
"headscratching one can see that this must be the state it's in when it has "
"seen \"fo\".  When this has happened, if anything other than another 'o' is "
"seen, the scanner will have to back up to simply match the 'f' (by the "
"default rule)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3126
msgid ""
"The comment regarding State #8 indicates there's a problem when \"foob\" has "
"been scanned.  Indeed, on any character other than an 'a', the scanner will "
"have to back up to accept \"foo\".  Similarly, the comment for State #9 "
"concerns when \"fooba\" has been scanned and an 'r' does not follow."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3134
msgid ""
"The final comment reminds us that there's no point going to all the trouble "
"of removing backing up from the rules unless we're using B<-Cf> or B<-CF,> "
"since there's no performance gain doing so with compressed scanners."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3136
msgid "The way to remove the backing up is to add \"error\" rules:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3141 /usr/src/usr.bin/lex/lex.1:3158
#, no-wrap
msgid ""
"    %%\n"
"    foo         return TOK_KEYWORD;\n"
"    foobar      return TOK_KEYWORD;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3148
#, no-wrap
msgid ""
"    fooba       |\n"
"    foob        |\n"
"    fo          {\n"
"                /* false alarm, not really a keyword */\n"
"                return TOK_ID;\n"
"                }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3153
msgid ""
"Eliminating backing up among a list of keywords can also be done using a "
"\"catch-all\" rule:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3160
#, no-wrap
msgid "    [a-z]+      return TOK_ID;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3163
msgid "This is usually the best solution when appropriate."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3174
msgid ""
"Backing up messages tend to cascade.  With a complicated set of rules it's "
"not uncommon to get hundreds of messages.  If one can decipher them, though, "
"it often only takes a dozen or so rules to eliminate the backing up (though "
"it's easy to make a mistake and have an error rule accidentally match a "
"valid token.  A possible future I<flex> feature will be to automatically add "
"rules to eliminate backing up)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3180
msgid ""
"It's important to keep in mind that you gain the benefits of eliminating "
"backing up only if you eliminate I<every> instance of backing up.  Leaving "
"just one means you gain nothing."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3187
msgid ""
"I<Variable> trailing context (where both the leading and trailing parts do "
"not have a fixed length) entails almost the same performance loss as "
"B<REJECT> (i.e., substantial).  So when possible a rule like:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3191
#, no-wrap
msgid ""
"    %%\n"
"    mouse|rat/(cat|dog)   run();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3194
msgid "is better written:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3199
#, no-wrap
msgid ""
"    %%\n"
"    mouse/cat|dog         run();\n"
"    rat/cat|dog           run();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3202
msgid "or as"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3207
#, no-wrap
msgid ""
"    %%\n"
"    mouse|rat/cat         run();\n"
"    mouse|rat/dog         run();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3213
msgid ""
"Note that here the special '|' action does I<not> provide any savings, and "
"can even make things worse (see Deficiencies / Bugs below)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3224
msgid ""
"Another area where the user can increase a scanner's performance (and one "
"that's easier to implement) arises from the fact that the longer the tokens "
"matched, the faster the scanner will run.  This is because with long tokens "
"the processing of most input characters takes place in the (short) inner "
"scanning loop, and does not often have to go through the additional work of "
"setting up the scanning environment (e.g., B<yytext)> for the action.  "
"Recall the scanner for C comments:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3236
#, no-wrap
msgid ""
"    E<lt>commentE<gt>[^*\\en]*\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*\n"
"    E<lt>commentE<gt>\\en             ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3239
msgid "This could be sped up by writing it as:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3252
#, no-wrap
msgid ""
"    E<lt>commentE<gt>[^*\\en]*\n"
"    E<lt>commentE<gt>[^*\\en]*\\en      ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*\\en ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3265
msgid ""
"Now instead of each newline requiring the processing of another action, "
"recognizing the newlines is \"distributed\" over the other rules to keep the "
"matched text as long as possible.  Note that I<adding> rules does I<not> "
"slow down the scanner! The speed of the scanner is independent of the number "
"of rules or (modulo the considerations given at the beginning of this "
"section) how complicated the rules are with regard to operators such as '*' "
"and '|'."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3271
msgid ""
"A final example in speeding up a scanner: suppose you want to scan through a "
"file containing identifiers and keywords, one per line and with no other "
"extraneous characters, and recognize all the keywords.  A natural first "
"approach is:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3280 /usr/src/usr.bin/lex/lex.1:3294
#, no-wrap
msgid ""
"    %%\n"
"    asm      |\n"
"    auto     |\n"
"    break    |\n"
"    ... etc ...\n"
"    volatile |\n"
"    while    /* it's a keyword */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3282
#, no-wrap
msgid "    .|\\en     /* it's not a keyword */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3285
msgid "To eliminate the back-tracking, introduce a catch-all rule:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3297
#, no-wrap
msgid ""
"    [a-z]+   |\n"
"    .|\\en     /* it's not a keyword */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3303
msgid ""
"Now, if it's guaranteed that there's exactly one word per line, then we can "
"reduce the total number of matches by a half by merging in the recognition "
"of newlines with that of the other tokens:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3312 /usr/src/usr.bin/lex/lex.1:3344
#, no-wrap
msgid ""
"    %%\n"
"    asm\\en    |\n"
"    auto\\en   |\n"
"    break\\en  |\n"
"    ... etc ...\n"
"    volatile\\en |\n"
"    while\\en  /* it's a keyword */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3315
#, no-wrap
msgid ""
"    [a-z]+\\en |\n"
"    .|\\en     /* it's not a keyword */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3335
msgid ""
"One has to be careful here, as we have now reintroduced backing up into the "
"scanner.  In particular, while I<we> know that there will never be any "
"characters in the input stream other than letters or newlines, I<flex> can't "
"figure this out, and it will plan for possibly needing to back up when it "
"has scanned a token like \"auto\" and then the next character is something "
"other than a newline or a letter.  Previously it would then just match the "
"\"auto\" rule and be done, but now it has no \"auto\" rule, only an "
"\"auto\\en\" rule.  To eliminate the possibility of backing up, we could "
"either duplicate all rules but without final newlines, or, since we never "
"expect to encounter such an input and therefore don't how it's classified, "
"we can introduce one more catch-all rule, this one which doesn't include a "
"newline:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3348
#, no-wrap
msgid ""
"    [a-z]+\\en |\n"
"    [a-z]+   |\n"
"    .|\\en     /* it's not a keyword */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3355
msgid ""
"Compiled with B<-Cf,> this is about as fast as one can get a I<flex> scanner "
"to go for this particular problem."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3363
msgid ""
"A final note: I<flex> is slow when matching NUL's, particularly when a token "
"contains multiple NUL's.  It's best to write rules which match I<short> "
"amounts of text if it's anticipated that the text will often include NUL's."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3373
msgid ""
"Another final note regarding performance: as mentioned above in the section "
"How the Input is Matched, dynamically resizing B<yytext> to accommodate huge "
"tokens is a slow process because it presently requires that the (huge) token "
"be rescanned from the beginning.  Thus if performance is vital, you should "
"attempt to match \"large\" quantities of text but not \"huge\" quantities, "
"where the cutoff between the two is at about 8K characters/token."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:3373
#, no-wrap
msgid "GENERATING C++ SCANNERS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3391
msgid ""
"I<flex> provides two different ways to generate scanners for use with C++.  "
"The first way is to simply compile a scanner generated by I<flex> using a "
"C++ compiler instead of a C compiler.  You should not encounter any "
"compilations errors (please report any you find to the email address given "
"in the Author section below).  You can then use C++ code in your rule "
"actions instead of C code.  Note that the default input source for your "
"scanner remains I<yyin,> and default echoing is still done to I<yyout.> Both "
"of these remain I<FILE *> variables and not C++ I<streams.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3408
msgid ""
"You can also use I<flex> to generate a C++ scanner class, using the B<-+> "
"option (or, equivalently, B<%option c++),> which is automatically specified "
"if the name of the flex executable ends in a '+', such as I<flex++.> When "
"using this option, flex defaults to generating the scanner to the file "
"B<lex.yy.cc> instead of B<lex.yy.c.> The generated scanner includes the "
"header file I<FlexLexer.h,> which defines the interface to two C++ classes."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3414
msgid ""
"The first class, B<FlexLexer,> provides an abstract base class defining the "
"general scanner class interface.  It provides the following member "
"functions:"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3414
#, no-wrap
msgid "B<const char* YYText()>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3418
msgid ""
"returns the text of the most recently matched token, the equivalent of "
"B<yytext.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3418
#, no-wrap
msgid "B<int YYLeng()>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3422
msgid ""
"returns the length of the most recently matched token, the equivalent of "
"B<yyleng.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3422
#, no-wrap
msgid "B<int lineno() const>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3432
msgid ""
"returns the current input line number (see B<%option yylineno),> or B<1> if "
"B<%option yylineno> was not used."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3432
#, no-wrap
msgid "B<void set_debug( int flag )>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3440
msgid ""
"sets the debugging flag for the scanner, equivalent to assigning to "
"B<yy_flex_debug> (see the Options section above).  Note that you must build "
"the scanner using B<%option debug> to include debugging information in it."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3440
#, no-wrap
msgid "B<int debug() const>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3443
msgid "returns the current setting of the debugging flag."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3458
msgid ""
"Also provided are member functions equivalent to B<yy_switch_to_buffer(),> "
"B<yy_create_buffer()> (though the first argument is an B<std::istream*> "
"object pointer and not a B<FILE*),> B<yy_flush_buffer(),> "
"B<yy_delete_buffer(),> and B<yyrestart()> (again, the first argument is a "
"B<std::istream*> object pointer)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3466
msgid ""
"The second class defined in I<FlexLexer.h> is B<yyFlexLexer,> which is "
"derived from B<FlexLexer.> It defines the following additional member "
"functions:"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3466
#, no-wrap
msgid "B<yyFlexLexer( std::istream* arg_yyin = 0, std::ostream* arg_yyout = 0 )>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3477
msgid ""
"constructs a B<yyFlexLexer> object using the given streams for input and "
"output.  If not specified, the streams default to B<cin> and B<cout,> "
"respectively."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3477
#, no-wrap
msgid "B<virtual int yylex()>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3507
msgid ""
"performs the same role is B<yylex()> does for ordinary flex scanners: it "
"scans the input stream, consuming tokens, until a rule's action returns a "
"value.  If you derive a subclass B<S> from B<yyFlexLexer> and want to access "
"the member functions and variables of B<S> inside B<yylex(),> then you need "
"to use B<%option yyclass=\"S\"> to inform I<flex> that you will be using "
"that subclass instead of B<yyFlexLexer.> In this case, rather than "
"generating B<yyFlexLexer::yylex(),> I<flex> generates B<S::yylex()> (and "
"also generates a dummy B<yyFlexLexer::yylex()> that calls "
"B<yyFlexLexer::LexerError()> if called)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3507
#, no-wrap
msgid "B<virtual void switch_streams(std::istream* new_in = 0,>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3524
msgid ""
"B<std::ostream* new_out = 0)> reassigns B<yyin> to B<new_in> (if non-nil)  "
"and B<yyout> to B<new_out> (ditto), deleting the previous input buffer if "
"B<yyin> is reassigned."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3524
#, no-wrap
msgid "B<int yylex( std::istream* new_in, std::ostream* new_out = 0 )>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3531
msgid ""
"first switches the input streams via B<switch_streams( new_in, new_out )> "
"and then returns the value of B<yylex().>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3536
msgid ""
"In addition, B<yyFlexLexer> defines the following protected virtual "
"functions which you can redefine in derived classes to tailor the scanner:"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3536
#, no-wrap
msgid "B<virtual int LexerInput( char* buf, int max_size )>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3557
msgid ""
"reads up to B<max_size> characters into B<buf> and returns the number of "
"characters read.  To indicate end-of-input, return 0 characters.  Note that "
"\"interactive\" scanners (see the B<-B> and B<-I> flags) define the macro "
"B<YY_INTERACTIVE.> If you redefine B<LexerInput()> and need to take "
"different actions depending on whether or not the scanner might be scanning "
"an interactive input source, you can test for the presence of this name via "
"B<#ifdef.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3557
#, no-wrap
msgid "B<virtual void LexerOutput( const char* buf, int size )>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3566
msgid ""
"writes out B<size> characters from the buffer B<buf,> which, while "
"NUL-terminated, may also contain \"internal\" NUL's if the scanner's rules "
"can match text with NUL's in them."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:3566
#, no-wrap
msgid "B<virtual void LexerError( const char* msg )>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3573
msgid ""
"reports a fatal error message.  The default version of this function writes "
"the message to the stream B<cerr> and exits."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3586
msgid ""
"Note that a B<yyFlexLexer> object contains its I<entire> scanning state.  "
"Thus you can use such objects to create reentrant scanners.  You can "
"instantiate multiple instances of the same B<yyFlexLexer> class, and you can "
"also combine multiple C++ scanner classes together in the same program using "
"the B<-P> option discussed above."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3592
msgid ""
"Finally, note that the B<%array> feature is not available to C++ scanner "
"classes; you must use B<%pointer> (the default)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3594
msgid "Here is an example of a simple C++ scanner:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3597
#, no-wrap
msgid "        // An example of using the flex C++ scanner class.\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3601
#, no-wrap
msgid ""
"    %{\n"
"    int mylineno = 0;\n"
"    %}\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3603
#, no-wrap
msgid "    string  \\e\"[^\\en\"]+\\e\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3605
#, no-wrap
msgid "    ws      [ \\et]+\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3612
#, no-wrap
msgid ""
"    alpha   [A-Za-z]\n"
"    dig     [0-9]\n"
"    name    ({alpha}|{dig}|\\e$)({alpha}|{dig}|[_.\\e-/$])*\n"
"    num1    [-+]?{dig}+\\e.?([eE][-+]?{dig}+)?\n"
"    num2    [-+]?{dig}*\\e.{dig}+([eE][-+]?{dig}+)?\n"
"    number  {num1}|{num2}\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3616
#, no-wrap
msgid "    {ws}    /* skip blanks and tabs */\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3619
#, no-wrap
msgid ""
"    \"/*\"    {\n"
"            int c;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3624
#, no-wrap
msgid ""
"            while((c = yyinput()) != 0)\n"
"                {\n"
"                if(c == '\\en')\n"
"                    ++mylineno;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3634
#, no-wrap
msgid ""
"                else if(c == '*')\n"
"                    {\n"
"                    if((c = yyinput()) == '/')\n"
"                        break;\n"
"                    else\n"
"                        unput(c);\n"
"                    }\n"
"                }\n"
"            }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3636
#, no-wrap
msgid ""
"    {number}  cout E<lt>E<lt> \"number \" E<lt>E<lt> YYText() E<lt>E<lt> "
"'\\en';\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3638
#, no-wrap
msgid "    \\en        mylineno++;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3640
#, no-wrap
msgid ""
"    {name}    cout E<lt>E<lt> \"name \" E<lt>E<lt> YYText() E<lt>E<lt> "
"'\\en';\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3642
#, no-wrap
msgid ""
"    {string}  cout E<lt>E<lt> \"string \" E<lt>E<lt> YYText() E<lt>E<lt> "
"'\\en';\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3652
#, no-wrap
msgid ""
"    int main( int /* argc */, char** /* argv */ )\n"
"        {\n"
"        FlexLexer* lexer = new yyFlexLexer;\n"
"        while(lexer-E<gt>yylex() != 0)\n"
"            ;\n"
"        return 0;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3666
msgid ""
"If you want to create multiple (different) lexer classes, you use the B<-P> "
"flag (or the B<prefix=> option) to rename each B<yyFlexLexer> to some other "
"B<xxFlexLexer.> You then can include B<E<lt>FlexLexer.hE<gt>> in your other "
"sources once per lexer class, first renaming B<yyFlexLexer> as follows:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3671
#, no-wrap
msgid ""
"    #undef yyFlexLexer\n"
"    #define yyFlexLexer xxFlexLexer\n"
"    #include E<lt>FlexLexer.hE<gt>\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3675
#, no-wrap
msgid ""
"    #undef yyFlexLexer\n"
"    #define yyFlexLexer zzFlexLexer\n"
"    #include E<lt>FlexLexer.hE<gt>\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3682
msgid ""
"if, for example, you used B<%option prefix=\"xx\"> for one of your scanners "
"and B<%option prefix=\"zz\"> for the other."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3686
msgid ""
"IMPORTANT: the present form of the scanning class is I<experimental> and may "
"change considerably between major releases."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:3686
#, no-wrap
msgid "INCOMPATIBILITIES WITH LEX AND POSIX"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3703
msgid ""
"I<flex> is a rewrite of the AT&T Unix I<lex> tool (the two implementations "
"do not share any code, though), with some extensions and incompatibilities, "
"both of which are of concern to those who wish to write scanners acceptable "
"to either implementation.  Flex is fully compliant with the POSIX I<lex> "
"specification, except that when using B<%pointer> (the default), a call to "
"B<unput()> destroys the contents of B<yytext,> which is counter to the POSIX "
"specification."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3706
msgid ""
"In this section we discuss all of the known areas of incompatibility between "
"flex, AT&T lex, and the POSIX specification."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3717
msgid ""
"I<flex's> B<-l> option turns on maximum compatibility with the original AT&T "
"I<lex> implementation, at the cost of a major loss in the generated "
"scanner's performance.  We note below which incompatibilities can be "
"overcome using the B<-l> option."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3722
msgid "I<flex> is fully compatible with I<lex> with the following exceptions:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3732
msgid ""
"The undocumented I<lex> scanner internal variable B<yylineno> is not "
"supported unless B<-l> or B<%option yylineno> is used."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3736
msgid ""
"B<yylineno> should be maintained on a per-buffer basis, rather than a "
"per-scanner (single global variable) basis."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3739
msgid "B<yylineno> is not part of the POSIX specification."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3753
msgid ""
"The B<input()> routine is not redefinable, though it may be called to read "
"characters following whatever has been matched by a rule.  If B<input()> "
"encounters an end-of-file the normal B<yywrap()> processing is done.  A "
"``real'' end-of-file is returned by B<input()> as I<EOF.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3757
msgid "Input is instead controlled by defining the B<YY_INPUT> macro."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3766
msgid ""
"The I<flex> restriction that B<input()> cannot be redefined is in accordance "
"with the POSIX specification, which simply does not specify any way of "
"controlling the scanner's input other than by making an initial assignment "
"to I<yyin.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3771
msgid ""
"The B<unput()> routine is not redefinable.  This restriction is in "
"accordance with POSIX."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3780
msgid ""
"I<flex> scanners are not as reentrant as I<lex> scanners.  In particular, if "
"you have an interactive scanner and an interrupt handler which long-jumps "
"out of the scanner, and the scanner is subsequently called again, you may "
"get the following message:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3783
#, no-wrap
msgid "    fatal flex scanner internal error--end of buffer missed\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3786
msgid "To reenter the scanner, first use"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3789 /usr/src/usr.bin/lex/lex.1:4101
#, no-wrap
msgid "    yyrestart( yyin );\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3793
msgid ""
"Note that this call will throw away any buffered input; usually this isn't a "
"problem with an interactive scanner."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3799
msgid ""
"Also note that flex C++ scanner classes I<are> reentrant, so if using C++ is "
"an option for you, you should use them instead.  See \"Generating C++ "
"Scanners\" above for details."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3808
msgid ""
"B<output()> is not supported.  Output from the B<ECHO> macro is done to the "
"file-pointer I<yyout> (default I<stdout).>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3811
msgid "B<output()> is not part of the POSIX specification."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3815
msgid ""
"I<lex> does not support exclusive start conditions (%x), though they are in "
"the POSIX specification."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3820
msgid ""
"When definitions are expanded, I<flex> encloses them in parentheses.  With "
"lex, the following:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3826
#, no-wrap
msgid ""
"    NAME    [A-Z][A-Z0-9]*\n"
"    %%\n"
"    foo{NAME}?      printf( \"Found it\\en\" );\n"
"    %%\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3836
msgid ""
"will not match the string \"foo\" because when the macro is expanded the "
"rule is equivalent to \"foo[A-Z][A-Z0-9]*?\" and the precedence is such that "
"the '?' is associated with \"[A-Z0-9]*\".  With I<flex,> the rule will be "
"expanded to \"foo([A-Z][A-Z0-9]*)?\" and so the string \"foo\" will match."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3852
msgid ""
"Note that if the definition begins with B<^> or ends with B<$> then it is "
"I<not> expanded with parentheses, to allow these operators to appear in "
"definitions without losing their special meanings.  But the B<E<lt>sE<gt>, "
"/,> and B<E<lt>E<lt>EOFE<gt>E<gt>> operators cannot be used in a I<flex> "
"definition."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3858
msgid ""
"Using B<-l> results in the I<lex> behavior of no parentheses around the "
"definition."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3860
msgid "The POSIX specification is that the definition be enclosed in parentheses."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3865
msgid ""
"Some implementations of I<lex> allow a rule's action to begin on a separate "
"line, if the rule's pattern has trailing whitespace:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3870
#, no-wrap
msgid ""
"    %%\n"
"    foo|barE<lt>space hereE<gt>\n"
"      { foobar_action(); }\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3874
msgid "I<flex> does not support this feature."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3881
msgid ""
"The I<lex> B<%r> (generate a Ratfor scanner) option is not supported.  It is "
"not part of the POSIX specification."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3894
msgid ""
"After a call to B<unput(),> I<yytext> is undefined until the next token is "
"matched, unless the scanner was built using B<%array.> This is not the case "
"with I<lex> or the POSIX specification.  The B<-l> option does away with "
"this incompatibility."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3905
msgid ""
"The precedence of the B<{}> (numeric range) operator is different.  I<lex> "
"interprets \"abc{1,3}\" as \"match one, two, or three occurrences of "
"'abc'\", whereas I<flex> interprets it as \"match 'ab' followed by one, two, "
"or three occurrences of 'c'\".  The latter is in agreement with the POSIX "
"specification."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3916
msgid ""
"The precedence of the B<^> operator is different.  I<lex> interprets "
"\"^foo|bar\" as \"match either 'foo' at the beginning of a line, or 'bar' "
"anywhere\", whereas I<flex> interprets it as \"match either 'foo' or 'bar' "
"if they come at the beginning of a line\".  The latter is in agreement with "
"the POSIX specification."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3926
msgid ""
"The special table-size declarations such as B<%a> supported by I<lex> are "
"not required by I<flex> scanners; I<flex> ignores them."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3942
msgid ""
"The name B<FLEX_SCANNER> is #define'd so scanners may be written for use "
"with either I<flex> or I<lex.> Scanners also include "
"B<YY_FLEX_MAJOR_VERSION> and B<YY_FLEX_MINOR_VERSION> indicating which "
"version of I<flex> generated the scanner (for example, for the 2.5 release, "
"these defines would be 2 and 5 respectively)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3948
msgid ""
"The following I<flex> features are not included in I<lex> or the POSIX "
"specification:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3969
#, no-wrap
msgid ""
"    C++ scanners\n"
"    %option\n"
"    start condition scopes\n"
"    start condition stacks\n"
"    interactive/non-interactive scanners\n"
"    yy_scan_string() and friends\n"
"    yyterminate()\n"
"    yy_set_interactive()\n"
"    yy_set_bol()\n"
"    YY_AT_BOL()\n"
"    E<lt>E<lt>EOFE<gt>E<gt>\n"
"    E<lt>*E<gt>\n"
"    YY_DECL\n"
"    YY_START\n"
"    YY_USER_ACTION\n"
"    YY_USER_INIT\n"
"    #line directives\n"
"    %{}'s around actions\n"
"    multiple actions on a line\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3978
msgid ""
"plus almost all of the flex flags.  The last feature in the list refers to "
"the fact that with I<flex> you can put multiple actions on the same line, "
"separated with semi-colons, while with I<lex,> the following"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3981
#, no-wrap
msgid "    foo    handle_foo(); ++num_foos_seen;\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3984
msgid "is (rather surprisingly) truncated to"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3987
#, no-wrap
msgid "    foo    handle_foo();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:3993
msgid ""
"I<flex> does not truncate the action.  Actions that are not enclosed in "
"braces are simply terminated at the end of the line."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:3993
#, no-wrap
msgid "DIAGNOSTICS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4000
msgid ""
"I<warning, rule cannot be matched> indicates that the given rule cannot be "
"matched because it follows other rules that will always match the same text "
"as it.  For example, in the following \"foo\" cannot be matched because it "
"comes after an identifier \"catch-all\" rule:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4004
#, no-wrap
msgid ""
"    [a-z]+    got_identifier();\n"
"    foo       got_foo();\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4009
msgid "Using B<REJECT> in a scanner suppresses this warning."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4020
msgid ""
"I<warning,> B<-s> I<option given but default rule can be matched> means that "
"it is possible (perhaps only in a particular start condition)  that the "
"default rule (match any single character) is the only one that will match a "
"particular input.  Since B<-s> was given, presumably this is not intended."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4041
msgid ""
"I<reject_used_but_not_detected undefined> or I<yymore_used_but_not_detected "
"undefined -> These errors can occur at compile time.  They indicate that the "
"scanner uses B<REJECT> or B<yymore()> but that I<flex> failed to notice the "
"fact, meaning that I<flex> scanned the first two sections looking for "
"occurrences of these actions and failed to find any, but somehow you snuck "
"some in (via a #include file, for example).  Use B<%option reject> or "
"B<%option yymore> to indicate to flex that you really do use these features."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4048
msgid ""
"I<flex scanner jammed -> a scanner compiled with B<-s> has encountered an "
"input string which wasn't matched by any of its rules.  This error can also "
"occur due to internal problems."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4061
msgid ""
"I<token too large, exceeds YYLMAX -> your scanner uses B<%array> and one of "
"its rules matched a string longer than the B<YYLMAX> constant (8K bytes by "
"default).  You can increase the value by #define'ing B<YYLMAX> in the "
"definitions section of your I<flex> input."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4075
msgid ""
"I<scanner requires -8 flag to> I<use the character 'x' -> Your scanner "
"specification includes recognizing the 8-bit character I<'x'> and you did "
"not specify the -8 flag, and your scanner defaulted to 7-bit because you "
"used the B<-Cf> or B<-CF> table compression options.  See the discussion of "
"the B<-7> flag for details."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4084
msgid ""
"I<flex scanner push-back overflow -> you used B<unput()> to push back so "
"much text that the scanner's buffer could not hold both the pushed-back text "
"and the current token in B<yytext.> Ideally the scanner should dynamically "
"resize the buffer in this case, but at present it does not."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4092
msgid ""
"I<input buffer overflow, can't enlarge buffer because scanner uses REJECT -> "
"the scanner was working on matching an extremely large token and needed to "
"expand the input buffer.  This doesn't work with scanners that use "
"B<REJECT.>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4098
msgid ""
"I<fatal flex scanner internal error--end of buffer missed -> This can occur "
"in a scanner which is reentered after a long-jump has jumped out (or over) "
"the scanner's activation frame.  Before reentering the scanner, use:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4104
msgid "or, as noted above, switch to using the C++ scanner class."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4108
msgid ""
"I<too many start conditions in E<lt>E<gt> construct! -> you listed more "
"start conditions in a E<lt>E<gt> construct than exist (so you must have "
"listed at least one of them twice)."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:4108
#, no-wrap
msgid "FILES"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:4109
#, no-wrap
msgid "B<-ll>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4112
msgid "library with which scanners must be linked."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:4112
#, no-wrap
msgid "I<lex.yy.c>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4117
msgid "generated scanner (called I<lexyy.c> on some systems)."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:4117
#, no-wrap
msgid "I<lex.yy.cc>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4121
msgid "generated C++ scanner class, when using B<-+.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:4121
#, no-wrap
msgid "I<E<lt>FlexLexer.hE<gt>>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4127
msgid ""
"header file defining the C++ scanner base class, B<FlexLexer,> and its "
"derived class, B<yyFlexLexer.>"
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:4127
#, no-wrap
msgid "I<flex.skl>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4131
msgid ""
"skeleton scanner.  This file is only used when building flex, not when flex "
"executes."
msgstr ""

#. type: TP
#: /usr/src/usr.bin/lex/lex.1:4131
#, no-wrap
msgid "I<lex.backup>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4138
msgid "backing-up information for B<-b> flag (called I<lex.bck> on some systems)."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:4138
#, no-wrap
msgid "DEFICIENCIES / BUGS"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4148
msgid ""
"Some trailing context patterns cannot be properly matched and generate "
"warning messages (\"dangerous trailing context\").  These are patterns where "
"the ending of the first part of the rule matches the beginning of the second "
"part, such as \"zx*/xy*\", where the 'x*' matches the 'x' at the beginning "
"of the trailing context.  (Note that the POSIX draft states that the text "
"matched by such patterns is undefined.)"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4153
msgid ""
"For some trailing context rules, parts which are actually fixed-length are "
"not recognized as such, leading to the above mentioned performance loss.  In "
"particular, parts using '|' or {n} (such as \"foo{3}\") are always "
"considered variable-length."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4160
msgid ""
"Combining trailing context with the special '|' action can result in "
"I<fixed> trailing context being turned into the more expensive I<variable> "
"trailing context.  For example, in the following:"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4165
#, no-wrap
msgid ""
"    %%\n"
"    abc      |\n"
"    xyz/def\n"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4176
msgid ""
"Use of B<unput()> invalidates yytext and yyleng, unless the B<%array> "
"directive or the B<-l> option has been used."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4179
msgid ""
"Pattern-matching of NUL's is substantially slower than matching other "
"characters."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4182
msgid ""
"Dynamic resizing of the input buffer is slow, as it entails rescanning all "
"the text matched so far by the current (generally huge) token."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4192
msgid ""
"Due to both buffering of input and read-ahead, you cannot intermix calls to "
"E<lt>stdio.hE<gt> routines, such as, for example, B<getchar(),> with I<flex> "
"rules and expect it to work.  Call B<input()> instead."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4201
msgid ""
"The total table entries listed by the B<-v> flag excludes the number of "
"table entries needed to determine what rule has been matched.  The number of "
"entries is equal to the number of DFA states if the scanner does not use "
"B<REJECT,> and somewhat greater than the number of states if it does."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4208
msgid "B<REJECT> cannot be used with the B<-f> or B<-F> options."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4212
msgid "The I<flex> internal algorithms need documentation."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:4212
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4214
msgid "lex(1), yacc(1), sed(1), awk(1)."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4219
msgid ""
"John Levine, Tony Mason, and Doug Brown, I<Lex & Yacc,> O'Reilly and "
"Associates.  Be sure to get the 2nd edition."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4222
msgid "M. E. Lesk and E. Schmidt, I<LEX - Lexical Analyzer Generator>"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4229
msgid ""
"Alfred Aho, Ravi Sethi and Jeffrey Ullman, I<Compilers: Principles, "
"Techniques and Tools,> Addison-Wesley (1986).  Describes the "
"pattern-matching techniques used by I<flex> (deterministic finite automata)."
msgstr ""

#. type: SH
#: /usr/src/usr.bin/lex/lex.1:4229
#, no-wrap
msgid "AUTHOR"
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4237
msgid ""
"Vern Paxson, with the help of many ideas and much inspiration from Van "
"Jacobson.  Original version by Jef Poskanzer.  The fast table representation "
"is a partial implementation of a design done by Van Jacobson.  The "
"implementation was done by Kevin Gong and Vern Paxson."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4282
msgid ""
"Thanks to the many I<flex> beta-testers, feedbackers, and contributors, "
"especially Francois Pinard, Casey Leedom, Robert Abramovitz, Stan Adermann, "
"Terry Allen, David Barker-Plummer, John Basrai, Neal Becker, Nelson "
"H.F. Beebe, benson@odi.com, Karl Berry, Peter A. Bigot, Simon Blanchard, "
"Keith Bostic, Frederic Brehm, Ian Brockbank, Kin Cho, Nick Christopher, "
"Brian Clapper, J.T. Conklin, Jason Coughlin, Bill Cox, Nick Cropper, Dave "
"Curtis, Scott David Daniels, Chris G. Demetriou, Theo de Raadt, Mike "
"Donahue, Chuck Doucette, Tom Epperly, Leo Eskin, Chris Faylor, Chris "
"Flatters, Jon Forrest, Jeffrey Friedl, Joe Gayda, Kaveh R. Ghazi, Wolfgang "
"Glunz, Eric Goldman, Christopher M. Gould, Ulrich Grepel, Peer Griebel, Jan "
"Hajic, Charles Hemphill, NORO Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff "
"Honig, Dana Hudes, Eric Hughes, John Interrante, Ceriel Jacobs, Michal "
"Jaegermann, Sakari Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, "
"Jonathan I. Kamens, Terrence O Kane, Amir Katz, ken@ken.hilco.com, Kevin "
"B. Kenny, Steve Kirsch, Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg "
"Lee, Rohan Lenard, Craig Leres, John Levine, Steve Liddle, David Loffredo, "
"Mike Long, Mohamed el Lozy, Brian Madsen, Malte, Joe Marshall, Bengt "
"Martensson, Chris Metcalf, Luke Mewburn, Jim Meyering, R. Alexander "
"Milowski, Erik Naggum, G.T. Nicol, Landon Noll, James Nordby, Marc Nozell, "
"Richard Ohnemus, Karsten Pahnke, Sven Panne, Roland Pesch, Walter Pelissero, "
"Gaumond Pierre, Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha, "
"Frederic Raimbault, Pat Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe "
"Rommel, Jim Roskind, Alberto Santini, Andreas Scherer, Darrell Schiebel, Raf "
"Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas Schwab, Larry "
"Schwimmer, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, "
"Paul Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt, Richard "
"M. Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, Gerhard "
"Wilhelms, Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn, and "
"those whose names have slipped my marginal mail-archiving skills but whose "
"contributions are appreciated all the same."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4287
msgid ""
"Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore, Craig "
"Leres, John Levine, Bob Mulcahy, G.T.  Nicol, Francois Pinard, Rich Salz, "
"and Richard Stallman for help with various distribution headaches."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4292
msgid ""
"Thanks to Esmond Pitt and Earle Horton for 8-bit character support; to "
"Benson Margulies and Fred Burke for C++ support; to Kent Williams and Tom "
"Epperly for C++ class support; to Ove Ewerlid for support of NUL's; and to "
"Eric Hughes for support of multiple buffers."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4296
msgid ""
"This work was primarily done when I was with the Real Time Systems Group at "
"the Lawrence Berkeley Laboratory in Berkeley, CA.  Many thanks to all there "
"for the support I received."
msgstr ""

#. type: Plain text
#: /usr/src/usr.bin/lex/lex.1:4297
msgid "Send comments to vern@ee.lbl.gov."
msgstr ""
