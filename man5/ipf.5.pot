# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-05-18 14:32-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: /usr/src/contrib/ipfilter/man/ipf.5:2
#, no-wrap
msgid "IPF"
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:3
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:5
msgid "ipf, ipf.conf - IPFilter firewall rules file format"
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:5
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:10
msgid ""
"The ipf.conf file is used to specify rules for the firewall, packet "
"authentication and packet accounting components of IPFilter. To load rules "
"specified in the ipf.conf file, the ipf(8) program is used."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:15
msgid ""
"For use as a firewall, there are two important rule types: those that block "
"and drop packets (block rules) and those that allow packets through (pass "
"rules.) Accompanying the decision to apply is a collection of statements "
"that specify under what conditions the result is to be applied and how."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:17
msgid "The simplest rules that can be used in ipf.conf are expressed like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:21
#, no-wrap
msgid ""
"block in all\n"
"pass out all\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:24
msgid "Each rule must contain at least the following three components"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:25 /usr/src/contrib/ipfilter/man/ipf.5:27 /usr/src/contrib/ipfilter/man/ipf.5:29
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:27
msgid "a decision keyword (pass, block, etc.)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:29
msgid "the direction of the packet (in or out)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:31
msgid "address patterns or \"all\" to match any address information"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:32
#, no-wrap
msgid "Long lines"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:36
msgid ""
"For rules lines that are particularly long, it is possible to split them "
"over multiple lines implicity like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:40
#, no-wrap
msgid ""
"pass in on bgeo proto tcp from 1.1.1.1 port E<gt> 1000\n"
"    to 2.2.2.2 port E<lt> 5000 flags S keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:43
msgid "or explicitly using the backslash ('\\e') character:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:47
#, no-wrap
msgid ""
"pass in on bgeo proto tcp from 1.1.1.1 port E<gt> 1000 \\e\n"
"    to 2.2.2.2 port E<lt> 5000 flags S keep state\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:48
#, no-wrap
msgid "Comments"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:52
msgid ""
"Comments in the ipf.conf file are indicated by the use of the '#' "
"character.  This can either be at the start of the line, like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:56
#, no-wrap
msgid ""
"# Allow all ICMP packets in\n"
"pass in proto icmp from any to any\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:59
msgid "Or at the end of a like, like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:62
#, no-wrap
msgid "pass in proto icmp from any to any # Allow all ICMP packets in\n"
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:63
#, no-wrap
msgid "Firewall rules"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:67
msgid ""
"This section goes into detail on how to construct firewall rules that are "
"placed in the ipf.conf file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:72
msgid ""
"It is beyond the scope of this document to describe what makes a good "
"firewall rule set or which packets should be blocked or allowed in.  Some "
"suggestions will be provided but further reading is expected to fully "
"understand what is safe and unsafe to allow in/out."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:72
#, no-wrap
msgid "Filter rule keywords"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:78
msgid ""
"The first word found in any filter rule describes what the eventual outcome "
"of a packet that matches it will be. Descriptions of the many and various "
"sections that can be used to match on the contents of packet headers will "
"follow on below."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:80
msgid "The complete list of keywords, along with what they do is as follows:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:85
msgid ""
"pass rules that match a packet indicate to ipfilter that it should be "
"allowed to continue on in the direction it is flowing."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:90
msgid ""
"block rules are used when it is desirable to prevent a packet from going any "
"further. Packets that are blocked on the \"in\" side are never seen by "
"TCP/IP and those that are blocked going \"out\" are never seen on the wire."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:98
msgid ""
"log when IPFilter successfully matches a packet against a log rule a log "
"record is generated and made available for ipmon(8) to read. These rules "
"have no impact on whether or not a packet is allowed through or not.  So if "
"a packet first matched a block rule and then matched a log rule, the status "
"of the packet after the log rule is that it will still be blocked."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:106
msgid ""
"count rules provide the administrator with the ability to count packets and "
"bytes that match the criteria laid out in the configuration file.  The count "
"rules are applied after NAT and filter rules on the inbound path. For "
"outbound packets, count rules are applied before NAT and before the packet "
"is dropped. Thus the count rule cannot be used as a true indicator of link "
"layer"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:114
msgid ""
"auth rules cause the matching packet to be queued up for processing by a "
"user space program. The user space program is responsible for making an "
"ioctl system call to collect the information about the queued packet and "
"another ioctl system call to return the verdict (block, pass, etc) on what "
"to do with the packet. In the event that the queue becomes full, the packets "
"will end up being dropped."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:119
msgid ""
"call provides access to functions built into IPFilter that allow for more "
"complex actions to be taken as part of the decision making that goes with "
"the rule."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:128
msgid ""
"decapsulate rules instruct ipfilter to remove any other headers (IP, UDP, "
"AH) and then process what is inside as a new packet.  For non-UDP packets, "
"there are builtin checks that are applied in addition to whatever is "
"specified in the rule, to only allow decapsulation of recognised "
"protocols. After decapsulating the inner packet, any filtering result that "
"is applied to the inner packet is also applied to the other packet."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:134
msgid ""
"The default way in which filter rules are applied is for the last matching "
"rule to be used as the decision maker. So even if the first rule to match a "
"packet is a pass, if there is a later matching rule that is a block and no "
"further rules match the packet, then it will be blocked."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:134
#, no-wrap
msgid "Matching Network Interfaces"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:142
msgid ""
"On systems with more than one network interface, it is necessary to be able "
"to specify different filter rules for each of them.  In the first instance, "
"this is because different networks will send us packets via each network "
"interface but it is also because of the hosts, the role and the resulting "
"security policy that we need to be able to distinguish which network "
"interface a packet is on."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:149
msgid ""
"To accomodate systems where the presence of a network interface is dynamic, "
"it is not necessary for the network interface named in a filter rule to be "
"present in the system when the rule is loaded.  This can lead to silent "
"errors being introduced and unexpected behaviour with the simplest of "
"keyboard mistakes - for example, typing in hem0 instead of hme0 or hme2 "
"instead of hme3."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:154
msgid ""
"On Solaris systems prior to Solaris 10 Update 4, it is not possible to "
"filter packets on the loopback interface (lo0) so filter rules that specify "
"it will have no impact on the corresponding flow of packets. See below for "
"Solaris specific tips on how to enable this."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:156
msgid "Some examples of including the network interface in filter rules are:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:160
#, no-wrap
msgid ""
"block in on bge0 all\n"
"pass out on bge0 all\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:161
#, no-wrap
msgid "Address matching (basic)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:168
msgid ""
"The first and most basic part of matching for filtering rules is to specify "
"IP addresses and TCP/UDP port numbers. The source address information is "
"matched by the \"from\" information in a filter rule and the destination "
"address information is matched with the \"to\" information in a filter rule."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:176
msgid ""
"The typical format used for IP addresses is CIDR notation, where an IP "
"address (or network) is followed by a '/' and a number representing the size "
"of the netmask in bits. This notation is used for specifying address "
"matching in both IPv4 and IPv6. If the '/' and bitmask size are excluded "
"from the matching string, it is assumed that the address specified is a host "
"address and that the netmask applied should be all 1's."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:178 /usr/src/contrib/ipfilter/man/ipf.5:352
msgid "Some examples of this are:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:182
#, no-wrap
msgid ""
"pass in from 10.1.0.0/24 to any\n"
"block out from any to 10.1.1.1\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:186
msgid ""
"It is not possible to specify a range of addresses that does not have a "
"boundary that can be defined by a standard subnet mask."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:188
msgid "B<Names instead of addresses>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:194
msgid ""
"Hostnames, resolved either via DNS or /etc/hosts, or network names, resolved "
"via /etc/networks, may be used in place of actual addresses in the filter "
"rules. WARNING: if a hostname expands to more than one address, only the "
"*first* is used in building the filter rule."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:199
msgid ""
"Caution should be exercised when relying on DNS for filter rules in case the "
"sending and receiving of DNS packets is blocked when ipf(8)  is processing "
"that part of the configuration file, leading to long delays, if not errors, "
"in loading the filter rules."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:200
#, no-wrap
msgid "Protocol Matching"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:206
msgid ""
"To match packets based on TCP/UDP port information, it is first necessary to "
"indicate which protocol the packet must be. This is done using the \"proto\" "
"keyword, followed by either the protocol number or a name which is mapped to "
"the protocol number, usually through the /etc/protocols file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:211
#, no-wrap
msgid ""
"pass in proto tcp from 10.1.0.0/24 to any\n"
"block out proto udp from any to 10.1.1.1\n"
"pass in proto icmp from any to 192.168.0.0/16\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:212
#, no-wrap
msgid "Sending back error packets"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:222
msgid ""
"When a packet is just discarded using a block rule, there is no feedback "
"given to the host that sent the packet. This is both good and bad. If this "
"is the desired behaviour and it is not desirable to send any feedback about "
"packets that are to be denied. The catch is that often a host trying to "
"connect to a TCP port or with a UDP based application will send more than "
"one packet because it assumes that just one packet may be discarded so a "
"retry is required. The end result being logs can become cluttered with "
"duplicate entries due to the retries."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:230
msgid ""
"To address this problem, a block rule can be qualified in two ways.  The "
"first of these is specific to TCP and instructs IPFilter to send back a "
"reset (RST) packet. This packet indicates to the remote system that the "
"packet it sent has been rejected and that it shouldn't make any further "
"attempts to send packets to that port. Telling IPFilter to return a TCP RST "
"packet in response to something that has been received is achieved with the "
"return-rst keyword like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:233
#, no-wrap
msgid "block return-rst in proto tcp from 10.0.0.0/8 to any\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:238
msgid ""
"When sending back a TCP RST packet, IPFilter must construct a new packet "
"that has the source address of the intended target, not the source address "
"of the system it is running on (if they are different.)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:245
msgid ""
"For all of the other protocols handled by the IP protocol suite, to send "
"back an error indicating that the received packet was dropped requires "
"sending back an ICMP error packet. Whilst these can also be used for TCP, "
"the sending host may not treat the received ICMP error as a hard error in "
"the same way as it does the TCP RST packet. To return an ICMP error it is "
"necessary to place return-icmp after the block keyword like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:248
#, no-wrap
msgid "block return-icmp in proto udp from any to 192.168.0.1/24\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:258
msgid ""
"When electing to return an ICMP error packet, it is also possible to select "
"what type of ICMP error is returned. Whilst the full compliment of ICMP "
"unreachable codes can be used by specifying a number instead of the string "
"below, only the following should be used in conjunction with "
"return-icmp. Which return code to use is a choice to be made when weighing "
"up the pro's and con's. Using some of the codes may make it more obvious "
"that a firewall is being used rather than just the host not responding."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:264
msgid ""
"filter-prohib (prohibited by filter)  sending packets to the destination "
"given in the received packet is prohibited due to the application of a "
"packet filter"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:269
msgid ""
"net-prohib (prohibited network)  sending packets to the destination given in "
"the received packet is administratively prohibited."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:274
msgid ""
"host-unk (host unknown)  the destination host address is not known by the "
"system receiving the packet and therefore cannot be reached."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:279
msgid ""
"host-unr (host unreachable)  it is not possible to reach the host as given "
"by the destination address in the packet header."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:284
msgid ""
"net-unk (network unknown)  the destination network address is not known by "
"the system receiving the packet and therefore cannot be reached."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:289
msgid ""
"net-unr (network unreachable)  it is not possible to forward the packet on "
"to its final destination as given by the destination address"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:294
msgid ""
"port-unr (port unreachable)  there is no application using the given "
"destination port and therefore it is not possible to reach that port."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:299
msgid ""
"proto-unr (protocol unreachable)  the IP protocol specified in the packet is "
"not available to receive packets."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:303
msgid ""
"An example that shows how to send back a port unreachable packet for UDP "
"packets to 192.168.1.0/24 is as follows:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:306
#, no-wrap
msgid "block return-icmp(port-unr) in proto udp from any to 192.168.1.0/24\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:315
msgid ""
"In the above examples, when sending the ICMP packet, IPFilter will construct "
"a new ICMP packet with a source address of the network interface used to "
"send the packet back to the original source. This can give away that there "
"is an intermediate system blocking packets. To have IPFilter send back ICMP "
"packets where the source address is the original destination, regardless of "
"whether or not it is on the local host, return-icmp-as-dest is used like "
"this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:319
#, no-wrap
msgid ""
"block return-icmp-as-dest(port-unr) in proto udp \\e\n"
"    from any to 192.168.1.0/24\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:320
#, no-wrap
msgid "TCP/UDP Port Matching"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:327
msgid ""
"Having specified which protocol is being matched, it is then possible to "
"indicate which port numbers a packet must have in order to match the rule.  "
"Due to port numbers being used differently to addresses, it is therefore "
"possible to match on them in different ways. IPFilter allows you to use the "
"following logical operations:"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:327
#, no-wrap
msgid "E<lt> x"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:331
msgid ""
"is true if the port number is greater than or equal to x and less than or "
"equal to y is true if the port number in the packet is less than x"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:331
#, no-wrap
msgid "E<lt>= x"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:333
msgid "is true if the port number in the packet is less than or equal to x"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:333
#, no-wrap
msgid "E<gt> x"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:335
msgid "is true if the port number in the packet is greater than x"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:335
#, no-wrap
msgid "E<gt>= x"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:337
msgid "is true if the port number in the packet is greater or equal to x"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:337
#, no-wrap
msgid "= x"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:339
msgid "is true if the port number in the packet is equal to x"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:339
#, no-wrap
msgid "!= x"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:341
msgid "is true if the port number in the packet is not equal to x"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:343
msgid "Additionally, there are a number of ways to specify a range of ports:"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:343
#, no-wrap
msgid "x E<lt>E<gt> y"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:345
msgid "is true if the port number is less than a and greater than y"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:345
#, no-wrap
msgid "x E<gt>E<lt> y"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:347
msgid "is true if the port number is greater than x and less than y"
msgstr ""

#. type: IP
#: /usr/src/contrib/ipfilter/man/ipf.5:347
#, no-wrap
msgid "x:y"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:350
msgid ""
"is true if the port number is greater than or equal to x and less than or "
"equal to y"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:359
#, no-wrap
msgid ""
"block in proto tcp from any port E<gt>= 1024 to any port E<lt> 1024\n"
"pass in proto tcp from 10.1.0.0/24 to any port = 22\n"
"block out proto udp from any to 10.1.1.1 port = 135\n"
"pass in proto udp from 1.1.1.1 port = 123 to 10.1.1.1 port = 123\n"
"pass in proto tcp from 127.0.0.0/8 to any port = 6000:6009\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:364
msgid ""
"If there is no desire to mention any specific source or destintion "
"information in a filter rule then the word \"all\" can be used to indicate "
"that all addresses are considered to match the rule."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:364
#, no-wrap
msgid "IPv4 or IPv6"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:371
msgid ""
"If a filter rule is constructed without any addresses then IPFilter will "
"attempt to match both IPv4 and IPv6 packets with it. In the next list of "
"rules, each one can be applied to either network protocol because there is "
"no address specified from which IPFilter can derive with network protocol to "
"expect."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:375
#, no-wrap
msgid ""
"pass in proto udp from any to any port = 53\n"
"block in proto tcp from any port E<lt> 1024 to any\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:381
msgid ""
"To explicitly match a particular network address family with a specific "
"rule, the family must be added to the rule. For IPv4 it is necessary to add "
"family inet and for IPv6, family inet6. Thus the next rule will block all "
"packets (both IPv4 and IPv6:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:384
#, no-wrap
msgid "block in all\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:388
msgid ""
"but in the following example, we block all IPv4 packets and only allow in "
"IPv6 packets:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:392
#, no-wrap
msgid ""
"block in family inet all\n"
"pass in family inet6 all\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:398
msgid ""
"To continue on from the example where we allowed either IPv4 or IPv6 packets "
"to port 53 in, to change that such that only IPv6 packets to port 53 need to "
"allowed blocked then it is possible to add in a protocol family qualifier:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:401
#, no-wrap
msgid "pass in family inet6 proto udp from any to any port = 53\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:402
#, no-wrap
msgid "First match vs last match"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:407
msgid ""
"To change the default behaviour from being the last matched rule decides the "
"outcome to being the first matched rule, the word \"quick\" is inserted to "
"the rule."
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:407
#, no-wrap
msgid "Extended Packet Matching"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:408
#, no-wrap
msgid "Beyond using plain addresses"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:415
msgid ""
"On firewalls that are working with large numbers of hosts and networks or "
"simply trying to filter discretely against various hosts, it can be an "
"easier administration task to define a pool of addresses and have a filter "
"rule reference that address pool rather than have a rule for each address."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:421
msgid ""
"In addition to being able to use address pools, it is possible to use the "
"interface name(s) in the from/to address fields of a rule. If the name being "
"used in the address section can be matched to any of the interface names "
"mentioned in the rule's \"on\" or \"via\" fields then it can be used with "
"one of the following keywords for extended effect:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:425
msgid ""
"broadcast use the primary broadcast address of the network interface for "
"matching packets with this filter rule;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:428
#, no-wrap
msgid "pass in on fxp0 proto udp from any to fxp0/broadcast port = 123\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:437
msgid ""
"peer use the peer address on point to point network interfaces for matching "
"packets with this filter rule. This option typically only has meaningful use "
"with link protocols such as SLIP and PPP.  For example, this rule allows "
"ICMP packets from the remote peer of ppp0 to be received if they're destined "
"for the address assigned to the link at the firewall end."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:440
#, no-wrap
msgid "pass in on ppp0 proto icmp from ppp0/peer to ppp0/32\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:450
msgid ""
"netmasked use the primary network address, with its netmask, of the network "
"interface for matching packets with this filter rule. If a network interface "
"had an IP address of 192.168.1.1 and its netmask was 255.255.255.0 (/24), "
"then using the word \"netmasked\" after the interface name would match any "
"addresses that would match 192.168.1.0/24. If we assume that bge0 has this "
"IP address and netmask then the following two rules both serve to produce "
"the same effect:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:454
#, no-wrap
msgid ""
"pass in on bge0 proto icmp from any to 192.168.1.0/24\n"
"pass in on bge0 proto icmp from any to bge0/netmasked\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:461
msgid ""
"network using the primary network address, and its netmask, of the network "
"interface, construct an address for exact matching. If a network interface "
"has an address of 192.168.1.1 and its netmask is 255.255.255.0, using this "
"option would only match packets to 192.168.1.0."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:464
#, no-wrap
msgid "pass in on bge0 proto icmp from any to bge0/network\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:474
msgid ""
"Another way to use the name of a network interface to get the address is to "
"wrap the name in ()'s. In the above method, IPFilter looks at the interface "
"names in use and to decide whether or not the name given is a hostname or "
"network interface name. With the use of ()'s, it is possible to tell "
"IPFilter that the name should be treated as a network interface name even "
"though it doesn't appear in the list of network interface that the rule ias "
"associated with."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:477
#, no-wrap
msgid "pass in proto icmp from any to (bge0)/32\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:478
#, no-wrap
msgid "Using address pools"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:488
msgid ""
"Rather than list out multiple rules that either allow or deny specific "
"addresses, it is possible to create a single object, call an address pool, "
"that contains all of those addresses and reference that in the filter "
"rule. For documentation on how to write the configuration file for those "
"pools and load them, see ippool.conf(5) and ippool(8).  There are two types "
"of address pools that can be defined in ippool.conf(5): trees and hash "
"tables. To refer to a tree defined in ippool.conf(5), use this syntax:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:491
#, no-wrap
msgid "pass in from pool/trusted to any\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:497
msgid ""
"Either a name or number can be used after the '/', just so long as it "
"matches up with something that has already been defined in ipool.conf(5)  "
"and loaded in with ippool(8). Loading a filter rule that references a pool "
"that does not exist will result in an error."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:500
msgid ""
"If hash tables have been used in ippool.conf(5) to store the addresses in "
"instead of a tree, then replace the word pool with hash:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:503
#, no-wrap
msgid "pass in from any to hash/webservers\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:508
msgid ""
"There are different operational characteristics with each, so there may be "
"some situations where a pool works better than hash and vice versa."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:508
#, no-wrap
msgid "Matching TCP flags"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:517
msgid ""
"The TCP header contains a field of flags that is used to decide if the "
"packet is a connection request, connection termination, data, etc.  By "
"matching on the flags in conjunction with port numbers, it is possible to "
"restrict the way in which IPFilter allows connections to be created.  A "
"quick overview of the TCP flags is below. Each is listed with the letter "
"used in IPFilter rules, followed by its three or four letter pneumonic."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:522
msgid ""
"S SYN - this bit is set when a host is setting up a connection.  The "
"initiator typically sends a packet with the SYN bit and the responder sends "
"back SYN plus ACK."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:526
msgid ""
"A ACK - this bit is set when the sender wishes to acknowledge the receipt of "
"a packet from another host"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:530
msgid ""
"P PUSH - this bit is set when a sending host has send some data that is yet "
"to be acknowledged and a reply is sought"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:534
msgid ""
"F FIN - this bit is set when one end of a connection starts to close the "
"connection down"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:537
msgid "U URG - this bit is set to indicate that the packet contains urgent data"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:541
msgid ""
"R RST - this bit is set only in packets that are a reply to another that has "
"been received but is not targetted at any open port"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:544
msgid "C CWN"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:547
msgid "E ECN"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:557
msgid ""
"When matching TCP flags, it is normal to just list the flag that you wish to "
"be set. By default the set of flags it is compared against is "
"\"FSRPAU\". Rules that say \"flags S\" will be displayed by ipfstat(8)  as "
"having \"flags S/FSRPAU\". This is normal.  The last two flags, \"C\" and "
"\"E\", are optional - they may or may not be used by an end host and have no "
"bearing on either the acceptance of data nor control of the "
"connection. Masking them out with \"flags S/FSRPAUCE\" may cause problems "
"for remote hosts making a successful connection."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:561
#, no-wrap
msgid ""
"pass in quick proto tcp from any to any port = 22 flags S/SAFR\n"
"pass out quick proto tcp from any port = 22 to any flags SA\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:565
msgid ""
"By itself, filtering based on the TCP flags becomes more work but when "
"combined with stateful filtering (see below), the situation changes."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:565
#, no-wrap
msgid "Matching on ICMP header information"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:571
msgid ""
"The TCP and UDP are not the only protocols for which filtering beyond just "
"the IP header is possible, extended matching on ICMP packets is also "
"available. The list of valid ICMP types is different for IPv4 vs IPv6."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:575
msgid ""
"As a practical example, to allow the ping command to work against a specific "
"target requires allowing two different types of ICMP packets, like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:579
#, no-wrap
msgid ""
"pass in proto icmp from any to webserver icmp-type echo\n"
"pass out proto icmp from webserver to any icmp-type echorep\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:586
msgid ""
"The ICMP header has two fields that are of interest for filtering: the ICMP "
"type and code. Filter rules can accept either a name or number for both the "
"type and code. The list of names supported for ICMP types is listed below, "
"however only ICMP unreachable errors have named codes (see above.)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:589
msgid ""
"The list of ICMP types that are available for matching an IPv4 packet are as "
"follows:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:605
msgid ""
"echo (echo request), echorep (echo reply), inforeq (information request), "
"inforep (information reply), maskreq (mask request), maskrep (mask reply), "
"paramprob (parameter problem), redir (redirect), routerad (router "
"advertisement), routersol (router solicit), squence (source quence), timest "
"(timestamp), timestreq (timestamp reply), timex (time exceeded), unreach "
"(unreachable)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:608
msgid ""
"The list of ICMP types that are available for matching an IPv6 packet are as "
"follows:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:630
msgid ""
"echo (echo request), echorep (echo reply), fqdnquery (FQDN query), fqdnreply "
"(FQDN reply), inforeq (information request), inforep (information reply), "
"listendone (MLD listener done), listendqry (MLD listener query), listendrep "
"(MLD listener reply), neighadvert (neighbour advert), neighborsol (neighbour "
"solicit), paramprob (parameter problem), redir (redirect), renumber (router "
"renumbering), routerad (router advertisement), routersol (router solicit), "
"timex (time exceeded), toobig (packet too big), unreach (unreachable, whoreq "
"(WRU request), whorep (WRU reply)."
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:630
#, no-wrap
msgid "Stateful Packet Filtering"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:635
msgid ""
"Stateful packet filtering is where IPFilter remembers some information from "
"one or more packets that it has seen and is able to apply it to future "
"packets that it receives from the network."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:648
msgid ""
"What this means for each transport layer protocol is different.  For TCP it "
"means that if IPFilter sees the very first packet of an attempt to make a "
"connection, it has enough information to allow all other subsequent packets "
"without there needing to be any explicit rules to match them. IPFilter uses "
"the TCP port numbers, TCP flags, window size and sequence numbers to "
"determine which packets should be matched. For UDP, only the UDP port "
"numbers are available.  For ICMP, the ICMP types can be combined with the "
"ICMP id field to determine which reply packets match a request/query that "
"has already been seen. For all other protocols, only matching on IP address "
"and protocol number is available for determining if a packet received is a "
"mate to one that has already been let through."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:651
msgid ""
"The difference this makes is a reduction in the number of rules from 2 or 4 "
"to 1. For example, these 4 rules:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:657
#, no-wrap
msgid ""
"pass in on bge0 proto tcp from any to any port = 22\n"
"pass out on bge1 proto tcp from any to any port = 22\n"
"pass in on bge1 proto tcp from any port = 22 to any\n"
"pass out on bge0 proto tcp from any port = 22 to any\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:660
msgid "can be replaced with this single rule:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:663
#, no-wrap
msgid "pass in on bge0 proto tcp from any to any port = 22 flags S keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:666
msgid "Similar rules for UDP and ICMP might be:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:670
#, no-wrap
msgid ""
"pass in on bge0 proto udp from any to any port = 53 keep state\n"
"pass in on bge0 proto icmp all icmp-type echo keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:685
msgid ""
"When using stateful filtering with TCP it is best to add \"flags S\" to the "
"rule to ensure that state is only created when a packet is seen that is an "
"indication of a new connection. Although IPFilter can gather some "
"information from packets in the middle of a TCP connection to do stateful "
"filtering, there are some options that are only sent at the start of the "
"connection which alter the valid window of what TCP accepts. The end result "
"of trying to pickup TCP state in mid connection is that some later packets "
"that are part of the connection may not match the known state information "
"and be dropped or blocked, causing problems. If a TCP packet matches IP "
"addresses and port numbers but does not fit into the recognised window, it "
"will not be automatically allowed and will be flagged inside of IPFitler as "
"\"out of window\" (oow). See below, \"Extra packet attributes\", for how to "
"match on this attribute."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:697
msgid ""
"Once a TCP connection has reached the established state, the default timeout "
"allows for it to be idle for 5 days before it is removed from the state "
"table. The timeouts for the other TCP connection states vary from 240 "
"seconds to 30 seconds.  Both UDP and ICMP state entries have asymetric "
"timeouts where the timeout set upon seeing packets in the forward direction "
"is much larger than for the reverse direction. For UDP the default timeouts "
"are 120 and 12 seconds, for ICMP 60 and 6 seconds. This is a reflection of "
"the use of these protocols being more for query-response than for ongoing "
"connections.  For all other protocols the timeout is 60 seconds in both "
"directions."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:697
#, no-wrap
msgid "Stateful filtering options"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:700
msgid "The following options can be used with stateful filtering:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:707
msgid ""
"limit limit the number of state table entries that this rule can create to "
"the number given after limit. A rule that has a limit specified is always "
"permitted that many state table entries, even if creating an additional "
"entry would cause the table to have more entries than the otherwise global "
"limit."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:710
#, no-wrap
msgid "pass ... keep state(limit 100)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:718
msgid ""
"age sets the timeout for the state entry when it sees packets going through "
"it. Additionally it is possible to set the tieout for the reply packets that "
"come back through the firewall to a different value than for the forward "
"path. allowing a short timeout to be set after the reply has been seen and "
"the state no longer required."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:725
#, no-wrap
msgid ""
"pass in quick proto icmp all icmp-type echo \\e\n"
"    keep state (age 3)\n"
"pass in quick proto udp from any \\e\n"
"    to any port = 53 keep state (age 30/1)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:733
msgid ""
"strict only has an impact when used with TCP. It forces all packets that are "
"allowed through the firewall to be sequential: no out of order delivery of "
"packets is allowed. This can cause significant slowdown for some connections "
"and may stall others. Use with caution."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:736
#, no-wrap
msgid "pass in proto tcp ... keep state(strict)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:741
msgid ""
"noicmperr prevents ICMP error packets from being able to match state table "
"entries created with this flag using the contents of the original packet "
"included."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:744
#, no-wrap
msgid "pass ... keep state(noicmperr)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:750
msgid ""
"sync indicates to IPFilter that it needs to provide information to the user "
"land daemons responsible for syncing other machines state tables up with "
"this one."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:753
#, no-wrap
msgid "pass ... keep state(sync)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:758
msgid ""
"nolog do not generate any log records for the creation or deletion of state "
"table entries."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:761
#, no-wrap
msgid "pass ... keep state(nolog)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:769
msgid ""
"icmp-head rather than just precent ICMP error packets from being able to "
"match state table entries, allow an ACL to be processed that can filter in "
"or out ICMP error packets based as you would with normal firewall rules.  "
"The icmp-head option requires a filter rule group number or name to be "
"present, just as you would use with head."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:774
#, no-wrap
msgid ""
"pass in quick proto tcp ... keep state(icmp-head 101)\n"
"block in proto icmp from 10.0.0.0/8 to any group 101\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:780
msgid ""
"max-srcs allows the number of distinct hosts that can create a state entry "
"to be defined."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:784
#, no-wrap
msgid ""
"pass ... keep state(max-srcs 100)\n"
"pass ... keep state(limit 1000, max-srcs 100)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:792
msgid ""
"max-per-src whilst max-srcs limits the number of individual hosts that may "
"cause the creation of a state table entry, each one of those hosts is still "
"table to fill up the state table with new entries until the global maximum "
"is reached. This option allows the number of state table entries per address "
"to be limited."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:796
#, no-wrap
msgid ""
"pass ... keep state(max-srcs 100, max-per-src 1)\n"
"pass ... keep state(limit 100, max-srcs 100, max-per-src 1)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:803
msgid ""
"Whilst these two rules might seem identical, in that they both ultimately "
"limit the number of hosts and state table entries created from the rule to "
"100, there is a subtle difference: the second will always allow up to 100 "
"state table entries to be created whereas the first may not if the state "
"table fills up from other rules."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:807
msgid ""
"Further, it is possible to specify a netmask size after the per-host limit "
"that enables the per-host limit to become a per-subnet or per-network limit."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:810
#, no-wrap
msgid "pass ... keep state(max-srcs 100, max-per-src 1/24)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:815
msgid ""
"If there is no IP protocol implied by addresses or other features of the "
"rule, IPFilter will assume that no netmask is an all ones netmask for both "
"IPv4 and IPv6."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:815
#, no-wrap
msgid "Tieing down a connection"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:820
msgid ""
"For any connection that transits a firewall, each packet will be seen twice: "
"once going in and once going out. Thus a connection has 4 flows of packets:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:823
msgid "forward inbound packets"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:826
msgid "forward outbound packets"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:829
msgid "reverse inbound packets"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:832
msgid "reverse outbound packets"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:838
msgid ""
"IPFilter allows you to define the network interface to be used at all four "
"points in the flow of packets. For rules that match inbound packets, out-via "
"is used to specify which interfaces the packets go out, For rules that match "
"outbound packets, in-via is used to match the inbound packets.  In each "
"case, the syntax generalises to this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:842
#, no-wrap
msgid ""
"pass ... in on forward-in,reverse-in \\e\n"
"       out-via forward-out,reverse-out ...\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:845
#, no-wrap
msgid ""
"pass ... out on forward-out,reverse-out \\e\n"
"         in-via forward-in,reverse-in ...\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:849
msgid ""
"An example that pins down all 4 network interfaces used by an ssh connection "
"might look something like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:853
#, no-wrap
msgid ""
"pass in on bge0,bge1 out-via bge1,bge0 proto tcp \\e\n"
"    from any to any port = 22 flags S keep state\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:854
#, no-wrap
msgid "Working with packet fragments"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:858
msgid ""
"Fragmented packets result in 1 packet containing all of the layer 3 and 4 "
"header information whilst the data is split across a number of other "
"packets."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:868
msgid ""
"To enforce access control on fragmented packets, one of two approaches can "
"be taken. The first is to allow through all of the data fragments (those "
"that made up the body of the original packet) and rely on matching the "
"header information in the \"first\" fragment, when it is seen. The reception "
"of body fragments without the first will result in the receiving host being "
"unable to completely reassemble the packet and discarding all of the "
"fragments. The following three rules deny all fragmented packets from being "
"received except those that are UDP and even then only allows those destined "
"for port 2049 to be completed."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:873
#, no-wrap
msgid ""
"block in all with frags\n"
"pass in proto udp from any to any with frag-body\n"
"pass in proto udp from any to any port = 2049 with frags\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:882
msgid ""
"Another mechanism that is available is to track \"fragment state\".  This "
"relies on the first fragment of a packet that arrives to be the fragment "
"that contains all of the layer 3 and layer 4 header information. With the "
"receipt of that fragment before any other, it is possible to determine which "
"other fragments are to be allowed through without needing to explicitly "
"allow all fragment body packets.  An example of how this is done is as "
"follows:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:885
#, no-wrap
msgid "pass in proto udp from any port = 2049 to any with frags keep frags\n"
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:886
#, no-wrap
msgid "Building a tree of rules"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:892
msgid ""
"Writing your filter rules as one long list of rules can be both inefficient "
"in terms of processing the rules and difficult to understand. To make the "
"construction of filter rules easier, it is possible to place them in "
"groups.  A rule can be both a member of a group and the head of a new group."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:898
msgid ""
"Using filter groups requires at least two rules: one to be in the group one "
"one to send matchign packets to the group. If a packet matches a filtre rule "
"that is a group head but does not match any of the rules in that group, then "
"the packet is considered to have matched the head rule."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:907
msgid ""
"Rules that are a member of a group contain the word group followed by either "
"a name or number that defines which group they're in. Rules that form the "
"branch point or starting point for the group must use the word head, "
"followed by either a group name or number. If rules are loaded in that "
"define a group but there is no matching head then they will effectively be "
"orphaned rules. It is possible to have more than one head rule point to the "
"same group, allowing groups to be used like subroutines to implement "
"specific common policies."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:911
msgid ""
"A common use of filter groups is to define head rules that exist in the "
"filter \"main line\" for each direction with the interfaces in use. For "
"example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:918
#, no-wrap
msgid ""
"block in quick on bge0 all head 100\n"
"block out quick on bge0 all head 101\n"
"block in quick on fxp0 all head internal-in\n"
"block out quick on fxp0 all head internal-out\n"
"pass in quick proto icmp all icmp-type echo group 100\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:924
msgid ""
"In the above set of rules, there are four groups defined but only one of "
"them has a member rule. The only packets that would be allowed through the "
"above ruleset would be ICMP echo packets that are received on bge0."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:927
msgid ""
"Rules can be both a member of a group and the head of a new group, allowing "
"groups to specialise."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:931
#, no-wrap
msgid ""
"block in quick on bge0 all head 100\n"
"block in quick proto tcp all head 1006 group 100\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:937
msgid ""
"Another use of filter rule groups is to provide a place for rules to be "
"dynamically added without needing to worry about their specific ordering "
"amongst the entire ruleset. For example, if I was using this simple ruleset:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:942
#, no-wrap
msgid ""
"block in quick all with bad\n"
"block in proto tcp from any to any port = smtp head spammers\n"
"pass in quick proto tcp from any to any port = smtp flags S keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:946
msgid ""
"and I was getting lots of connections to my email server from 10.1.1.1 to "
"deliver spam, I could load the following rule to complement the above:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:949
#, no-wrap
msgid "block in quick from 10.1.1.1 to any group spammers\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:950
#, no-wrap
msgid "Decapsulation"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:957
msgid ""
"Rule groups also form a different but vital role for decapsulation rules.  "
"With the following simple rule, if IPFilter receives an IP packet that has "
"an AH header as its layer 4 payload, IPFilter would adjust its view of the "
"packet internally and then jump to group 1001 using the data beyond the AH "
"header as the new transport header."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:960
#, no-wrap
msgid "decapsulate in proto ah all head 1001\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:968
msgid ""
"For protocols that are recognised as being used with tunnelling or otherwise "
"encapsulating IP protocols, IPFilter is able to decide what it has on the "
"inside without any assistance. Some tunnelling protocols use UDP as the "
"transport mechanism. In this case, it is necessary to instruct IPFilter as "
"to what protocol is inside UDP."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:972
#, no-wrap
msgid ""
"decapsulate l5-as(ip) in proto udp from any \\e\n"
"    to any port = 1520 head 1001\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:976
msgid ""
"Currently IPFilter only supports finding IPv4 and IPv6 headers directly "
"after the UDP header."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:981
msgid ""
"If a packet matches a decapsulate rule but fails to match any of the rules "
"that are within the specified group, processing of the packet continues to "
"the next rule after the decapsulate and IPFilter's internal view of the "
"packet is returned to what it was prior to the decapsulate rule."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:985
msgid ""
"It is possible to construct a decapsulate rule without the group head at the "
"end that ipf(8) will accept but such rules will not result in anything "
"happening."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:985
#, no-wrap
msgid "Policy Based Routing"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:993
msgid ""
"With firewalls being in the position they often are, at the boundary of "
"different networks connecting together and multiple connections that have "
"different properties, it is often desirable to have packets flow in a "
"direction different to what the routing table instructs the kernel.  These "
"decisions can often be extended to changing the route based on both source "
"and destination address or even port numbers."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:999
msgid ""
"To support this kind of configuration, IPFilter allows the next hop "
"destination to be specified with a filter rule. The next hop is given with "
"the interface name to use for output. The syntax for this is "
"interface:ip.address. It is expected that the address given as the next hop "
"is directly connected to the network to which the interface is."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1003
#, no-wrap
msgid ""
"pass in on bge0 to bge1:1.1.1.1 proto tcp \\e\n"
"    from 1.1.2.3 to any port = 80 flags S keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1009
msgid ""
"When this feature is combined with stateful filtering, it becomes possible "
"to influence the network interface used to transmit packets in both "
"directions because we now have a sense for what its reverse flow of packets "
"is."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1013
#, no-wrap
msgid ""
"pass in on bge0 to bge1:1.1.1.1 reply-to hme1:2.1.1.2 \\e\n"
"    proto tcp from 1.1.2.3 to any port = 80 flags S keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1019
msgid ""
"If the actions of the routing table are perfectly acceptable, but you would "
"like to mask the presence of the firewall by not changing the TTL in IP "
"packets as they transit it, IPFilter can be instructed to do a \"fastroute\" "
"action like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1022
#, no-wrap
msgid "pass in on bge0 fastroute proto icmp all\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1027
msgid ""
"This should be used with caution as it can lead to endless packet "
"loops. Additionally, policy based routing does not change the IP header's "
"TTL value."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1031
msgid ""
"A variation on this type of rule supports a duplicate of the original packet "
"being created and sent out a different network. This can be useful for "
"monitoring traffic and other purposes."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1036
#, no-wrap
msgid ""
"pass in on bge0 to bge1:1.1.1.1 reply-to hme1:2.1.1.2 \\e\n"
"    dup-to fxp0:10.0.0.1 proto tcp from 1.1.2.3 \\e\n"
"    to any port = 80 flags S keep state\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1037
#, no-wrap
msgid "Matching IPv4 options"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1046
msgid ""
"The design for IPv4 allows for the header to be upto 64 bytes long, however "
"most traffic only uses the basic header which is 20 bytes long.  The other "
"44 bytes can be uesd to store IP options. These options are generally not "
"necessary for proper interaction and function on the Internet today. For "
"most people it is sufficient to block and drop all packets that have any "
"options set. This can be achieved with this rule:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1049
#, no-wrap
msgid "block in quick all with ipopts\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1053
msgid ""
"This rule is usually placed towards the top of the configuration so that all "
"incoming packets are blocked."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1056
msgid ""
"If you wanted to allow in a specific IP option type, the syntax changes "
"slightly:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1059
#, no-wrap
msgid "pass in quick proto igmp all with opt rtralrt\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1063
msgid ""
"The following is a list of IP options that most people encounter and what "
"their use/threat is."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1070
msgid ""
"lsrr (loose source route) the sender of the packet includes a list of "
"addresses that they wish the packet to be routed through to on the way to "
"the destination. Because replies to such packets are expected to use the "
"list of addresses in reverse, hackers are able to very effectively use this "
"header option in address spoofing attacks."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1078
msgid ""
"rr (record route) the sender allocates some buffer space for recording the "
"IP address of each router that the packet goes through. This is most often "
"used with ping, where the ping response contains a copy of all addresses "
"from the original packet, telling the sender what route the packet took to "
"get there. Due to performance and security issues with IP header options, "
"this is almost no longer used."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1085
msgid ""
"rtralrt (router alert) this option is often used in IGMP messages as a flag "
"to routers that the packet needs to be handled differently. It is unlikely "
"to ever be received from an unknown sender. It may be found on LANs or "
"otherwise controlled networks where the RSVP protocol and multicast traffic "
"is in heavy use."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1092
msgid ""
"ssrr (strict source route) the sender of the packet includes a list of "
"addresses that they wish the packet to be routed through to on the way to "
"the destination. Where the lsrr option allows the sender to specify only "
"some of the nodes the packet must go through, with the ssrr option, every "
"next hop router must be specified."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1118
msgid ""
"The complete list of IPv4 options that can be matched on is: addext (Address "
"Extention), cipso (Classical IP Security Option), dps (Dynamic Packet "
"State), e-sec (Extended Security), eip (Extended Internet Protocol), encode "
"(ENCODE), finn (Experimental Flow Control), imitd (IMI Traffic Descriptor), "
"lsrr (Loose Source Route), mtup (MTU Probe - obsolete), mtur (MTU response - "
"obsolete), nop (No Operation), nsapa (NSAP Address), rr (Record Route), "
"rtralrt (Router Alert), satid (Stream Identifier), sdb (Selective Directed "
"Broadcast), sec (Security), ssrr (Strict Source Route), tr (Tracerote), ts "
"(Timestamp), ump (Upstream Multicast Packet), visa (Experimental Access "
"Control)  and zsu (Experimental Measurement)."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1118
#, no-wrap
msgid "Security with CIPSO and IPSO"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1125
msgid ""
"IPFilter supports filtering on IPv4 packets using security attributes "
"embedded in the IP options part of the packet. These options are usually "
"only used on networks and systems that are using lablled security. Unless "
"you know that you are using labelled security and your networking is also "
"labelled, it is highly unlikely that this section will be relevant to you."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1137
msgid ""
"With the traditional IP Security Options (IPSO), packets can be tagged with "
"a security level. The following keywords are recognised and match with the "
"relevant RFC with respect to the bit patterns matched: confid "
"(confidential), rserve-1 (1st reserved value), rserve-2 (2nd reserved "
"value), rserve-3 (3rd reserved value), rserve-4 (4th reserved value), secret "
"(secret), topsecret (top secret), unclass (unclassified)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1141
#, no-wrap
msgid ""
"block in quick all with opt sec-class unclass\n"
"pass in all with opt sec-class secret\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1142
#, no-wrap
msgid "Matching IPv6 extension headers"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1147
msgid ""
"Just as it is possible to filter on the various IPv4 header options, so too "
"it is possible to filter on the IPv6 extension headers that are placed "
"between the IPv6 header and the transport protocol header."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1156
msgid ""
"dstopts (destination options), esp (encrypted, secure, payload), frag "
"(fragment), hopopts (hop-by-hop options), ipv6 (IPv6 header), mobility (IP "
"mobility), none, routing."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1156
#, no-wrap
msgid "Logging"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1162
msgid ""
"There are two ways in which packets can be logged with IPFilter. The first "
"is with a rule that specifically says log these types of packets and the "
"second is a qualifier to one of the other keywords. Thus it is possible to "
"both log and allow or deny a packet with a single rule."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1165
#, no-wrap
msgid "pass in log quick proto tcp from any to any port = 22\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1173
msgid ""
"When using stateful filtering, the log action becomes part of the result "
"that is remembered about a packet. Thus if the above rule was qualified with "
"keep state, every packet in the connection would be logged. To only log the "
"first packet from every packet flow tracked with keep state, it is necessary "
"to indicate to IPFilter that you only wish to log the first packet."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1177
#, no-wrap
msgid ""
"pass in log first quick proto tcp from any to any port = 22 \\e\n"
"    flags S keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1186
msgid ""
"If it is a requirement that the logging provide an accurate representation "
"of which connections are allowed, the log action can be qualified with the "
"option or-block. This allows the administrator to instruct IPFilter to block "
"the packet if the attempt to record the packet in IPFilter's kernel log "
"records (which have an upper bound on size) failed. Unless the system shuts "
"down or reboots, once a log record is written into the kernel buffer, it is "
"there until ipmon(8) reads it."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1191
#, no-wrap
msgid ""
"block in log proto tcp from any to any port = smtp\n"
"pass in log or-block first quick proto tcp from any \\e\n"
"    to any port = 22 flags S keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1197
msgid ""
"By default, IPFilter will only log the header portion of a packet received "
"on the network. A portion of the body of a packet, upto 128 bytes, can also "
"be logged with the body keyword. ipmon(8) will display the contents of the "
"portion of the body logged in hex."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1200
#, no-wrap
msgid "block in log body proto icmp all\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1205
msgid ""
"When logging packets from ipmon(8) to syslog, by default ipmon(8) will "
"control what syslog facility and priority a packet will be logged with.  "
"This can be tuned on a per rule basis like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1210
#, no-wrap
msgid ""
"block in quick log level err all with bad\n"
"pass in log level local1.info proto tcp \\e\n"
"    from any to any port = 22 flags S keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1214
msgid ""
"ipfstat(8) reports how many packets have been successfully logged and how "
"many failed attempts to log a packet there were."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1214
#, no-wrap
msgid "Filter rule comments"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1220
msgid ""
"If there is a desire to associate a text string, be it an administrative "
"comment or otherwise, with an IPFilter rule, this can be achieved by giving "
"the filter rule a comment.  The comment is loaded with the rule into the "
"kernel and can be seen when the rules are listed with ipfstat."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1226
#, no-wrap
msgid ""
"pass in quick proto tcp from any \\e\n"
"    to port = 80 comment \"all web server traffic is ok\"\n"
"pass out quick proto tcp from any port = 80 \\e\n"
"    to any comment \"all web server traffic is ok\"\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1227
#, no-wrap
msgid "Tags"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1234
msgid ""
"To enable filtering and NAT to correctly match up packets with rules, tags "
"can be added at with NAT (for inbound packets) and filtering (for outbound "
"packets.) This allows a filter to be correctly mated with its NAT rule in "
"the event that the NAT rule changed the packet in a way that would mean it "
"is not obvious what it was."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1238
msgid ""
"For inbound packets, IPFilter can match the tag used in the filter rules "
"with that set by NAT. For outbound rules, it is the reverse, the filter sets "
"the tag and the NAT rule matches up with it."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1242
#, no-wrap
msgid ""
"pass in ... match-tag(nat=proxy)\n"
"pass out ... set-tag(nat=proxy)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1248
msgid ""
"Another use of tags is to supply a number that is only used with logging.  "
"When packets match these rules, the log tag is carried over into the log "
"file records generated by ipmon(8). With the correct use of tools such as "
"grep, extracting log records of interest is simplified."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1251
#, no-wrap
msgid "block in quick log ... set-tag(log=33)\n"
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:1252
#, no-wrap
msgid "Filter Rule Expiration"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1260
msgid ""
"IPFilter allows rules to be added into the kernel that it will remove after "
"a specific period of time by specifying rule-ttl at the end of a rule.  When "
"listing rules in the kernel using ipfstat(8), rules that are going to expire "
"will NOT display \"rule-ttl\" with the timeout, rather what will be seen is "
"a comment with how many ipfilter ticks left the rule has to live."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1262
msgid "The time to live is specified in seconds."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1266
#, no-wrap
msgid ""
"pass in on fxp0 proto tcp from any \\e\n"
"    to port = 22 flags S keep state rule-ttl 30\n"
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:1267
#, no-wrap
msgid "Internal packet attributes"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1274
msgid ""
"In addition to being able to filter on very specific network and transport "
"header fields, it is possible to filter on other attributes that IPFilter "
"attaches to a packet. These attributes are placed in a rule after the "
"keyword \"with\", as can be seen with frags and frag-body above. The "
"following is a list of the other attributes available:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1279
msgid ""
"oow the packet's IP addresses and TCP ports match an existing entry in the "
"state table but the sequence numbers indicate that it is outside of the "
"accepted window."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1282
#, no-wrap
msgid "block return-rst in quick proto tcp from any to any with not oow\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1288
msgid ""
"bcast this is set by IPFilter when it receives notification that the link "
"layer packet was a broadcast packet. No checking of the IP addresses is "
"performned to determine if it is a broadcast destination or not."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1291
#, no-wrap
msgid "block in quick proto udp all with bcast\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1297
msgid ""
"mcast this is set by IPFilter when it receives notification that the link "
"layer packet was a multicast packet. No checking of the IP addresses is "
"performned to determine if it is a multicast destination or not."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1300
#, no-wrap
msgid "pass in quick proto udp from any to any port = dns with mcast\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1305
msgid ""
"mbcast can be used to match a packet that is either a multicast or broadcast "
"packet at the link layer, as indicated by the operating system."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1308
#, no-wrap
msgid "pass in quick proto udp from any to any port = ntp with mbcast\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1312
msgid "nat the packet positively matched a NAT table entry."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1316
msgid ""
"bad sanity checking of the packet failed. This could indicate that the layer "
"3/4 headers are not properly formed."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1322
msgid ""
"bad-src when reverse path verification is enabled, this flag will be set "
"when the interface the packet is received on does not match that which would "
"be used to send a packet out of to the source address in the received "
"packet."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1325
msgid "bad-nat an attempt to perform NAT on the packet failed."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1330
msgid ""
"not each one of the attributes matched using the \"with\" keyword can also "
"be looked for to not be present. For example, to only allow in good packets, "
"I can do this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1334
#, no-wrap
msgid ""
"block in all\n"
"pass in all with not bad\n"
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:1335
#, no-wrap
msgid "Tuning IPFilter"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1343
msgid ""
"The ipf.conf file can also be used to tune the behaviour of IPFilter, "
"allowing, for example, timeouts for the NAT/state table(s) to be set along "
"with their sizes. The presence and names of tunables may change from one "
"release of IPFilter to the next. The tunables that can be changed via "
"ipf.conf is the same as those that can be seen and modified using the -T "
"command line option to ipf(8)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1348
msgid ""
"NOTE: When parsing ipf.conf, ipf(8) will apply the settings before loading "
"any rules. Thus if your settings are at the top, these may be applied whilst "
"the rules not applied if there is an error further down in the configuration "
"file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1351
msgid ""
"To set one of the values below, the syntax is simple: \"set\", followed by "
"the name of the tuneable to set and then the value to set it to."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1355
#, no-wrap
msgid ""
"set state_max 9999;\n"
"set state_size 10101;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1359
msgid ""
"A list of the currently available variables inside IPFilter that may be "
"tuned from ipf.conf are as follows:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1362
msgid "active set through -s command line switch of ipf(8). See ipf(8) for detals."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1366
msgid ""
"chksrc when set, enables reverse path verification on source addresses and "
"for filters to match packets with bad-src attribute."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1369
msgid ""
"control_forwarding when set turns off kernel forwarding when IPFilter is "
"disabled or unloaded."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1375
msgid ""
"default_pass the default policy - whether packets are blocked or passed, etc "
"- is represented by the value of this variable. It is a bit field and the "
"bits that can be set are found in E<lt>netinet/ip_fil.hE<gt>. It is not "
"recommended to tune this value directly."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1379
msgid ""
"ftp_debug set the debugging level of the in-kernel FTP proxy.  Debug "
"messages will be printed to the system console."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1383
msgid ""
"ftp_forcepasv when set the FTP proxy must see a PASV/EPSV command before "
"creating the state/NAT entries for the 227 response."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1387
msgid ""
"ftp_insecure when set the FTP proxy will not wait for a user to login before "
"allowing data connections to be created."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1391
msgid ""
"ftp_pasvonly when set the proxy will not create state/NAT entries for when "
"it sees either the PORT or EPRT command."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1396
msgid ""
"ftp_pasvrdr when enabled causes the FTP proxy to create very insecure "
"NAT/state entries that will allow any connection between the client and "
"server hosts when a 227 reply is seen.  Use with extreme caution."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1399
msgid ""
"ftp_single_xfer when set the FTP proxy will only allow one data connection "
"at a time."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1403
msgid ""
"hostmap_size sets the size of the hostmap table used by NAT to store address "
"mappings for use with sticky rules."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1407
msgid ""
"icmp_ack_timeout default timeout used for ICMP NAT/state when a reply packet "
"is seen for an ICMP state that already exists"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1411
msgid ""
"icmp_minfragmtu sets the minimum MTU that is considered acceptable in an "
"ICMP error before deciding it is a bad packet."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1414
msgid ""
"icmp_timeout default timeout used for ICMP NAT/state when the packet matches "
"the rule"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1417
msgid ""
"ip_timeout default timeout used for NAT/state entries that are not "
"TCP/UDP/ICMP."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1419
msgid "ipf_flags"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1423
msgid ""
"ips_proxy_debug this sets the debugging level for the proxy support code.  "
"When enabled, debugging messages will be printed to the system console."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1427
msgid ""
"log_all when set it changes the behaviour of \"log body\" to log the entire "
"packet rather than just the first 128 bytes."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1430
msgid "log_size sets the size of the in-kernel log buffer in bytes."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1436
msgid ""
"log_suppress when set, IPFilter will check to see if the packet it is "
"logging is similar to the one it previously logged and if so, increases the "
"occurance count for that packet. The previously logged packet must not have "
"yet been read by ipmon(8)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1440
msgid ""
"min_ttl is used to set the TTL value that packets below will be marked with "
"the low-ttl attribute."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1445
msgid ""
"nat_doflush if set it will cause the NAT code to do a more aggressive flush "
"of the NAT table at the next opportunity. Once the flush has been done, the "
"value is reset to 0."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1448
msgid "nat_lock this should only be changed using ipfs(8)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1451
msgid ""
"nat_logging when set, NAT will create log records that can be read from "
"/dev/ipnat."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1456
msgid ""
"nat_maxbucket maximum number of entries allowed to exist in each NAT hash "
"bucket.  This prevents an attacker trying to load up the hash table with "
"entries in a single bucket, reducing performance."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1459
msgid "nat_rules_size size of the hash table to store map rules."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1462
msgid "nat_table_max maximum number of entries allowed into the NAT table"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1465
msgid "nat_table_size size of the hash table used for NAT"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1469
msgid ""
"nat_table_wm_high when the fill percentage of the NAT table exceeds this "
"mark, more aggressive flushing is enabled."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1473
msgid ""
"nat_table_wm_low this sets the percentage at which the NAT table's agressive "
"flushing will turn itself off at."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1476
msgid "rdr_rules_size size of the hash table to store rdr rules."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1479
msgid "state_lock this should only be changed using ipfs(8)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1483
msgid ""
"state_logging when set, the stateful filtering will create log records that "
"can be read from /dev/ipstate."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1486
msgid "state_max maximum number of entries allowed into the state table"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1491
msgid ""
"state_maxbucket maximum number of entries allowed to exist in each state "
"hash bucket.  This prevents an attacker trying to load up the hash table "
"with entries in a single bucket, reducing performance."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1494
msgid "state_size size of the hash table used for stateful filtering"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1498
msgid ""
"state_wm_freq this controls how often the agressive flushing should be run "
"once the state table exceeds state_wm_high in percentage full."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1502
msgid ""
"state_wm_high when the fill percentage of the state table exceeds this mark, "
"more aggressive flushing is enabled."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1506
msgid ""
"state_wm_low this sets the percentage at which the state table's agressive "
"flushing will turn itself off at."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1509
msgid ""
"tcp_close_wait timeout used when a TCP state entry reaches the FIN_WAIT_2 "
"state."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1513
msgid ""
"tcp_closed timeout used when a TCP state entry is ready to be removed after "
"either a RST packet is seen."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1516
msgid ""
"tcp_half_closed timeout used when a TCP state entry reaches the CLOSE_WAIT "
"state."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1519
msgid ""
"tcp_idle_timeout timeout used when a TCP state entry reaches the ESTABLISHED "
"state."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1522
msgid ""
"tcp_last_ack timeout used when a TCP NAT/state entry reaches the LAST_ACK "
"state."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1525
msgid ""
"tcp_syn_received timeout applied to a TCP NAT/state entry after SYN-ACK "
"packet has been seen."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1528
msgid ""
"tcp_syn_sent timeout applied to a TCP NAT/state entry after SYN packet has "
"been seen."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1531
msgid ""
"tcp_time_wait timeout used when a TCP NAT/state entry reaches the TIME_WAIT "
"state."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1535
msgid ""
"tcp_timeout timeout used when a TCP NAT/state entry reaches either the half "
"established state (one ack is seen after a SYN-ACK) or one side is in "
"FIN_WAIT_1."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1539
msgid ""
"udp_ack_timeout default timeout used for UDP NAT/state when a reply packet "
"is seen for a UDP state that already exists"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1542
msgid ""
"udp_timeout default timeout used for UDP NAT/state when the packet matches "
"the rule"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1546
msgid ""
"update_ipid when set, turns on changing the IP id field in NAT'd packets to "
"a random number."
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1546
#, no-wrap
msgid "Table of visible variables"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1550
msgid ""
"A list of all of the tunables, their minimum, maximum and current values is "
"as follows."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1604
#, no-wrap
msgid ""
"Name\t\t\t\tMin\tMax\tCurrent\n"
"active\t\t\t0\t0\t0\n"
"chksrc\t\t\t0\t1\t0\n"
"control_forwarding\t0\t1\t0\n"
"default_pass\t\t0\tMAXUINT\t134217730\n"
"ftp_debug\t\t\t0\t10\t0\n"
"ftp_forcepasv\t\t0\t1\t1\n"
"ftp_insecure\t\t0\t1\t0\n"
"ftp_pasvonly\t\t0\t1\t0\n"
"ftp_pasvrdr\t\t0\t1\t0\n"
"ftp_single_xfer\t0\t1\t0\n"
"hostmap_size\t\t1\tMAXINT\t2047\n"
"icmp_ack_timeout\t1\tMAXINT\t12\n"
"icmp_minfragmtu\t0\t1\t68\n"
"icmp_timeout\t\t1\tMAXINT\t120\n"
"ip_timeout\t\t1\tMAXINT\t120\n"
"ipf_flags\t\t\t0\tMAXUINT\t0\n"
"ips_proxy_debug\t0\t10\t0\n"
"log_all\t\t\t0\t1\t0\n"
"log_size\t\t\t0\t524288\t32768\n"
"log_suppress\t\t0\t1\t1\n"
"min_ttl\t\t\t0\t1\t4\n"
"nat_doflush\t\t0\t1\t0\n"
"nat_lock\t\t\t0\t1\t0\n"
"nat_logging\t\t0\t1\t1\n"
"nat_maxbucket\t\t1\tMAXINT\t22\n"
"nat_rules_size\t\t1\tMAXINT\t127\n"
"nat_table_max\t\t1\tMAXINT\t30000\n"
"nat_table_size\t\t1\tMAXINT\t2047\n"
"nat_table_wm_high\t2\t100\t99\n"
"nat_table_wm_low\t1\t99\t90\n"
"rdr_rules_size\t\t1\tMAXINT\t127\n"
"state_lock\t\t0\t1\t0\n"
"state_logging\t\t0\t1\t1\n"
"state_max\t\t\t1\tMAXINT\t4013\n"
"state_maxbucket\t1\tMAXINT\t26\n"
"state_size\t\t1\tMAXINT\t5737\n"
"state_wm_freq\t\t2\t999999\t20\n"
"state_wm_high\t\t2\t100\t99\n"
"state_wm_low\t\t1\t99\t90\n"
"tcp_close_wait\t\t1\tMAXINT\t480\n"
"tcp_closed\t\t1\tMAXINT\t60\n"
"tcp_half_closed\t1\tMAXINT\t14400\n"
"tcp_idle_timeout\t1\tMAXINT\t864000\n"
"tcp_last_ack\t\t1\tMAXINT\t60\n"
"tcp_syn_received\t1\tMAXINT\t480\n"
"tcp_syn_sent\t\t1\tMAXINT\t480\n"
"tcp_time_wait\t\t1\tMAXINT\t480\n"
"tcp_timeout\t\t1\tMAXINT\t480\n"
"udp_ack_timeout\t1\tMAXINT\t24\n"
"udp_timeout\t\t1\tMAXINT\t240\n"
"update_ipid\t\t0\t1\t0\n"
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:1605
#, no-wrap
msgid "Calling out to internal functions"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1612
msgid ""
"IPFilter provides a pair of functions that can be called from a rule that "
"allow for a single rule to jump out to a group rather than walk through a "
"list of rules to find the group. If you've got multiple networks, each with "
"its own group of rules, this feature may help provide better filtering "
"performance."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1615
msgid ""
"The lookup to find which rule group to jump to is done on either the source "
"address or the destination address but not both."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1626
msgid ""
"In this example below, we are blocking all packets by default but then doing "
"a lookup on the source address from group 1010. The two rules in the "
"ipf.conf section are lone members of their group. For an incoming packet "
"that is from 1.1.1.1, it will go through three rules: (1) the block rule, "
"(2) the call rule and (3) the pass rule for group 1020.  For a packet that "
"is from 3.3.2.2, it will also go through three rules: (1) the block rule, "
"(2) the call rule and (3) the pass rule for group 1030. Should a packet from "
"3.1.1.1 arrive, it will be blocked as it does not match any of the entries "
"in group 1010, leaving it to only match the first rule."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1634
#, no-wrap
msgid ""
"from ipf.conf\n"
"-------------\n"
"block in all\n"
"call now srcgrpmap/1010 in all\n"
"pass in proto tcp from any to any port = 80 group 1020\n"
"pass in proto icmp all icmp-type echo group 1030\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1639
#, no-wrap
msgid ""
"from ippool.conf\n"
"----------------\n"
"group-map in role=ipf number=1010\n"
"    { 1.1.1.1 group = 1020, 3.3.0.0/16 group = 1030; };\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1640
#, no-wrap
msgid "IPFilter matching expressions"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1646
msgid ""
"An experimental feature that has been added to filter rules is to use the "
"same expression matching that is available with various commands to flush "
"and list state/NAT table entries. The use of such an expression precludes "
"the filter rule from using the normal IP header matching."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1649
#, no-wrap
msgid "pass in exp { \"tcp.sport 23 or tcp.sport 50\" } keep state\n"
msgstr ""

#. type: SS
#: /usr/src/contrib/ipfilter/man/ipf.5:1650
#, no-wrap
msgid "Filter rules with BPF"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1656
msgid ""
"On platforms that have the BPF built into the kernel, IPFilter can be built "
"to allow BPF expressions in filter rules. This allows for packet matching to "
"be on arbitrary data in the packt. The use of a BPF expression replaces all "
"of the other protocol header matching done by IPFilter."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1660
#, no-wrap
msgid ""
"pass in bpf-v4 { \"tcp and (src port 23 or src port 50)\" } \\e\n"
"    keep state\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1668
msgid ""
"These rules tend to be write-only because the act of compiling the filter "
"expression into the BPF instructions loaded into the kernel can make it "
"difficut to accurately reconstruct the original text filter. The end result "
"is that while ipf.conf() can be easy to read, understanding the output from "
"ipfstat might not be."
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:1668
#, no-wrap
msgid "VARIABLES"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1672
msgid ""
"This configuration file, like all others used with IPFilter, supports the "
"use of variable substitution throughout the text."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1676
#, no-wrap
msgid ""
"nif=\"ppp0\";\n"
"pass in on $nif from any to any\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1679
msgid "would become"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1682
#, no-wrap
msgid "pass in on ppp0 from any to any\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1686
msgid ""
"Variables can be used recursively, such as 'foo=\"$bar baz\";', so long as "
"$bar exists when the parser reaches the assignment for foo."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1691
msgid ""
"See B<ipf(8)> for instructions on how to define variables to be used from a "
"shell environment."
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:1692
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1695
msgid "/dev/ipf /etc/ipf.conf"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1697
msgid "/usr/share/examples/ipfilter Directory with examples."
msgstr ""

#. type: SH
#: /usr/src/contrib/ipfilter/man/ipf.5:1697
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/ipfilter/man/ipf.5:1698
msgid "ipf(8), ipfstat(8), ippool.conf(5), ippool(8)"
msgstr ""
