# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-05-18 14:28-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Dd
#: /usr/src/share/man/man9/bus_space.9:55
#, no-wrap
msgid "January 15, 2017"
msgstr ""

#. type: Dt
#: /usr/src/share/man/man9/bus_space.9:56
#, no-wrap
msgid "BUS_SPACE 9"
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:58
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:137
msgid ""
"E<.Nm bus_space>, E<.Nm bus_space_barrier>, E<.Nm bus_space_copy_region_1>, "
"E<.Nm bus_space_copy_region_2>, E<.Nm bus_space_copy_region_4>, E<.Nm "
"bus_space_copy_region_8>, E<.Nm bus_space_copy_region_stream_1>, E<.Nm "
"bus_space_copy_region_stream_2>, E<.Nm bus_space_copy_region_stream_4>, "
"E<.Nm bus_space_copy_region_stream_8>, E<.Nm bus_space_free>, E<.Nm "
"bus_space_map>, E<.Nm bus_space_read_1>, E<.Nm bus_space_read_2>, E<.Nm "
"bus_space_read_4>, E<.Nm bus_space_read_8>, E<.Nm bus_space_read_multi_1>, "
"E<.Nm bus_space_read_multi_2>, E<.Nm bus_space_read_multi_4>, E<.Nm "
"bus_space_read_multi_8>, E<.Nm bus_space_read_multi_stream_1>, E<.Nm "
"bus_space_read_multi_stream_2>, E<.Nm bus_space_read_multi_stream_4>, E<.Nm "
"bus_space_read_multi_stream_8>, E<.Nm bus_space_read_region_1>, E<.Nm "
"bus_space_read_region_2>, E<.Nm bus_space_read_region_4>, E<.Nm "
"bus_space_read_region_8>, E<.Nm bus_space_read_region_stream_1>, E<.Nm "
"bus_space_read_region_stream_2>, E<.Nm bus_space_read_region_stream_4>, "
"E<.Nm bus_space_read_region_stream_8>, E<.Nm bus_space_read_stream_1>, E<.Nm "
"bus_space_read_stream_2>, E<.Nm bus_space_read_stream_4>, E<.Nm "
"bus_space_read_stream_8>, E<.Nm bus_space_set_multi_1>, E<.Nm "
"bus_space_set_multi_2>, E<.Nm bus_space_set_multi_4>, E<.Nm "
"bus_space_set_multi_8>, E<.Nm bus_space_set_multi_stream_1>, E<.Nm "
"bus_space_set_multi_stream_2>, E<.Nm bus_space_set_multi_stream_4>, E<.Nm "
"bus_space_set_multi_stream_8>, E<.Nm bus_space_set_region_1>, E<.Nm "
"bus_space_set_region_2>, E<.Nm bus_space_set_region_4>, E<.Nm "
"bus_space_set_region_8>, E<.Nm bus_space_set_region_stream_1>, E<.Nm "
"bus_space_set_region_stream_2>, E<.Nm bus_space_set_region_stream_4>, E<.Nm "
"bus_space_set_region_stream_8>, E<.Nm bus_space_subregion>, E<.Nm "
"bus_space_unmap>, E<.Nm bus_space_write_1>, E<.Nm bus_space_write_2>, E<.Nm "
"bus_space_write_4>, E<.Nm bus_space_write_8>, E<.Nm "
"bus_space_write_multi_1>, E<.Nm bus_space_write_multi_2>, E<.Nm "
"bus_space_write_multi_4>, E<.Nm bus_space_write_multi_8>, E<.Nm "
"bus_space_write_multi_stream_1>, E<.Nm bus_space_write_multi_stream_2>, "
"E<.Nm bus_space_write_multi_stream_4>, E<.Nm "
"bus_space_write_multi_stream_8>, E<.Nm bus_space_write_region_1>, E<.Nm "
"bus_space_write_region_2>, E<.Nm bus_space_write_region_4>, E<.Nm "
"bus_space_write_region_8>, E<.Nm bus_space_write_region_stream_1>, E<.Nm "
"bus_space_write_region_stream_2>, E<.Nm bus_space_write_region_stream_4>, "
"E<.Nm bus_space_write_region_stream_8>, E<.Nm bus_space_write_stream_1>, "
"E<.Nm bus_space_write_stream_2>, E<.Nm bus_space_write_stream_4>, E<.Nm "
"bus_space_write_stream_8>"
msgstr ""

#. type: Nd
#: /usr/src/share/man/man9/bus_space.9:137
#, no-wrap
msgid "bus space manipulation functions"
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:138
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: In
#: /usr/src/share/man/man9/bus_space.9:139 /usr/src/share/man/man9/bus_space.9:585 /usr/src/share/man/man9/bus_space.9:619 /usr/src/share/man/man9/bus_space.9:721
#, no-wrap
msgid "machine/bus.h"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:577
msgid ""
"E<.Ft int> E<.Fo bus_space_map> E<.Fa \"bus_space_tag_t space\" \"bus_addr_t "
"address\"> E<.Fa \"bus_size_t size\" \"int flags\" \"bus_space_handle_t "
"*handlep\"> E<.Fc> E<.Ft void> E<.Fo bus_space_unmap> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t size\"> "
"E<.Fc> E<.Ft int> E<.Fo bus_space_subregion> E<.Fa \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\"> E<.Fa \"bus_size_t offset\" \"bus_size_t "
"size\" \"bus_space_handle_t *nhandlep\"> E<.Fc> E<.Ft int> E<.Fo "
"bus_space_alloc> E<.Fa \"bus_space_tag_t space\" \"bus_addr_t reg_start\" "
"\"bus_addr_t reg_end\"> E<.Fa \"bus_size_t size\" \"bus_size_t alignment\" "
"\"bus_size_t boundary\"> E<.Fa \"int flags\" \"bus_addr_t *addrp\" "
"\"bus_space_handle_t *handlep\"> E<.Fc> E<.Ft void> E<.Fo bus_space_free> "
"E<.Fa \"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"size\"> E<.Fc> E<.Ft uint8_t> E<.Fo bus_space_read_1> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Fc> E<.Ft uint16_t> E<.Fo bus_space_read_2> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Fc> E<.Ft uint32_t> E<.Fo bus_space_read_4> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Fc> E<.Ft uint64_t> E<.Fo bus_space_read_8> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Fc> E<.Ft uint8_t> E<.Fo bus_space_read_stream_1> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Fc> E<.Ft uint16_t> E<.Fo bus_space_read_stream_2> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Fc> E<.Ft uint32_t> E<.Fo bus_space_read_stream_4> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Fc> E<.Ft uint64_t> E<.Fo bus_space_read_stream_8> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Fc> E<.Ft void> E<.Fo bus_space_write_1> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\"> E<.Fa \"bus_size_t "
"offset\" \"uint8_t value\"> E<.Fc> E<.Ft void> E<.Fo bus_space_write_2> "
"E<.Fa \"bus_space_tag_t space\" \"bus_space_handle_t handle\"> E<.Fa "
"\"bus_size_t offset\" \"uint16_t value\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_4> E<.Fa \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\"> E<.Fa \"bus_size_t offset\" \"uint32_t value\"> E<.Fc> E<.Ft void> "
"E<.Fo bus_space_write_8> E<.Fa \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\"> E<.Fa \"bus_size_t offset\" \"uint64_t "
"value\"> E<.Fc> E<.Ft void> E<.Fo bus_space_write_stream_1> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\"> E<.Fa \"bus_size_t "
"offset\" \"uint8_t value\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_stream_2> E<.Fa \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\"> E<.Fa \"bus_size_t offset\" \"uint16_t "
"value\"> E<.Fc> E<.Ft void> E<.Fo bus_space_write_stream_4> E<.Fa "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\"> E<.Fa \"bus_size_t "
"offset\" \"uint32_t value\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_stream_8> E<.Fa \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\"> E<.Fa \"bus_size_t offset\" \"uint64_t "
"value\"> E<.Fc> E<.Ft void> E<.Fo bus_space_barrier> E<.Fa \"bus_space_tag_t "
"space\" \"bus_space_handle_t handle\"> E<.Fa \"bus_size_t offset\" "
"\"bus_size_t length\" \"int flags\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_region_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_region_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_region_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_region_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_region_stream_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_region_stream_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_region_stream_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_region_stream_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_region_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_region_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_region_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_region_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_region_stream_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_region_stream_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_region_stream_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_region_stream_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_copy_region_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t srchandle\" \"bus_size_t srcoffset\"> E<.Fa "
"\"bus_space_handle_t dsthandle\" \"bus_size_t dstoffset\" \"bus_size_t "
"count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_copy_region_2> E<.Fa "
"\"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t srchandle\" "
"\"bus_size_t srcoffset\"> E<.Fa \"bus_space_handle_t dsthandle\" "
"\"bus_size_t dstoffset\" \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_copy_region_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t srchandle\" \"bus_size_t srcoffset\"> E<.Fa "
"\"bus_space_handle_t dsthandle\" \"bus_size_t dstoffset\" \"bus_size_t "
"count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_copy_region_8> E<.Fa "
"\"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t srchandle\" "
"\"bus_size_t srcoffset\"> E<.Fa \"bus_space_handle_t dsthandle\" "
"\"bus_size_t dstoffset\" \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_copy_region_stream_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t srchandle\" \"bus_size_t srcoffset\"> E<.Fa "
"\"bus_space_handle_t dsthandle\" \"bus_size_t dstoffset\" \"bus_size_t "
"count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_copy_region_stream_2> E<.Fa "
"\"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t srchandle\" "
"\"bus_size_t srcoffset\"> E<.Fa \"bus_space_handle_t dsthandle\" "
"\"bus_size_t dstoffset\" \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_copy_region_stream_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t srchandle\" \"bus_size_t srcoffset\"> E<.Fa "
"\"bus_space_handle_t dsthandle\" \"bus_size_t dstoffset\" \"bus_size_t "
"count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_copy_region_stream_8> E<.Fa "
"\"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t srchandle\" "
"\"bus_size_t srcoffset\"> E<.Fa \"bus_space_handle_t dsthandle\" "
"\"bus_size_t dstoffset\" \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_set_region_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t value\"> E<.Fa "
"\"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_set_region_2> E<.Fa "
"\"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint16_t value\"> E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> "
"E<.Fo bus_space_set_region_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t value\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_set_region_8> "
"E<.Fa \"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"uint64_t value\"> E<.Fa \"bus_size_t count\"> E<.Fc> "
"E<.Ft void> E<.Fo bus_space_set_region_stream_1> E<.Fa \"bus_space_tag_t "
"space\"> E<.Fa \"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t "
"value\"> E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_set_region_stream_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t value\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_set_region_stream_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t value\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_set_region_stream_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t value\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_read_multi_1> "
"E<.Fa \"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"uint8_t *datap\"> E<.Fa \"bus_size_t count\"> E<.Fc> "
"E<.Ft void> E<.Fo bus_space_read_multi_2> E<.Fa \"bus_space_tag_t space\"> "
"E<.Fa \"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t "
"*datap\"> E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_multi_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_read_multi_8> "
"E<.Fa \"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"uint64_t *datap\"> E<.Fa \"bus_size_t count\"> "
"E<.Fc> E<.Ft void> E<.Fo bus_space_read_multi_stream_1> E<.Fa "
"\"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint8_t *datap\"> E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> "
"E<.Fo bus_space_read_multi_stream_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_multi_stream_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_read_multi_stream_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_multi_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_multi_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_multi_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_multi_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_multi_stream_1> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_multi_stream_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_multi_stream_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_write_multi_stream_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_set_multi_1> "
"E<.Fa \"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"uint8_t value\"> E<.Fa \"bus_size_t count\"> E<.Fc> "
"E<.Ft void> E<.Fo bus_space_set_multi_2> E<.Fa \"bus_space_tag_t space\"> "
"E<.Fa \"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t "
"value\"> E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_set_multi_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t value\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo bus_space_set_multi_8> "
"E<.Fa \"bus_space_tag_t space\"> E<.Fa \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"uint64_t value\"> E<.Fa \"bus_size_t count\"> E<.Fc> "
"E<.Ft void> E<.Fo bus_space_set_multi_stream_1> E<.Fa \"bus_space_tag_t "
"space\"> E<.Fa \"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t "
"value\"> E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_set_multi_stream_2> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t value\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_set_multi_stream_4> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t value\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc> E<.Ft void> E<.Fo "
"bus_space_set_multi_stream_8> E<.Fa \"bus_space_tag_t space\"> E<.Fa "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t value\"> "
"E<.Fa \"bus_size_t count\"> E<.Fc>"
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:577
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:585
msgid ""
"The E<.Nm> functions exist to allow device drivers machine-independent "
"access to bus memory and register areas.  All of the functions and types "
"described in this document can be used by including the"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:587
msgid "header file."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:604
msgid ""
"Many common devices are used on multiple architectures, but are accessed "
"differently on each because of architectural constraints.  For instance, a "
"device which is mapped in one system's I/O space may be mapped in memory "
"space on a second system.  On a third system, architectural limitations "
"might change the way registers need to be accessed (e.g.\\& creating a "
"non-linear register space).  In some cases, a single driver may need to "
"access the same type of device in multiple ways in a single system or "
"architecture.  The goal of the E<.Nm> functions is to allow a single driver "
"source file to manipulate a set of devices on different system "
"architectures, and to allow a single driver object file to manipulate a set "
"of devices on multiple bus types on a single architecture."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:610
msgid ""
"Not all buses have to implement all functions described in this document, "
"though that is encouraged if the operations are logically supported by the "
"bus.  Unimplemented functions should cause compile-time errors if possible."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:619
msgid ""
"All of the interface definitions described in this document are shown as "
"function prototypes and discussed as if they were required to be functions.  "
"Implementations are encouraged to implement prototyped (type-checked) "
"versions of these interfaces, but may implement them as macros if "
"appropriate.  Machine-dependent types, variables, and functions should be "
"marked clearly in"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:623
msgid ""
"to avoid confusion with the machine-independent types and functions, and, if "
"possible, should be given names which make the machine-dependence clear."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:623
#, no-wrap
msgid "CONCEPTS AND GUIDELINES"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:637
msgid ""
"Bus spaces are described by bus space tags, which can be created only by "
"machine-dependent code.  A given machine may have several different types of "
"bus space (e.g.\\& memory space and I/O space), and thus may provide "
"multiple different bus space tags.  Individual buses or devices on a machine "
"may use more than one bus space tag.  For instance, ISA devices are given an "
"ISA memory space tag and an ISA I/O space tag.  Architectures may have "
"several different tags which represent the same type of space, for instance "
"because of multiple different host bus interface chipsets."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:646
msgid ""
"A range in bus space is described by a bus address and a bus size.  The bus "
"address describes the start of the range in bus space.  The bus size "
"describes the size of the range in bytes.  Buses which are not byte "
"addressable may require use of bus space ranges with appropriately aligned "
"addresses and properly rounded sizes."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:653
msgid ""
"Access to regions of bus space is facilitated by use of bus space handles, "
"which are usually created by mapping a specific range of a bus space.  "
"Handles may also be created by allocating and mapping a range of bus space, "
"the actual location of which is picked by the implementation within bounds "
"specified by the caller of the allocation function."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:667
msgid ""
"All of the bus space access functions require one bus space tag argument, at "
"least one handle argument, and at least one offset argument (a bus size).  "
"The bus space tag specifies the space, each handle specifies a region in the "
"space, and each offset specifies the offset into the region of the actual "
"location(s) to be accessed.  Offsets are given in bytes, though buses may "
"impose alignment constraints.  The offset used to access data relative to a "
"given handle must be such that all of the data being accessed is in the "
"mapped region that the handle describes.  Trying to access data outside that "
"region is an error."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:686
msgid ""
"Because some architectures' memory systems use buffering to improve memory "
"and device access performance, there is a mechanism which can be used to "
"create E<.Dq barriers> in the bus space read and write stream.  There are "
"three types of barriers: read, write, and read/write.  All reads started to "
"the region before a read barrier must complete before any reads after the "
"read barrier are started.  (The analogous requirement is true for write "
"barriers.)  Read/write barriers force all reads and writes started before "
"the barrier to complete before any reads or writes after the barrier are "
"started.  Correctly-written drivers will include all appropriate barriers, "
"and assume only the read/write ordering imposed by the barrier operations."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:697
msgid ""
"People trying to write portable drivers with the E<.Nm> functions should try "
"to make minimal assumptions about what the system allows.  In particular, "
"they should expect that the system requires bus space addresses being "
"accessed to be naturally aligned (i.e., base address of handle added to "
"offset is a multiple of the access size), and that the system does alignment "
"checking on pointers (i.e., pointer to objects being read and written must "
"point to properly-aligned data)."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:719
msgid ""
"The descriptions of the E<.Nm> functions given below all assume that they "
"are called with proper arguments.  If called with invalid arguments or "
"arguments that are out of range (e.g.\\& trying to access data outside of "
"the region mapped when a given handle was created), undefined behaviour "
"results.  In that case, they may cause the system to halt, either "
"intentionally (via panic) or unintentionally (by causing a fatal trap of by "
"some other means) or may cause improper operation which is not immediately "
"fatal.  Functions which return E<.Ft void> or which return data read from "
"bus space (i.e., functions which do not obviously return an error code) do "
"not fail.  They could only fail if given invalid arguments, and in that case "
"their behaviour is undefined.  Functions which take a count of bytes have "
"undefined results if the specified E<.Fa count> is zero."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:719
#, no-wrap
msgid "TYPES"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:721
msgid "Several types are defined in"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:725
msgid "to facilitate use of the E<.Nm> functions by drivers."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:725
#, no-wrap
msgid "Vt bus_addr_t"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:734
msgid ""
"The E<.Vt bus_addr_t> type is used to describe bus addresses.  It must be an "
"unsigned integral type capable of holding the largest bus address usable by "
"the architecture.  This type is primarily used when mapping and unmapping "
"bus space."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:734
#, no-wrap
msgid "Vt bus_size_t"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:746
msgid ""
"The E<.Vt bus_size_t> type is used to describe sizes of ranges in bus "
"space.  It must be an unsigned integral type capable of holding the size of "
"the largest bus address range usable on the architecture.  This type is used "
"by virtually all of the E<.Nm> functions, describing sizes when mapping "
"regions and offsets into regions when performing space access operations."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:746
#, no-wrap
msgid "Vt bus_space_tag_t"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:756
msgid ""
"The E<.Vt bus_space_tag_t> type is used to describe a particular bus space "
"on a machine.  Its contents are machine-dependent and should be considered "
"opaque by machine-independent code.  This type is used by all E<.Nm> "
"functions to name the space on which they are operating."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:756
#, no-wrap
msgid "Vt bus_space_handle_t"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:765
msgid ""
"The E<.Vt bus_space_handle_t> type is used to describe a mapping of a range "
"of bus space.  Its contents are machine-dependent and should be considered "
"opaque by machine-independent code.  This type is used when performing bus "
"space access operations."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:765
#, no-wrap
msgid "MAPPING AND UNMAPPING BUS SPACE"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:771 /usr/src/share/man/man9/bus_space.9:938
msgid ""
"This section is specific to the E<.Nx> version of these functions and may or "
"may not apply to the E<.Fx> version."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:779
msgid ""
"Bus space must be mapped before it can be used, and should be unmapped when "
"it is no longer needed.  The E<.Fn bus_space_map> and E<.Fn bus_space_unmap> "
"functions provide these capabilities."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:785
msgid ""
"Some drivers need to be able to pass a subregion of already-mapped bus space "
"to another driver or module within a driver.  The E<.Fn bus_space_subregion> "
"function allows such subregions to be created."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:785
#, no-wrap
msgid "Fn bus_space_map space address size flags handlep"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:803
msgid ""
"The E<.Fn bus_space_map> function maps the region of bus space named by the "
"E<.Fa space , address>, and E<.Fa size> arguments.  If successful, it "
"returns zero and fills in the bus space handle pointed to by E<.Fa handlep> "
"with the handle that can be used to access the mapped region.  If "
"unsuccessful, it will return non-zero and leave the bus space handle pointed "
"to by E<.Fa handlep> in an undefined state."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:808
msgid ""
"The E<.Fa flags> argument controls how the space is to be mapped.  Supported "
"flags include:"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:809
#, no-wrap
msgid "Dv BUS_SPACE_MAP_CACHEABLE"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:815
msgid ""
"Try to map the space so that accesses can be cached and/or prefetched by the "
"system.  If this flag is not specified, the implementation should map the "
"space so that it will not be cached or prefetched."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:818
msgid ""
"This flag must have a value of 1 on all implementations for backward "
"compatibility."
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:818
#, no-wrap
msgid "Dv BUS_SPACE_MAP_LINEAR"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:831
msgid ""
"Try to map the space so that its contents can be accessed linearly via "
"normal memory access methods (e.g.\\& pointer dereferencing and structure "
"accesses).  This is useful when software wants to do direct access to a "
"memory device, e.g.\\& a frame buffer.  If this flag is specified and linear "
"mapping is not possible, the E<.Fn bus_space_map> call should fail.  If this "
"flag is not specified, the system may map the space in whatever way is most "
"convenient."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:852
msgid ""
"Not all combinations of flags make sense or are supported with all spaces.  "
"For instance, E<.Dv BUS_SPACE_MAP_CACHEABLE> may be meaningless when used on "
"many systems' I/O port spaces, and on some systems E<.Dv "
"BUS_SPACE_MAP_LINEAR> without E<.Dv BUS_SPACE_MAP_CACHEABLE> may never "
"work.  When the system hardware or firmware provides hints as to how spaces "
"should be mapped (e.g.\\& the PCI memory mapping registers' E<.Dq "
"prefetchable> bit), those hints should be followed for maximum "
"compatibility.  On some systems, requesting a mapping that cannot be "
"satisfied (e.g.\\& requesting a non-cacheable mapping when the system can "
"only provide a cacheable one)  will cause the request to fail."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:860
msgid ""
"Some implementations may keep track of use of bus space for some or all bus "
"spaces and refuse to allow duplicate allocations.  This is encouraged for "
"bus spaces which have no notion of slot-specific space addressing, such as "
"ISA, and for spaces which coexist with those spaces (e.g.\\& PCI memory and "
"I/O spaces co-existing with ISA memory and I/O spaces)."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:865
msgid ""
"Mapped regions may contain areas for which there is no device on the bus.  "
"If space in those areas is accessed, the results are bus-dependent."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:865
#, no-wrap
msgid "Fn bus_space_unmap space handle size"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:876
msgid ""
"The E<.Fn bus_space_unmap> function unmaps a region of bus space mapped with "
"E<.Fn bus_space_map>.  When unmapping a region, the E<.Fa size> specified "
"should be the same as the size given to E<.Fn bus_space_map> when mapping "
"that region."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:883
msgid ""
"After E<.Fn bus_space_unmap> is called on a handle, that handle is no longer "
"valid.  (If copies were made of the handle they are no longer valid, "
"either.)"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:891
msgid ""
"This function will never fail.  If it would fail (e.g.\\& because of an "
"argument error), that indicates a software bug which should cause a panic.  "
"In that case, E<.Fn bus_space_unmap> will never return."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:891
#, no-wrap
msgid "Fn bus_space_subregion space handle offset size nhandlep"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:903
msgid ""
"The E<.Fn bus_space_subregion> function is a convenience function which "
"makes a new handle to some subregion of an already-mapped region of bus "
"space.  The subregion described by the new handle starts at byte offset "
"E<.Fa offset> into the region described by E<.Fa handle>, with the size give "
"by E<.Fa size>, and must be wholly contained within the original region."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:917
msgid ""
"If successful, E<.Fn bus_space_subregion> returns zero and fills in the bus "
"space handle pointed to by E<.Fa nhandlep>.  If unsuccessful, it returns "
"non-zero and leaves the bus space handle pointed to by E<.Fa nhandlep> in an "
"undefined state.  In either case, the handle described by E<.Fa handle> "
"remains valid and is unmodified."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:932
msgid ""
"When done with a handle created by E<.Fn bus_space_subregion>, the handle "
"should be thrown away.  Under no circumstances should E<.Fn bus_space_unmap> "
"be used on the handle.  Doing so may confuse any resource management being "
"done on the space, and will result in undefined behaviour.  When E<.Fn "
"bus_space_unmap> or E<.Fn bus_space_free> is called on a handle, all "
"subregions of that handle become invalid."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:932
#, no-wrap
msgid "ALLOCATING AND FREEING BUS SPACE"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:948
msgid ""
"Some devices require or allow bus space to be allocated by the operating "
"system for device use.  When the devices no longer need the space, the "
"operating system should free it for use by other devices.  The E<.Fn "
"bus_space_alloc> and E<.Fn bus_space_free> functions provide these "
"capabilities."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:948
#, no-wrap
msgid ""
"Fn bus_space_alloc space reg_start reg_end size alignment boundary flags "
"addrp handlep"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:967
msgid ""
"The E<.Fn bus_space_alloc> function allocates and maps a region of bus space "
"with the size given by E<.Fa size>, corresponding to the given constraints.  "
"If successful, it returns zero, fills in the bus address pointed to by E<.Fa "
"addrp> with the bus space address of the allocated region, and fills in the "
"bus space handle pointed to by E<.Fa handlep> with the handle that can be "
"used to access that region.  If unsuccessful, it returns non-zero and leaves "
"the bus address pointed to by E<.Fa addrp> and the bus space handle pointed "
"to by E<.Fa handlep> in an undefined state."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1000
msgid ""
"Constraints on the allocation are given by the E<.Fa reg_start , reg_end , "
"alignment>, and E<.Fa boundary> parameters.  The allocated region will start "
"at or after E<.Fa reg_start> and end before or at E<.Fa reg_end>.  The E<.Fa "
"alignment> constraint must be a power of two, and the allocated region will "
"start at an address that is an even multiple of that power of two.  The "
"E<.Fa boundary> constraint, if non-zero, ensures that the region is "
"allocated so that E<.Fa \"first address in region\"> / E<.Fa boundary> has "
"the same value as E<.Fa \"last address in region\"> / E<.Fa boundary>.  If "
"the constraints cannot be met, E<.Fn bus_space_alloc> will fail.  It is an "
"error to specify a set of constraints that can never be met (for example, "
"E<.Fa size> greater than E<.Fa boundary>)."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1007
msgid ""
"The E<.Fa flags> parameter is the same as the like-named parameter to E<.Fn "
"bus_space_map>, the same flag values should be used, and they have the same "
"meanings."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1020
msgid ""
"Handles created by E<.Fn bus_space_alloc> should only be freed with E<.Fn "
"bus_space_free>.  Trying to use E<.Fn bus_space_unmap> on them causes "
"undefined behaviour.  The E<.Fn bus_space_subregion> function can be used on "
"handles created by E<.Fn bus_space_alloc>."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1020
#, no-wrap
msgid "Fn bus_space_free space handle size"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1031
msgid ""
"The E<.Fn bus_space_free> function unmaps and frees a region of bus space "
"mapped and allocated with E<.Fn bus_space_alloc>.  When unmapping a region, "
"the E<.Fa size> specified should be the same as the size given to E<.Fn "
"bus_space_alloc> when allocating the region."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1037
msgid ""
"After E<.Fn bus_space_free> is called on a handle, that handle is no longer "
"valid.  (If copies were made of the handle, they are no longer valid, "
"either.)"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1045
msgid ""
"This function will never fail.  If it would fail (e.g.\\& because of an "
"argument error), that indicates a software bug which should cause a panic.  "
"In that case, E<.Fn bus_space_free> will never return."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1045
#, no-wrap
msgid "READING AND WRITING SINGLE DATA ITEMS"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1055
msgid ""
"The simplest way to access bus space is to read or write a single data "
"item.  The E<.Fn bus_space_read_N> and E<.Fn bus_space_write_N> families of "
"functions provide the ability to read and write 1, 2, 4, and 8 byte data "
"items on buses which support those access sizes."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1055
#, no-wrap
msgid "Fn bus_space_read_1 space handle offset"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1056
#, no-wrap
msgid "Fn bus_space_read_2 space handle offset"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1057
#, no-wrap
msgid "Fn bus_space_read_4 space handle offset"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1058
#, no-wrap
msgid "Fn bus_space_read_8 space handle offset"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1070
msgid ""
"The E<.Fn bus_space_read_N> family of functions reads a 1, 2, 4, or 8 byte "
"data item from the offset specified by E<.Fa offset> into the region "
"specified by E<.Fa handle> of the bus space specified by E<.Fa space>.  The "
"location being read must lie within the bus space region specified by E<.Fa "
"handle>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1076
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data item being "
"read.  On some systems, not obeying this requirement may cause incorrect "
"data to be read, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1084
msgid ""
"Read operations done by the E<.Fn bus_space_read_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1090 /usr/src/share/man/man9/bus_space.9:1127 /usr/src/share/man/man9/bus_space.9:1282 /usr/src/share/man/man9/bus_space.9:1334 /usr/src/share/man/man9/bus_space.9:1394 /usr/src/share/man/man9/bus_space.9:1444 /usr/src/share/man/man9/bus_space.9:1504 /usr/src/share/man/man9/bus_space.9:1552 /usr/src/share/man/man9/bus_space.9:1597
msgid ""
"These functions will never fail.  If they would fail (e.g.\\& because of an "
"argument error), that indicates a software bug which should cause a panic.  "
"In that case, they will never return."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1090
#, no-wrap
msgid "Fn bus_space_write_1 space handle offset value"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1091
#, no-wrap
msgid "Fn bus_space_write_2 space handle offset value"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1092
#, no-wrap
msgid "Fn bus_space_write_4 space handle offset value"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1093
#, no-wrap
msgid "Fn bus_space_write_8 space handle offset value"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1106
msgid ""
"The E<.Fn bus_space_write_N> family of functions writes a 1, 2, 4, or 8 byte "
"data item to the offset specified by E<.Fa offset> into the region specified "
"by E<.Fa handle> of the bus space specified by E<.Fa space>.  The location "
"being written must lie within the bus space region specified by E<.Fa "
"handle>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1113
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data item being "
"written.  On some systems, not obeying this requirement may cause incorrect "
"data to be written, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1121
msgid ""
"Write operations done by the E<.Fn bus_space_write_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1127
#, no-wrap
msgid "BARRIERS"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1134
msgid ""
"In order to allow high-performance buffering implementations to avoid bus "
"activity on every operation, read and write ordering should be specified "
"explicitly by drivers when necessary.  The E<.Fn bus_space_barrier> function "
"provides that ability."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1134
#, no-wrap
msgid "Fn bus_space_barrier space handle offset length flags"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1146
msgid ""
"The E<.Fn bus_space_barrier> function enforces ordering of bus space read "
"and write operations for the specified subregion (described by the E<.Fa "
"offset> and E<.Fa length> parameters) of the region named by E<.Fa handle> "
"in the space named by E<.Fa space>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1151
msgid ""
"The E<.Fa flags> argument controls what types of operations are to be "
"ordered.  Supported flags are:"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1152
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_READ"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1154
msgid "Synchronize read operations."
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1154
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_WRITE"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1156
msgid "Synchronize write operations."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1160
msgid ""
"Those flags can be combined (or-ed together) to enforce ordering on both "
"read and write operations."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1164
msgid ""
"All of the specified type(s) of operation which are done to the region "
"before the barrier operation are guaranteed to complete before any of the "
"specified type(s) of operation done after the barrier."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1174
msgid ""
"Example: Consider a hypothetical device with two single-byte ports, one "
"write-only input port (at offset 0) and a read-only output port (at offset "
"1).  Operation of the device is as follows: data bytes are written to the "
"input port, and are placed by the device on a stack, the top of which is "
"read by reading from the output port.  The sequence to correctly write two "
"data bytes to the device then read those two data bytes back would be:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1188
#, no-wrap
msgid ""
"/*\n"
" * t and h are the tag and handle for the mapped device's\n"
" * space.\n"
" */\n"
"bus_space_write_1(t, h, 0, data0);\n"
"bus_space_barrier(t, h, 0, 1, BUS_SPACE_BARRIER_WRITE);  /* 1 */\n"
"bus_space_write_1(t, h, 0, data1);\n"
"bus_space_barrier(t, h, 0, 2,\n"
"    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);     /* 2 */\n"
"ndata1 = bus_space_read_1(t, h, 1);\n"
"bus_space_barrier(t, h, 1, 1, BUS_SPACE_BARRIER_READ);   /* 3 */\n"
"ndata0 = bus_space_read_1(t, h, 1);\n"
"/* data0 == ndata0, data1 == ndata1 */\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1195
msgid ""
"The first barrier makes sure that the first write finishes before the second "
"write is issued, so that two writes to the input port are done in order and "
"are not collapsed into a single write.  This ensures that the data bytes are "
"written to the device correctly and in order."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1202
msgid ""
"The second barrier makes sure that the writes to the output port finish "
"before any of the reads to the input port are issued, thereby making sure "
"that all of the writes are finished before data is read.  This ensures that "
"the first byte read from the device really is the last one that was written."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1205
msgid ""
"The third barrier makes sure that the first read finishes before the second "
"read is issued, ensuring that data is read correctly and in order."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1212
msgid ""
"The barriers in the example above are specified to cover the absolute "
"minimum number of bus space locations.  It is correct (and often easier) to "
"make barrier operations cover the device's whole range of bus space, that "
"is, to specify an offset of zero and the size of the whole region."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1212
#, no-wrap
msgid "REGION OPERATIONS"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1223
msgid ""
"Some devices use buffers which are mapped as regions in bus space.  Often, "
"drivers want to copy the contents of those buffers to or from memory, "
"e.g.\\& into mbufs which can be passed to higher levels of the system or "
"from mbufs to be output to a network.  In order to allow drivers to do this "
"as efficiently as possible, the E<.Fn bus_space_read_region_N> and E<.Fn "
"bus_space_write_region_N> families of functions are provided."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1232
msgid ""
"Drivers occasionally need to copy one region of a bus space to another, or "
"to set all locations in a region of bus space to contain a single value.  "
"The E<.Fn bus_space_copy_region_N> family of functions and the E<.Fn "
"bus_space_set_region_N> family of functions allow drivers to perform these "
"operations."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1232
#, no-wrap
msgid "Fn bus_space_read_region_1 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1233
#, no-wrap
msgid "Fn bus_space_read_region_2 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1234
#, no-wrap
msgid "Fn bus_space_read_region_4 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1235
#, no-wrap
msgid "Fn bus_space_read_region_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1255
msgid ""
"The E<.Fn bus_space_read_region_N> family of functions reads E<.Fa count> 1, "
"2, 4, or 8 byte data items from bus space starting at byte offset E<.Fa "
"offset> in the region specified by E<.Fa handle> of the bus space specified "
"by E<.Fa space> and writes them into the array specified by E<.Fa datap>.  "
"Each successive data item is read from an offset 1, 2, 4, or 8 bytes after "
"the previous data item (depending on which function is used).  All locations "
"being read must lie within the bus space region specified by E<.Fa handle>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1263 /usr/src/share/man/man9/bus_space.9:1485
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data items being "
"read and the data array pointer should be properly aligned.  On some "
"systems, not obeying these requirements may cause incorrect data to be read, "
"on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1276
msgid ""
"Read operations done by the E<.Fn bus_space_read_region_N> functions may be "
"executed in any order.  They may also be executed out of order with respect "
"to other pending read and write operations unless order is enforced by use "
"of the E<.Fn bus_space_barrier> function.  There is no way to insert "
"barriers between reads of individual bus space locations executed by the "
"E<.Fn bus_space_read_region_N> functions."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1282
#, no-wrap
msgid "Fn bus_space_write_region_1 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1283
#, no-wrap
msgid "Fn bus_space_write_region_2 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1284
#, no-wrap
msgid "Fn bus_space_write_region_4 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1285
#, no-wrap
msgid "Fn bus_space_write_region_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1306
msgid ""
"The E<.Fn bus_space_write_region_N> family of functions reads E<.Fa count> "
"1, 2, 4, or 8 byte data items from the array specified by E<.Fa datap> and "
"writes them to bus space starting at byte offset E<.Fa offset> in the region "
"specified by E<.Fa handle> of the bus space specified by E<.Fa space>.  Each "
"successive data item is written to an offset 1, 2, 4, or 8 bytes after the "
"previous data item (depending on which function is used).  All locations "
"being written must lie within the bus space region specified by E<.Fa "
"handle>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1314 /usr/src/share/man/man9/bus_space.9:1534 /usr/src/share/man/man9/bus_space.9:1579
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data items being "
"written and the data array pointer should be properly aligned.  On some "
"systems, not obeying these requirements may cause incorrect data to be "
"written, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1328
msgid ""
"Write operations done by the E<.Fn bus_space_write_region_N> functions may "
"be executed in any order.  They may also be executed out of order with "
"respect to other pending read and write operations unless order is enforced "
"by use of the E<.Fn bus_space_barrier> function.  There is no way to insert "
"barriers between writes of individual bus space locations executed by the "
"E<.Fn bus_space_write_region_N> functions."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1334
#, no-wrap
msgid ""
"Fn bus_space_copy_region_1 space srchandle srcoffset dsthandle dstoffset "
"count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1336
#, no-wrap
msgid ""
"Fn bus_space_copy_region_2 space srchandle srcoffset dsthandle dstoffset "
"count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1338
#, no-wrap
msgid ""
"Fn bus_space_copy_region_4 space srchandle srcoffset dsthandle dstoffset "
"count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1340
#, no-wrap
msgid ""
"Fn bus_space_copy_region_8 space srchandle srcoffset dsthandle dstoffset "
"count"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1363
msgid ""
"The E<.Fn bus_space_copy_region_N> family of functions copies E<.Fa count> "
"1, 2, 4, or 8 byte data items in bus space from the area starting at byte "
"offset E<.Fa srcoffset> in the region specified by E<.Fa srchandle> of the "
"bus space specified by E<.Fa space> to the area starting at byte offset "
"E<.Fa dstoffset> in the region specified by E<.Fa dsthandle> in the same bus "
"space.  Each successive data item read or written has an offset 1, 2, 4, or "
"8 bytes after the previous data item (depending on which function is used).  "
"All locations being read and written must lie within the bus space region "
"specified by their respective handles."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1370
msgid ""
"For portability, the starting addresses of the regions specified by the each "
"handle plus its respective offset should be a multiple of the size of data "
"items being copied.  On some systems, not obeying this requirement may cause "
"incorrect data to be copied, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1383
msgid ""
"Read and write operations done by the E<.Fn bus_space_copy_region_N> "
"functions may be executed in any order.  They may also be executed out of "
"order with respect to other pending read and write operations unless order "
"is enforced by use of the E<.Fn bus_space_barrier> function.  There is no "
"way to insert barriers between reads or writes of individual bus space "
"locations executed by the E<.Fn bus_space_copy_region_N> functions."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1388
msgid ""
"Overlapping copies between different subregions of a single region of bus "
"space are handled correctly by the E<.Fn bus_space_copy_region_N> functions."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1394
#, no-wrap
msgid "Fn bus_space_set_region_1 space handle offset value count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1395
#, no-wrap
msgid "Fn bus_space_set_region_2 space handle offset value count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1396
#, no-wrap
msgid "Fn bus_space_set_region_4 space handle offset value count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1397
#, no-wrap
msgid "Fn bus_space_set_region_8 space handle offset value count"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1417
msgid ""
"The E<.Fn bus_space_set_region_N> family of functions writes the given E<.Fa "
"value> to E<.Fa count> 1, 2, 4, or 8 byte data items in bus space starting "
"at byte offset E<.Fa offset> in the region specified by E<.Fa handle> of the "
"bus space specified by E<.Fa space>.  Each successive data item has an "
"offset 1, 2, 4, or 8 bytes after the previous data item (depending on which "
"function is used).  All locations being written must lie within the bus "
"space region specified by E<.Fa handle>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1424
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data items being "
"written.  On some systems, not obeying this requirement may cause incorrect "
"data to be written, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1438
msgid ""
"Write operations done by the E<.Fn bus_space_set_region_N> functions may be "
"executed in any order.  They may also be executed out of order with respect "
"to other pending read and write operations unless order is enforced by use "
"of the E<.Fn bus_space_barrier> function.  There is no way to insert "
"barriers between writes of individual bus space locations executed by the "
"E<.Fn bus_space_set_region_N> functions."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1444
#, no-wrap
msgid "READING AND WRITING A SINGLE LOCATION MULTIPLE TIMES"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1455
msgid ""
"Some devices implement single locations in bus space which are to be read or "
"written multiple times to communicate data, e.g.\\& some ethernet devices' "
"packet buffer FIFOs.  In order to allow drivers to manipulate these types of "
"devices as efficiently as possible, the E<.Fn bus_space_read_multi_N>, E<.Fn "
"bus_space_set_multi_N>, and E<.Fn bus_space_write_multi_N> families of "
"functions are provided."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1455
#, no-wrap
msgid "Fn bus_space_read_multi_1 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1456
#, no-wrap
msgid "Fn bus_space_read_multi_2 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1457
#, no-wrap
msgid "Fn bus_space_read_multi_4 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1458
#, no-wrap
msgid "Fn bus_space_read_multi_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1477
msgid ""
"The E<.Fn bus_space_read_multi_N> family of functions reads E<.Fa count> 1, "
"2, 4, or 8 byte data items from bus space at byte offset E<.Fa offset> in "
"the region specified by E<.Fa handle> of the bus space specified by E<.Fa "
"space> and writes them into the array specified by E<.Fa datap>.  Each "
"successive data item is read from the same location in bus space.  The "
"location being read must lie within the bus space region specified by E<.Fa "
"handle>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1498
msgid ""
"Read operations done by the E<.Fn bus_space_read_multi_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function.  Because the E<.Fn bus_space_read_multi_N> functions read the same "
"bus space location multiple times, they place an implicit read barrier "
"between each successive read of that bus space location."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1504
#, no-wrap
msgid "Fn bus_space_write_multi_1 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1505
#, no-wrap
msgid "Fn bus_space_write_multi_2 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1506
#, no-wrap
msgid "Fn bus_space_write_multi_4 space handle offset datap count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1507
#, no-wrap
msgid "Fn bus_space_write_multi_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1526
msgid ""
"The E<.Fn bus_space_write_multi_N> family of functions reads E<.Fa count> 1, "
"2, 4, or 8 byte data items from the array specified by E<.Fa datap> and "
"writes them into bus space at byte offset E<.Fa offset> in the region "
"specified by E<.Fa handle> of the bus space specified by E<.Fa space>.  Each "
"successive data item is written to the same location in bus space.  The "
"location being written must lie within the bus space region specified by "
"E<.Fa handle>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1546
msgid ""
"Write operations done by the E<.Fn bus_space_write_multi_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function.  Because the E<.Fn bus_space_write_multi_N> functions write the "
"same bus space location multiple times, they place an implicit write barrier "
"between each successive write of that bus space location."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1552
#, no-wrap
msgid "Fn bus_space_set_multi_1 space handle offset value count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1553
#, no-wrap
msgid "Fn bus_space_set_multi_2 space handle offset value count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1554
#, no-wrap
msgid "Fn bus_space_set_multi_4 space handle offset value count"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man9/bus_space.9:1555
#, no-wrap
msgid "Fn bus_space_set_multi_8 space handle offset value count"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1571
msgid ""
"The E<.Fn bus_space_set_multi_N> writes E<.Fa value> into bus space at byte "
"offset E<.Fa offset> in the region specified by E<.Fa handle> of the bus "
"space specified by E<.Fa space>, E<.Fa count> times.  The location being "
"written must lie within the bus space region specified by E<.Fa handle>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1591
msgid ""
"Write operations done by the E<.Fn bus_space_set_multi_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function.  Because the E<.Fn bus_space_set_multi_N> functions write the same "
"bus space location multiple times, they place an implicit write barrier "
"between each successive write of that bus space location."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1597
#, no-wrap
msgid "STREAM FUNCTIONS"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1607
msgid ""
"Most of the E<.Nm> functions imply a host byte-order and a bus byte-order "
"and take care of any translation for the caller.  In some cases, however, "
"hardware may map a FIFO or some other memory region for which the caller may "
"want to use multi-word, yet untranslated access.  Access to these types of "
"memory regions should be with the E<.Fn bus_space_*_stream_N> functions."
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1609
#, no-wrap
msgid "Fn bus_space_read_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1610
#, no-wrap
msgid "Fn bus_space_read_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1611
#, no-wrap
msgid "Fn bus_space_read_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1612
#, no-wrap
msgid "Fn bus_space_read_stream_8"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1613
#, no-wrap
msgid "Fn bus_space_read_multi_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1614
#, no-wrap
msgid "Fn bus_space_read_multi_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1615
#, no-wrap
msgid "Fn bus_space_read_multi_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1616
#, no-wrap
msgid "Fn bus_space_read_multi_stream_8"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1617
#, no-wrap
msgid "Fn bus_space_read_region_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1618
#, no-wrap
msgid "Fn bus_space_read_region_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1619
#, no-wrap
msgid "Fn bus_space_read_region_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1620
#, no-wrap
msgid "Fn bus_space_read_region_stream_8"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1621
#, no-wrap
msgid "Fn bus_space_write_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1622
#, no-wrap
msgid "Fn bus_space_write_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1623
#, no-wrap
msgid "Fn bus_space_write_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1624
#, no-wrap
msgid "Fn bus_space_write_stream_8"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1625
#, no-wrap
msgid "Fn bus_space_write_multi_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1626
#, no-wrap
msgid "Fn bus_space_write_multi_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1627
#, no-wrap
msgid "Fn bus_space_write_multi_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1628
#, no-wrap
msgid "Fn bus_space_write_multi_stream_8"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1629
#, no-wrap
msgid "Fn bus_space_write_region_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1630
#, no-wrap
msgid "Fn bus_space_write_region_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1631
#, no-wrap
msgid "Fn bus_space_write_region_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1632
#, no-wrap
msgid "Fn bus_space_write_region_stream_8"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1633
#, no-wrap
msgid "Fn bus_space_copy_region_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1634
#, no-wrap
msgid "Fn bus_space_copy_region_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1635
#, no-wrap
msgid "Fn bus_space_copy_region_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1636
#, no-wrap
msgid "Fn bus_space_copy_region_stream_8"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1637
#, no-wrap
msgid "Fn bus_space_set_multi_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1638
#, no-wrap
msgid "Fn bus_space_set_multi_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1639
#, no-wrap
msgid "Fn bus_space_set_multi_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1640
#, no-wrap
msgid "Fn bus_space_set_multi_stream_8"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1641
#, no-wrap
msgid "Fn bus_space_set_region_stream_1"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1642
#, no-wrap
msgid "Fn bus_space_set_region_stream_2"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1643
#, no-wrap
msgid "Fn bus_space_set_region_stream_4"
msgstr ""

#. type: It
#: /usr/src/share/man/man9/bus_space.9:1644
#, no-wrap
msgid "Fn bus_space_set_region_stream_8"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1649
msgid ""
"These functions are defined just as their non-stream counterparts, except "
"that they provide no byte-order translation."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1649
#, no-wrap
msgid "COMPATIBILITY"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1660
msgid ""
"The current E<.Nx> version of the E<.Nm> interface specification differs "
"slightly from the original specification that came into wide use and E<.Fx> "
"adopted.  A few of the function names and arguments have changed for "
"consistency and increased functionality."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1660
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1662
msgid "E<.Xr bus_dma 9>"
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1662
#, no-wrap
msgid "HISTORY"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1677
msgid ""
"The E<.Nm> functions were introduced in a different form (memory and I/O "
"spaces were accessed via different sets of functions) in E<.Nx 1.2>.  The "
"functions were merged to work on generic E<.Dq spaces> early in the E<.Nx "
"1.3> development cycle, and many drivers were converted to use them.  This "
"document was written later during the E<.Nx 1.3> development cycle, and the "
"specification was updated to fix some consistency problems and to add some "
"missing functionality."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1686
msgid ""
"The manual page was then adapted to the version of the interface that E<.Fx> "
"imported for the CAM SCSI drivers, plus subsequent evolution.  The E<.Fx> "
"E<.Nm> version was imported in E<.Fx 3.0>."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1686
#, no-wrap
msgid "AUTHORS"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1702
msgid ""
"E<.An -nosplit> The E<.Nm> interfaces were designed and implemented by the "
"E<.Nx> developer community.  Primary contributors and implementors were "
"E<.An Chris Demetriou>, E<.An Jason Thorpe>, and E<.An Charles Hannum>, but "
"the rest of the E<.Nx> developers and the user community played a "
"significant role in development."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1706
msgid "E<.An Justin Gibbs> ported these interfaces to E<.Fx>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1709
msgid "E<.An Chris Demetriou> wrote this manual page."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1714
msgid "E<.An Warner Losh> modified it for the E<.Fx> implementation."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man9/bus_space.9:1714
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man9/bus_space.9:1716
msgid ""
"This manual may not completely and accurately document the interface, and "
"many parts of the interface are unspecified."
msgstr ""
