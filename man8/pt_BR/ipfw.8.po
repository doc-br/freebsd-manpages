# Edson Brandi <ebrandi@FreeBSD.org>, 2019. #zanata
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-05-18 14:29-0300\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"PO-Revision-Date: 2019-05-25 02:42+0000\n"
"Last-Translator: Edson Brandi <ebrandi@FreeBSD.org>\n"
"Language-Team: Portuguese (Brazil)\n"
"Language: pt_BR\n"
"X-Generator: Zanata 4.6.2\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"

#. type: Dd
#: /usr/src/sbin/ipfw/ipfw.8:4
#, no-wrap
msgid "April 21, 2019"
msgstr "21 de Abril de 2019"

#. type: Dt
#: /usr/src/sbin/ipfw/ipfw.8:5
#, no-wrap
msgid "IPFW 8"
msgstr "IPFW 8"

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:7
#, no-wrap
msgid "NAME"
msgstr "NOME"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:9
msgid "E<.Nm ipfw>"
msgstr "E<.Nm ipfw>"

#. type: Nd
#: /usr/src/sbin/ipfw/ipfw.8:9
#, no-wrap
msgid "User interface for firewall, traffic shaper, packet scheduler,"
msgstr ""
"Interface de usuário para firewall, traffic shaper, agendador de pacotes,"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:11
msgid "in-kernel NAT."
msgstr "NAT no kernel."

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:11
#, no-wrap
msgid "SYNOPSIS"
msgstr "SINOPSE"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:12
#, no-wrap
msgid "FIREWALL CONFIGURATION"
msgstr "CONFIGURAÇÃO DE FIREWALL"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:31
msgid ""
"E<.Nm> E<.Op Fl cq> E<.Cm add> E<.Ar rule> E<.Nm> E<.Op Fl acdefnNStT> E<.Op "
"Cm set Ar N> E<.Brq Cm list | show> E<.Op Ar rule | first-last ...> E<.Nm> "
"E<.Op Fl f | q> E<.Op Cm set Ar N> E<.Cm flush> E<.Nm> E<.Op Fl q> E<.Op Cm "
"set Ar N> E<.Brq Cm delete | zero | resetlog> E<.Op Ar number ...>"
msgstr ""
"E<.Nm> E<.Op Fl cq> E<.Cm add> E<.Ar rule> E<.Nm> E<.Op Fl acdefnNStT> E<.Op "
"Cm set Ar N> E<.Brq Cm list | show> E<.Op Ar rule | first-last ...> E<.Nm> "
"E<.Op Fl f | q> E<.Op Cm set Ar N> E<.Cm flush> E<.Nm> E<.Op Fl q> E<.Op Cm "
"set Ar N> E<.Brq Cm delete | zero | resetlog> E<.Op Ar number ...>"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:42
msgid ""
"E<.Nm> E<.Cm set Oo Cm disable Ar number ... Oc Op Cm enable Ar number ...> "
"E<.Nm> E<.Cm set move> E<.Op Cm rule> E<.Ar number Cm to Ar number> E<.Nm> "
"E<.Cm set swap Ar number number> E<.Nm> E<.Cm set show>"
msgstr ""
"E<.Nm> E<.Cm set Oo Cm disable Ar number ... Oc Op Cm enable Ar number ...> "
"E<.Nm> E<.Cm set move> E<.Op Cm rule> E<.Ar number Cm to Ar number> E<.Nm> "
"E<.Cm set swap Ar number number> E<.Nm> E<.Cm set show>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:42
#, no-wrap
msgid "SYSCTL SHORTCUTS"
msgstr "ATALHOS DO SYSCTL"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:49
msgid ""
"E<.Nm> E<.Cm enable> E<.Brq Cm firewall | altq | one_pass | debug | verbose "
"| dyn_keepalive> E<.Nm> E<.Cm disable> E<.Brq Cm firewall | altq | one_pass "
"| debug | verbose | dyn_keepalive>"
msgstr ""
"E<.Nm> E<.Cm enable> E<.Brq Cm firewall | altq | one_pass | debug | verbose "
"| dyn_keepalive> E<.Nm> E<.Cm disable> E<.Brq Cm firewall | altq | one_pass "
"| debug | verbose | dyn_keepalive>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:49 /usr/src/sbin/ipfw/ipfw.8:2080 /usr/src/sbin/ipfw/ipfw.8:4386
#, no-wrap
msgid "LOOKUP TABLES"
msgstr "TABELAS DE LOOKUP"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:90
msgid ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm create Ar create-options> E<."
"Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar name | all> E<.Cm destroy> E<."
"Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm modify Ar modify-options> E<."
"Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm swap Ar name> E<.Nm> E<.Oo Cm "
"set Ar N Oc Cm table Ar name Cm add Ar table-key Op Ar value> E<.Nm> E<.Oo "
"Cm set Ar N Oc Cm table Ar name Cm add Op Ar table-key Ar value ...> E<.Nm> "
"E<.Oo Cm set Ar N Oc Cm table Ar name Cm atomic add Op Ar table-key Ar value "
"...> E<.Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm delete Op Ar table-key ."
"..> E<.Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm lookup Ar addr> E<.Nm> "
"E<.Oo Cm set Ar N Oc Cm table Ar name Cm lock> E<.Nm> E<.Oo Cm set Ar N Oc "
"Cm table Ar name Cm unlock> E<.Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar "
"name | all> E<.Cm list> E<.Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar name "
"| all> E<.Cm info> E<.Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar name | "
"all> E<.Cm detail> E<.Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar name | "
"all> E<.Cm flush>"
msgstr ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm create Ar create-options> E<."
"Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar name | all> E<.Cm destroy> E<."
"Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm modify Ar modify-options> E<."
"Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm swap Ar name> E<.Nm> E<.Oo Cm "
"set Ar N Oc Cm table Ar name Cm add Ar table-key Op Ar value> E<.Nm> E<.Oo "
"Cm set Ar N Oc Cm table Ar name Cm add Op Ar table-key Ar value ...> E<.Nm> "
"E<.Oo Cm set Ar N Oc Cm table Ar name Cm atomic add Op Ar table-key Ar value "
"...> E<.Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm delete Op Ar table-key ."
"..> E<.Nm> E<.Oo Cm set Ar N Oc Cm table Ar name Cm lookup Ar addr> E<.Nm> "
"E<.Oo Cm set Ar N Oc Cm table Ar name Cm lock> E<.Nm> E<.Oo Cm set Ar N Oc "
"Cm table Ar name Cm unlock> E<.Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar "
"name | all> E<.Cm list> E<.Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar name "
"| all> E<.Cm info> E<.Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar name | "
"all> E<.Cm detail> E<.Nm> E<.Oo Cm set Ar N Oc Cm table> E<.Brq Ar name | "
"all> E<.Cm flush>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:90
#, no-wrap
msgid "DUMMYNET CONFIGURATION (TRAFFIC SHAPER AND PACKET SCHEDULER)"
msgstr "CONFIGURAÇÃO DO DUMMYNET (TRAFFIC SHAPER E AGENDADOR DE PACOTES)"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:101
msgid ""
"E<.Nm> E<.Brq Cm pipe | queue | sched> E<.Ar number> E<.Cm config> E<.Ar "
"config-options> E<.Nm> E<.Op Fl s Op Ar field> E<.Brq Cm pipe | queue | "
"sched> E<.Brq Cm delete | list | show> E<.Op Ar number ...>"
msgstr ""
"E<.Nm> E<.Brq Cm pipe | queue | sched> E<.Ar number> E<.Cm config> E<.Ar "
"config-options> E<.Nm> E<.Op Fl s Op Ar field> E<.Brq Cm pipe | queue | "
"sched> E<.Brq Cm delete | list | show> E<.Op Ar number ...>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:101
#, no-wrap
msgid "IN-KERNEL NAT"
msgstr "NAT NO KERNEL"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:108
msgid ""
"E<.Nm> E<.Op Fl q> E<.Cm nat> E<.Ar number> E<.Cm config> E<.Ar config-"
"options>"
msgstr ""
"E<.Nm> E<.Op Fl q> E<.Cm nat> E<.Ar number> E<.Cm config> E<.Ar config-"
"options>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:108
#, no-wrap
msgid "STATEFUL IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION"
msgstr "ENDEREÇOS DE REDE IPv6/IPv4 STATEFUL E TRADUÇÃO DE PROTOCOLO DE REDE"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:124
msgid ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn Ar name Cm create Ar create-options> "
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn Ar name Cm config Ar config-options> "
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn> E<.Brq Ar name | all> E<.Brq Cm "
"list | show> E<.Op Cm states> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn> E<."
"Brq Ar name | all> E<.Cm destroy> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn Ar "
"name Cm stats Op Cm reset>"
msgstr ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn Ar name Cm create Ar create-options> "
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn Ar name Cm config Ar config-options> "
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn> E<.Brq Ar name | all> E<.Brq Cm "
"list | show> E<.Op Cm states> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn> E<."
"Brq Ar name | all> E<.Cm destroy> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64lsn Ar "
"name Cm stats Op Cm reset>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:124
#, no-wrap
msgid "STATELESS IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION"
msgstr "ENDEREÇOS DE REDE IPv6/IPv4 STATELESS E TRADUÇÃO DE PROTOCOLO DE REDE"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:139
msgid ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl Ar name Cm create Ar create-options> "
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl Ar name Cm config Ar config-options> "
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl> E<.Brq Ar name | all> E<.Brq Cm "
"list | show> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl> E<.Brq Ar name | all> "
"E<.Cm destroy> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl Ar name Cm stats Op "
"Cm reset>"
msgstr ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl Ar name Cm create Ar create-options> "
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl Ar name Cm config Ar config-options> "
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl> E<.Brq Ar name | all> E<.Brq Cm "
"list | show> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl> E<.Brq Ar name | all> "
"E<.Cm destroy> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64stl Ar name Cm stats Op "
"Cm reset>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:139
#, no-wrap
msgid "XLAT464 CLAT IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION"
msgstr ""
"ENDEREÇOS DE REDE IPv6/IPv4 XLAT464 CLAT E TRADUÇÃO DE PROTOCOLO DE REDE"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:154
msgid ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat Ar name Cm create Ar create-"
"options> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat Ar name Cm config Ar "
"config-options> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat> E<.Brq Ar name | "
"all> E<.Brq Cm list | show> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat> E<.Brq "
"Ar name | all> E<.Cm destroy> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat Ar "
"name Cm stats Op Cm reset>"
msgstr ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat Ar name Cm create Ar create-"
"options> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat Ar name Cm config Ar "
"config-options> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat> E<.Brq Ar name | "
"all> E<.Brq Cm list | show> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat> E<.Brq "
"Ar name | all> E<.Cm destroy> E<.Nm> E<.Oo Cm set Ar N Oc Cm nat64clat Ar "
"name Cm stats Op Cm reset>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:154
#, no-wrap
msgid "IPv6-to-IPv6 NETWORK PREFIX TRANSLATION"
msgstr "TRADUÇÃO DE PREFIXO DE REDE IPv6-para-IPv6"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:167
msgid ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nptv6 Ar name Cm create Ar create-options> E<."
"Nm> E<.Oo Cm set Ar N Oc Cm nptv6> E<.Brq Ar name | all> E<.Brq Cm list | "
"show> E<.Nm> E<.Oo Cm set Ar N Oc Cm nptv6> E<.Brq Ar name | all> E<.Cm "
"destroy> E<.Nm> E<.Oo Cm set Ar N Oc Cm nptv6 Ar name Cm stats Op Cm reset>"
msgstr ""
"E<.Nm> E<.Oo Cm set Ar N Oc Cm nptv6 Ar name Cm create Ar create-options> E<."
"Nm> E<.Oo Cm set Ar N Oc Cm nptv6> E<.Brq Ar name | all> E<.Brq Cm list | "
"show> E<.Nm> E<.Oo Cm set Ar N Oc Cm nptv6> E<.Brq Ar name | all> E<.Cm "
"destroy> E<.Nm> E<.Oo Cm set Ar N Oc Cm nptv6 Ar name Cm stats Op Cm reset>"

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:167 /usr/src/sbin/ipfw/ipfw.8:4072
#, no-wrap
msgid "INTERNAL DIAGNOSTICS"
msgstr "DIAGNÓSTICOS INTERNOS"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:174
msgid ""
"E<.Nm> E<.Cm internal iflist> E<.Nm> E<.Cm internal talist> E<.Nm> E<.Cm "
"internal vlist>"
msgstr ""
"E<.Nm> E<.Cm internal iflist> E<.Nm> E<.Cm internal talist> E<.Nm> E<.Cm "
"internal vlist>"

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:174 /usr/src/sbin/ipfw/ipfw.8:397
#, no-wrap
msgid "LIST OF RULES AND PREPROCESSING"
msgstr "LISTA DE REGRAS E PRÉ-PROCESSAMENTO"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:184
msgid ""
"E<.Nm> E<.Op Fl cfnNqS> E<.Oo> E<.Fl p Ar preproc> E<.Oo> E<.Ar preproc-"
"flags> E<.Oc> E<.Oc> E<.Ar pathname>"
msgstr ""
"E<.Nm> E<.Op Fl cfnNqS> E<.Oo> E<.Fl p Ar preproc> E<.Oo> E<.Ar preproc-"
"flags> E<.Oc> E<.Oc> E<.Ar pathname>"

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:184
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIÇÃO"

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:193
msgid ""
"The E<.Nm> utility is the user interface for controlling the E<.Xr ipfw 4> "
"firewall, the E<.Xr dummynet 4> traffic shaper/packet scheduler, and the in-"
"kernel NAT services."
msgstr ""
"O utilitário E<.Nm> é a interface do usuário para controlar o firewall E<.Xr "
"ipfw 4>, o E<.Xr dummynet 4> traffic shaper/packet scheduler e os serviços "
"NAT no kernel."

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:212
msgid ""
"A firewall configuration, or E<.Em ruleset>, is made of a list of E<.Em "
"rules> numbered from 1 to 65535.  Packets are passed to the firewall from a "
"number of different places in the protocol stack (depending on the source "
"and destination of the packet, it is possible for the firewall to be invoked "
"multiple times on the same packet).  The packet passed to the firewall is "
"compared against each of the rules in the E<.Em ruleset>, in rule-number "
"order (multiple rules with the same number are permitted, in which case they "
"are processed in order of insertion).  When a match is found, the action "
"corresponding to the matching rule is performed."
msgstr ""
"Uma configuração de firewall, ou E<.Em ruleset>, é feita de uma lista de E<."
"Em rules> numeradas de 1 a 65535.  Os pacotes são passados para o firewall a "
"partir de vários locais diferentes na pilha de protocolos (dependendo da "
"origem e do destino do pacote, é possível que o firewall seja invocado "
"várias vezes no mesmo pacote).  O pacote passado para o firewall é comparado "
"com cada uma das regras no E<.Em ruleset>, em ordem de número de regras "
"(várias regras com o mesmo número são permitidas, caso em que são "
"processadas em ordem de inserção).  Quando uma correspondência é encontrada, "
"a ação correspondente à regra de correspondência é executada."

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:216
msgid ""
"Depending on the action and certain system settings, packets can be "
"reinjected into the firewall at some rule after the matching one for further "
"processing."
msgstr ""
"Dependendo da ação e de certas configurações do sistema, os pacotes podem "
"ser reinjetados no firewall em alguma regra após a regra correspondente para "
"processamento posterior."

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:228
msgid ""
"A ruleset always includes a E<.Em default> rule (numbered 65535) which "
"cannot be modified or deleted, and matches all packets.  The action "
"associated with the E<.Em default> rule can be either E<.Cm deny> or E<.Cm "
"allow> depending on how the kernel is configured."
msgstr ""
"Um conjunto de regras sempre inclui uma regra E<.Em default> (numerada de "
"65535) que não pode ser modificada ou excluída, e corresponde a todos os "
"pacotes.  A ação associada à regra E<.Em default> pode ser E<.Cm deny> ou E<."
"Cm allow>, dependendo de como o kernel está configurado."

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:269
msgid ""
"If the ruleset includes one or more rules with the E<.Cm keep-state>, E<.Cm "
"record-state>, E<.Cm limit> or E<.Cm set-limit> option, the firewall will "
"have a E<.Em stateful> behaviour, i.e., upon a match it will create E<.Em "
"dynamic rules>, i.e., rules that match packets with the same 5-tuple "
"(protocol, source and destination addresses and ports)  as the packet which "
"caused their creation.  Dynamic rules, which have a limited lifetime, are "
"checked at the first occurrence of a E<.Cm check-state>, E<.Cm keep-state> "
"or E<.Cm limit> rule, and are typically used to open the firewall on-demand "
"to legitimate traffic only.  Please note, that E<.Cm keep-state> and E<.Cm "
"limit> imply implicit E<.Cm check-state> for all packets (not only these "
"matched by the rule) but E<.Cm record-state> and E<.Cm set-limit> have no "
"implicit E<.Cm check-state>.  See the E<.Sx STATEFUL FIREWALL> and E<.Sx "
"EXAMPLES> Sections below for more information on the stateful behaviour of "
"E<.Nm>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:276
msgid ""
"All rules (including dynamic ones) have a few associated counters: a packet "
"count, a byte count, a log count and a timestamp indicating the time of the "
"last match.  Counters can be displayed or reset with E<.Nm> commands."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:290
msgid ""
"Each rule belongs to one of 32 different E<.Em sets> , and there are E<.Nm> "
"commands to atomically manipulate sets, such as enable, disable, swap sets, "
"move all rules in a set to another one, delete all rules in a set.  These "
"can be useful to install temporary configurations, or to test them.  See "
"Section E<.Sx SETS OF RULES> for more information on E<.Em sets>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:308
msgid ""
"Rules can be added with the E<.Cm add> command; deleted individually or in "
"groups with the E<.Cm delete> command, and globally (except those in set 31) "
"with the E<.Cm flush> command; displayed, optionally with the content of the "
"counters, using the E<.Cm show> and E<.Cm list> commands.  Finally, counters "
"can be reset with the E<.Cm zero> and E<.Cm resetlog> commands."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:309
#, no-wrap
msgid "COMMAND OPTIONS"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:312
msgid "The following general options are available when invoking E<.Nm>:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:313
#, no-wrap
msgid "Fl a"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:318
msgid ""
"Show counter values when listing rules.  The E<.Cm show> command implies "
"this option."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:318
#, no-wrap
msgid "Fl b"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:322
msgid ""
"Only show the action and the comment, not the body of a rule.  Implies E<.Fl "
"c>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:322
#, no-wrap
msgid "Fl c"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:326
msgid ""
"When entering or showing rules, print them in compact form, i.e., omitting "
"the \"ip from any to any\" string when this does not carry any additional "
"information."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:326
#, no-wrap
msgid "Fl d"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:328
msgid "When listing, show dynamic rules in addition to static ones."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:328
#, no-wrap
msgid "Fl D"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:331
msgid ""
"When listing, show only dynamic states.  When deleting, delete only dynamic "
"states."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:331
#, no-wrap
msgid "Fl f"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:341
msgid ""
"Run without prompting for confirmation for commands that can cause problems "
"if misused, i.e., E<.Cm flush>.  If there is no tty associated with the "
"process, this is implied.  The E<.Cm delete> command with this flag ignores "
"possible errors, i.e., nonexistent rule number.  And for batched commands "
"execution continues with the next command."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:341
#, no-wrap
msgid "Fl i"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:347
msgid ""
"When listing a table (see the E<.Sx LOOKUP TABLES> section below for more "
"information on lookup tables), format values as IP addresses.  By default, "
"values are shown as integers."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:347
#, no-wrap
msgid "Fl n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:350
msgid ""
"Only check syntax of the command strings, without actually passing them to "
"the kernel."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:350
#, no-wrap
msgid "Fl N"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:352
msgid "Try to resolve addresses and service names in output."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:352
#, no-wrap
msgid "Fl q"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:373
msgid ""
"Be quiet when executing the E<.Cm add>, E<.Cm nat>, E<.Cm zero>, E<.Cm "
"resetlog> or E<.Cm flush> commands; (implies E<.Fl f>).  This is useful when "
"updating rulesets by executing multiple E<.Nm> commands in a script (e.g., "
"E<.Ql sh\\ /etc/rc.firewall>), or by processing a file with many E<.Nm> "
"rules across a remote login session.  It also stops a table add or delete "
"from failing if the entry already exists or is not present."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:382
msgid ""
"The reason why this option may be important is that for some of these "
"actions, E<.Nm> may print a message; if the action results in blocking the "
"traffic to the remote client, the remote login session will be closed and "
"the rest of the ruleset will not be processed.  Access to the console would "
"then be required to recover."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:382
#, no-wrap
msgid "Fl S"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:388
msgid ""
"When listing rules, show the E<.Em set> each rule belongs to.  If this flag "
"is not specified, disabled rules will not be listed."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:388
#, no-wrap
msgid "Fl s Op Ar field"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:391
msgid ""
"When listing pipes, sort according to one of the four counters (total or "
"current packets or bytes)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:391
#, no-wrap
msgid "Fl t"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:393
msgid "When listing, show last match timestamp converted with ctime()."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:393
#, no-wrap
msgid "Fl T"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:396
msgid ""
"When listing, show last match timestamp as seconds from the epoch.  This "
"form can be more convenient for postprocessing by scripts."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:408
msgid ""
"To ease configuration, rules can be put into a file which is processed using "
"E<.Nm> as shown in the last synopsis line.  An absolute E<.Ar pathname> must "
"be used.  The file will be read line by line and applied as arguments to the "
"E<.Nm> utility."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:436
msgid ""
"Optionally, a preprocessor can be specified using E<.Fl p Ar preproc> where "
"E<.Ar pathname> is to be piped through.  Useful preprocessors include E<.Xr "
"cpp 1> and E<.Xr m4 1>.  If E<.Ar preproc> does not start with a slash E<.Pq "
"Ql /> as its first character, the usual E<.Ev PATH> name search is performed."
"  Care should be taken with this in environments where not all file systems "
"are mounted (yet) by the time E<.Nm> is being run (e.g.\\& when they are "
"mounted over NFS).  Once E<.Fl p> has been specified, any additional "
"arguments are passed on to the preprocessor for interpretation.  This allows "
"for flexible configuration files (like conditionalizing them on the local "
"hostname) and the use of macros to centralize frequently required arguments "
"like IP addresses."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:436
#, no-wrap
msgid "TRAFFIC SHAPER CONFIGURATION"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:446
msgid ""
"The E<.Nm> E<.Cm pipe , queue> and E<.Cm sched> commands are used to "
"configure the traffic shaper and packet scheduler.  See the E<.Sx TRAFFIC "
"SHAPER (DUMMYNET) CONFIGURATION> Section below for details."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:457
msgid ""
"If the world and the kernel get out of sync the E<.Nm> ABI may break, "
"preventing you from being able to add any rules.  This can adversely affect "
"the booting process.  You can use E<.Nm> E<.Cm disable> E<.Cm firewall> to "
"temporarily disable the firewall to regain access to the network, allowing "
"you to fix the problem."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:457
#, no-wrap
msgid "PACKET FLOW"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:462
msgid ""
"A packet is checked against the active ruleset in multiple places in the "
"protocol stack, under control of several sysctl variables.  These places and "
"variables are shown below, and it is important to have this picture in mind "
"in order to design a correct ruleset."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:475
#, no-wrap
msgid ""
"       ^    to upper layers    V\n"
"       |                       |\n"
"       +-----------E<gt>-----------+\n"
"       ^                       V\n"
" [ip(6)_input]           [ip(6)_output]     net.inet(6).ip(6).fw.enable=1\n"
"       |                       |\n"
"       ^                       V\n"
" [ether_demux]        [ether_output_frame]  net.link.ether.ipfw=1\n"
"       |                       |\n"
"       +--E<gt>--[bdg_forward]--E<gt>--+            net.link.bridge.ipfw=1\n"
"       ^                       V\n"
"       |      to devices       |\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:481
msgid ""
"The number of times the same packet goes through the firewall can vary "
"between 0 and 4 depending on packet source and destination, and system "
"configuration."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:495
msgid ""
"Note that as packets flow through the stack, headers can be stripped or "
"added to it, and so they may or may not be available for inspection.  E.g., "
"incoming packets will include the MAC header when E<.Nm> is invoked from E<."
"Cm ether_demux()>, but the same packets will have the MAC header stripped "
"off when E<.Nm> is invoked from E<.Cm ip_input()> or E<.Cm ip6_input()>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:515
msgid ""
"Also note that each packet is always checked against the complete ruleset, "
"irrespective of the place where the check occurs, or the source of the "
"packet.  If a rule contains some match patterns or actions which are not "
"valid for the place of invocation (e.g.\\& trying to match a MAC header "
"within E<.Cm ip_input> or E<.Cm ip6_input ),> the match pattern will not "
"match, but a E<.Cm not> operator in front of such patterns E<.Em will> cause "
"the pattern to E<.Em always> match on those packets.  It is thus the "
"responsibility of the programmer, if necessary, to write a suitable ruleset "
"to differentiate among the possible places.  E<.Cm skipto> rules can be "
"useful here, as an example:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:524
#, no-wrap
msgid ""
"# packets from ether_demux or bdg_forward\n"
"ipfw add 10 skipto 1000 all from any to any layer2 in\n"
"# packets from ip_input\n"
"ipfw add 10 skipto 2000 all from any to any not layer2 in\n"
"# packets from ip_output\n"
"ipfw add 10 skipto 3000 all from any to any not layer2 out\n"
"# packets from ether_output_frame\n"
"ipfw add 10 skipto 4000 all from any to any layer2 out\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:528
msgid ""
"(yes, at the moment there is no way to differentiate between ether_demux and "
"bdg_forward)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:549
msgid ""
"Also note that only actions E<.Cm allow,> E<.Cm deny,> E<.Cm netgraph,> E<."
"Cm ngtee> and related to E<.Cm dummynet> are processed for E<.Cm layer2> "
"frames and all other actions act as if they were E<.Cm allow> for such "
"frames.  Full set of actions is supported for IP packets without E<.Cm "
"layer2> headers only.  For example, E<.Cm divert> action does not divert E<."
"Cm layer2> frames."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:549
#, no-wrap
msgid "SYNTAX"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:556
msgid ""
"In general, each keyword or argument must be provided as a separate command "
"line argument, with no leading or trailing spaces.  Keywords are case-"
"sensitive, whereas arguments may or may not be case-sensitive depending on "
"their nature (e.g.\\& uid's are, hostnames are not)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:564
msgid ""
"Some arguments (e.g., port or address lists) are comma-separated lists of "
"values.  In this case, spaces after commas ',' are allowed to make the line "
"more readable.  You can also put the entire command (including flags) into a "
"single argument.  E.g., the following forms are equivalent:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:568
#, no-wrap
msgid ""
"ipfw -q add deny src-ip 10.0.0.0/24,127.0.0.1/8\n"
"ipfw -q add deny src-ip 10.0.0.0/24, 127.0.0.1/8\n"
"ipfw \"-q add deny src-ip 10.0.0.0/24, 127.0.0.1/8\"\n"
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:569
#, no-wrap
msgid "RULE FORMAT"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:571
msgid "The format of firewall rules is the following:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:585
#, no-wrap
msgid ""
"E<.Bk -words>\n"
"E<.Op Ar rule_number>\n"
"E<.Op Cm set Ar set_number>\n"
"E<.Op Cm prob Ar match_probability>\n"
"E<.Ar action>\n"
"E<.Op Cm log Op Cm logamount Ar number>\n"
"E<.Op Cm altq Ar queue>\n"
"E<.Oo>\n"
"E<.Bro Cm tag | untag>\n"
"E<.Brc Ar number>\n"
"E<.Oc>\n"
"E<.Ar body>\n"
"E<.Ek>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:589
msgid ""
"where the body of the rule specifies which information is used for filtering "
"packets, among the following:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:591
#, no-wrap
msgid "Layer-2 header fields"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:593
msgid "When available"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:593
#, no-wrap
msgid "IPv4 and IPv6 Protocol"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:595
msgid "SCTP, TCP, UDP, ICMP, etc."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:595
#, no-wrap
msgid "Source and dest. addresses and ports"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:596
#, no-wrap
msgid "Direction"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:599
msgid "See Section E<.Sx PACKET FLOW>"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:599
#, no-wrap
msgid "Transmit and receive interface"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:601
msgid "By name or address"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:601
#, no-wrap
msgid "Misc. IP header fields"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:605
msgid ""
"Version, type of service, datagram length, identification, fragment flag "
"(non-zero IP offset), Time To Live"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:605
#, no-wrap
msgid "IP options"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:606
#, no-wrap
msgid "IPv6 Extension headers"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:609
msgid ""
"Fragmentation, Hop-by-Hop options, Routing Headers, Source routing rthdr0, "
"Mobile IPv6 rthdr2, IPSec options."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:609
#, no-wrap
msgid "IPv6 Flow-ID"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:610
#, no-wrap
msgid "Misc. TCP header fields"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:614
msgid ""
"TCP flags (SYN, FIN, ACK, RST, etc.), sequence number, acknowledgment "
"number, window"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:614
#, no-wrap
msgid "TCP options"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:615
#, no-wrap
msgid "ICMP types"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:617
msgid "for ICMP packets"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:617
#, no-wrap
msgid "ICMP6 types"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:619
msgid "for ICMP6 packets"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:619
#, no-wrap
msgid "User/group ID"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:621
msgid "When the packet can be associated with a local socket."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:621
#, no-wrap
msgid "Divert status"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:624
msgid "Whether a packet came from a divert socket (e.g., E<.Xr natd 8>)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:624
#, no-wrap
msgid "Fib annotation state"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:627
msgid ""
"Whether a packet has been tagged for using a specific FIB (routing table)  "
"in future forwarding decisions."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:632
msgid ""
"Note that some of the above information, e.g.\\& source MAC or IP addresses "
"and TCP/UDP ports, can be easily spoofed, so filtering on those fields alone "
"might not guarantee the desired results."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:633
#, no-wrap
msgid "Ar rule_number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:655
msgid ""
"Each rule is associated with a E<.Ar rule_number> in the range 1..65535, "
"with the latter reserved for the E<.Em default> rule.  Rules are checked "
"sequentially by rule number.  Multiple rules can have the same number, in "
"which case they are checked (and listed) according to the order in which "
"they have been added.  If a rule is entered without specifying a number, the "
"kernel will assign one in such a way that the rule becomes the last one "
"before the E<.Em default> rule.  Automatic rule numbers are assigned by "
"incrementing the last non-default rule number by the value of the sysctl "
"variable E<.Ar net.inet.ip.fw.autoinc_step> which defaults to 100.  If this "
"is not possible (e.g.\\& because we would go beyond the maximum allowed rule "
"number), the number of the last non-default value is used instead."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:655
#, no-wrap
msgid "Cm set Ar set_number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:664
msgid ""
"Each rule is associated with a E<.Ar set_number> in the range 0..31.  Sets "
"can be individually disabled and enabled, so this parameter is of "
"fundamental importance for atomic ruleset manipulation.  It can be also used "
"to simplify deletion of groups of rules.  If a rule is entered without "
"specifying a set number, set 0 will be used."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:674
msgid ""
"Set 31 is special in that it cannot be disabled, and rules in set 31 are not "
"deleted by the E<.Nm ipfw flush> command (but you can delete them with the "
"E<.Nm ipfw delete set 31> command).  Set 31 is also used for the E<.Em "
"default> rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:674
#, no-wrap
msgid "Cm prob Ar match_probability"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:683
msgid ""
"A match is only declared with the specified probability (floating point "
"number between 0 and 1).  This can be useful for a number of applications "
"such as random packet drop or (in conjunction with E<.Nm dummynet>)  to "
"simulate the effect of multiple paths leading to out-of-order packet "
"delivery."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:691
msgid ""
"Note: this condition is checked before any other condition, including ones "
"such as E<.Cm keep-state> or E<.Cm check-state> which might have side "
"effects."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:691
#, no-wrap
msgid "Cm log Op Cm logamount Ar number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:704
msgid ""
"Packets matching a rule with the E<.Cm log> keyword will be made available "
"for logging in two ways: if the sysctl variable E<.Va net.inet.ip.fw."
"verbose> is set to 0 (default), one can use E<.Xr bpf 4> attached to the E<."
"Li ipfw0> pseudo interface.  This pseudo interface can be created manually "
"after a system boot by using the following command:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:706
#, no-wrap
msgid "# ifconfig ipfw0 create\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:712
msgid ""
"Or, automatically at boot time by adding the following line to the E<.Xr rc."
"conf 5> file:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:714
#, no-wrap
msgid "firewall_logif=\"YES\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:719
msgid ""
"There is zero overhead when no E<.Xr bpf 4> is attached to the pseudo "
"interface."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:734
msgid ""
"If E<.Va net.inet.ip.fw.verbose> is set to 1, packets will be logged to E<."
"Xr syslogd 8> with a E<.Dv LOG_SECURITY> facility up to a maximum of E<.Cm "
"logamount> packets.  If no E<.Cm logamount> is specified, the limit is taken "
"from the sysctl variable E<.Va net.inet.ip.fw.verbose_limit>.  In both "
"cases, a value of 0 means unlimited logging."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:739
msgid ""
"Once the limit is reached, logging can be re-enabled by clearing the logging "
"counter or the packet counter for that entry, see the E<.Cm resetlog> "
"command."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:743
msgid ""
"Note: logging is done after all other packet matching conditions have been "
"successfully verified, and before performing the final action (accept, deny, "
"etc.) on the packet."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:743
#, no-wrap
msgid "Cm tag Ar number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:761
msgid ""
"When a packet matches a rule with the E<.Cm tag> keyword, the numeric tag "
"for the given E<.Ar number> in the range 1..65534 will be attached to the "
"packet.  The tag acts as an internal marker (it is not sent out over the "
"wire) that can be used to identify these packets later on.  This can be "
"used, for example, to provide trust between interfaces and to start doing "
"policy-based filtering.  A packet can have multiple tags at the same time.  "
"Tags are \"sticky\", meaning once a tag is applied to a packet by a matching "
"rule it exists until explicit removal.  Tags are kept with the packet "
"everywhere within the kernel, but are lost when packet leaves the kernel, "
"for example, on transmitting packet out to the network or sending packet to "
"a E<.Xr divert 4> socket."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:768
msgid ""
"To check for previously applied tags, use the E<.Cm tagged> rule option.  To "
"delete previously applied tag, use the E<.Cm untag> keyword."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:783
msgid ""
"Note: since tags are kept with the packet everywhere in kernelspace, they "
"can be set and unset anywhere in the kernel network subsystem (using the E<."
"Xr mbuf_tags 9> facility), not only by means of the E<.Xr ipfw 4> E<.Cm tag> "
"and E<.Cm untag> keywords.  For example, there can be a specialized E<.Xr "
"netgraph 4> node doing traffic analyzing and tagging for later inspecting in "
"firewall."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:783
#, no-wrap
msgid "Cm untag Ar number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:791
msgid ""
"When a packet matches a rule with the E<.Cm untag> keyword, the tag with the "
"number E<.Ar number> is searched among the tags attached to this packet and, "
"if found, removed from it.  Other tags bound to packet, if present, are left "
"untouched."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:791
#, no-wrap
msgid "Cm altq Ar queue"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:818
msgid ""
"When a packet matches a rule with the E<.Cm altq> keyword, the ALTQ "
"identifier for the given E<.Ar queue> (see E<.Xr altq 4>)  will be attached. "
" Note that this ALTQ tag is only meaningful for packets going \"out\" of "
"IPFW, and not being rejected or going to divert sockets.  Note that if there "
"is insufficient memory at the time the packet is processed, it will not be "
"tagged, so it is wise to make your ALTQ \"default\" queue policy account for "
"this.  If multiple E<.Cm altq> rules match a single packet, only the first "
"one adds the ALTQ classification tag.  In doing so, traffic may be shaped by "
"using E<.Cm count Cm altq Ar queue> rules for classification early in the "
"ruleset, then later applying the filtering decision.  For example, E<.Cm "
"check-state> and E<.Cm keep-state> rules may come later and provide the "
"actual filtering decisions in addition to the fallback ALTQ tag."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:826
msgid ""
"You must run E<.Xr pfctl 8> to set up the queues before IPFW will be able to "
"look them up by name, and if the ALTQ disciplines are rearranged, the rules "
"in containing the queue identifiers in the kernel will likely have gone "
"stale and need to be reloaded.  Stale queue identifiers will probably result "
"in misclassification."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:837
msgid ""
"All system ALTQ processing can be turned on or off via E<.Nm> E<.Cm enable "
"Ar altq> and E<.Nm> E<.Cm disable Ar altq>.  The usage of E<.Va net.inet.ip."
"fw.one_pass> is irrelevant to ALTQ traffic shaping, as the actual rule "
"action is followed always after adding an ALTQ tag."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:838
#, no-wrap
msgid "RULE ACTIONS"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:841
msgid ""
"A rule can be associated with one of the following actions, which will be "
"executed when the packet matches the body of the rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:842
#, no-wrap
msgid "Cm allow | accept | pass | permit"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:845
msgid "Allow packets that match rule.  The search terminates."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:845
#, no-wrap
msgid "Cm check-state Op Ar :flowname | Cm :any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:850
msgid ""
"Checks the packet against the dynamic ruleset.  If a match is found, execute "
"the action associated with the rule which generated this dynamic rule, "
"otherwise move to the next rule."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:871
msgid ""
"E<.Cm Check-state> rules do not have a body.  If no E<.Cm check-state> rule "
"is found, the dynamic ruleset is checked at the first E<.Cm keep-state> or "
"E<.Cm limit> rule.  The E<.Ar :flowname> is symbolic name assigned to "
"dynamic rule by E<.Cm keep-state> opcode.  The special flowname E<.Cm :any> "
"can be used to ignore states flowname when matching.  The E<.Cm :default> "
"keyword is special name used for compatibility with old rulesets."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:871
#, no-wrap
msgid "Cm count"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:874
msgid ""
"Update counters for all packets that match rule.  The search continues with "
"the next rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:874
#, no-wrap
msgid "Cm deny | drop"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:877
msgid "Discard packets that match this rule.  The search terminates."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:877
#, no-wrap
msgid "Cm divert Ar port"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:883
msgid ""
"Divert packets that match this rule to the E<.Xr divert 4> socket bound to "
"port E<.Ar port>.  The search terminates."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:883
#, no-wrap
msgid "Cm fwd | forward Ar ipaddr | tablearg Ns Op , Ns Ar port"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:892
msgid ""
"Change the next-hop on matching packets to E<.Ar ipaddr>, which can be an IP "
"address or a host name.  The next hop can also be supplied by the last table "
"looked up for the packet by using the E<.Cm tablearg> keyword instead of an "
"explicit address.  The search terminates if this rule matches."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:899
msgid ""
"If E<.Ar ipaddr> is a local address, then matching packets will be forwarded "
"to E<.Ar port> (or the port number in the packet if one is not specified in "
"the rule)  on the local machine."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:906
msgid ""
"If E<.Ar ipaddr> is not a local address, then the port number (if specified) "
"is ignored, and the packet will be forwarded to the remote address, using "
"the route as found in the local routing table for that IP."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:911
msgid ""
"A E<.Ar fwd> rule will not match layer-2 packets (those received on "
"ether_input, ether_output, or bridged)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:925
msgid ""
"The E<.Cm fwd> action does not change the contents of the packet at all.  In "
"particular, the destination address remains unmodified, so packets forwarded "
"to another system will usually be rejected by that system unless there is a "
"matching rule on that system to capture them.  For packets forwarded "
"locally, the local address of the socket will be set to the original "
"destination address of the packet.  This makes the E<.Xr netstat 1> entry "
"look rather weird but is intended for use with transparent proxy servers."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:925
#, no-wrap
msgid "Cm nat Ar nat_nr | tablearg"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:932
msgid ""
"Pass packet to a nat instance (for network address translation, address "
"redirect, etc.): see the E<.Sx NETWORK ADDRESS TRANSLATION (NAT)> Section "
"for further information."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:932
#, no-wrap
msgid "Cm nat64lsn Ar name"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:937
msgid ""
"Pass packet to a stateful NAT64 instance (for IPv6/IPv4 network address and "
"protocol translation): see the E<.Sx IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL "
"TRANSLATION> Section for further information."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:937
#, no-wrap
msgid "Cm nat64stl Ar name"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:942
msgid ""
"Pass packet to a stateless NAT64 instance (for IPv6/IPv4 network address and "
"protocol translation): see the E<.Sx IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL "
"TRANSLATION> Section for further information."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:942
#, no-wrap
msgid "Cm nat64clat Ar name"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:947
msgid ""
"Pass packet to a CLAT NAT64 instance (for client-side IPv6/IPv4 network "
"address and protocol translation): see the E<.Sx IPv6/IPv4 NETWORK ADDRESS "
"AND PROTOCOL TRANSLATION> Section for further information."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:947
#, no-wrap
msgid "Cm nptv6 Ar name"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:952
msgid ""
"Pass packet to a NPTv6 instance (for IPv6-to-IPv6 network prefix "
"translation): see the E<.Sx IPv6-to-IPv6 NETWORK PREFIX TRANSLATION (NPTv6)> "
"Section for further information."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:952 /usr/src/sbin/ipfw/ipfw.8:2740
#, no-wrap
msgid "Cm pipe Ar pipe_nr"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:967
msgid ""
"Pass packet to a E<.Nm dummynet> E<.Dq pipe> (for bandwidth limitation, "
"delay, etc.).  See the E<.Sx TRAFFIC SHAPER (DUMMYNET) CONFIGURATION> "
"Section for further information.  The search terminates; however, on exit "
"from the pipe and if the E<.Xr sysctl 8> variable E<.Va net.inet.ip.fw."
"one_pass> is not set, the packet is passed again to the firewall code "
"starting from the next rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:967
#, no-wrap
msgid "Cm queue Ar queue_nr"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:972
msgid ""
"Pass packet to a E<.Nm dummynet> E<.Dq queue> (for bandwidth limitation "
"using WF2Q+)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:972
#, no-wrap
msgid "Cm reject"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:976
msgid "(Deprecated).  Synonym for E<.Cm unreach host>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:976 /usr/src/sbin/ipfw/ipfw.8:3225
#, no-wrap
msgid "Cm reset"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:980 /usr/src/sbin/ipfw/ipfw.8:984
msgid ""
"Discard packets that match this rule, and if the packet is a TCP packet, try "
"to send a TCP reset (RST) notice.  The search terminates."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:980
#, no-wrap
msgid "Cm reset6"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:984
#, no-wrap
msgid "Cm skipto Ar number | tablearg"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:999
msgid ""
"Skip all subsequent rules numbered less than E<.Ar number>.  The search "
"continues with the first rule numbered E<.Ar number> or higher.  It is "
"possible to use the E<.Cm tablearg> keyword with a skipto for a E<.Em "
"computed> skipto. Skipto may work either in O(log(N)) or in O(1) depending "
"on amount of memory and/or sysctl variables.  See the E<.Sx SYSCTL "
"VARIABLES> section for more details."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:999
#, no-wrap
msgid "Cm call Ar number | tablearg"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1018
msgid ""
"The current rule number is saved in the internal stack and ruleset "
"processing continues with the first rule numbered E<.Ar number> or higher.  "
"If later a rule with the E<.Cm return> action is encountered, the processing "
"returns to the first rule with number of this E<.Cm call> rule plus one or "
"higher (the same behaviour as with packets returning from E<.Xr divert 4> "
"socket after a E<.Cm divert> action).  This could be used to make somewhat "
"like an assembly language E<.Dq subroutine> calls to rules with common "
"checks for different interfaces, etc."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1027
msgid ""
"Rule with any number could be called, not just forward jumps as with E<.Cm "
"skipto>.  So, to prevent endless loops in case of mistakes, both E<.Cm call> "
"and E<.Cm return> actions don't do any jumps and simply go to the next rule "
"if memory cannot be allocated or stack overflowed/underflowed."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1035
msgid ""
"Internally stack for rule numbers is implemented using E<.Xr mbuf_tags 9> "
"facility and currently has size of 16 entries.  As mbuf tags are lost when "
"packet leaves the kernel, E<.Cm divert> should not be used in subroutines to "
"avoid endless loops and other undesired effects."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1035
#, no-wrap
msgid "Cm return"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1045
msgid ""
"Takes rule number saved to internal stack by the last E<.Cm call> action and "
"returns ruleset processing to the first rule with number greater than number "
"of corresponding E<.Cm call> rule.  See description of the E<.Cm call> "
"action for more details."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1062
msgid ""
"Note that E<.Cm return> rules usually end a E<.Dq subroutine> and thus are "
"unconditional, but E<.Nm> command-line utility currently requires every "
"action except E<.Cm check-state> to have body.  While it is sometimes useful "
"to return only on some packets, usually you want to print just E<.Dq return> "
"for readability.  A workaround for this is to use new syntax and E<.Fl c> "
"switch:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1065
#, no-wrap
msgid "# Add a rule without actual body\n"
"ipfw add 2999 return via any\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1068
#, no-wrap
msgid "# List rules without \"from any to any\" part\n"
"ipfw -c list\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1071
msgid "This cosmetic annoyance may be fixed in future releases."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1071
#, no-wrap
msgid "Cm tee Ar port"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1077
msgid ""
"Send a copy of packets matching this rule to the E<.Xr divert 4> socket "
"bound to port E<.Ar port>.  The search continues with the next rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1077
#, no-wrap
msgid "Cm unreach Ar code"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1091
msgid ""
"Discard packets that match this rule, and try to send an ICMP unreachable "
"notice with code E<.Ar code>, where E<.Ar code> is a number from 0 to 255, "
"or one of these aliases: E<.Cm net , host , protocol , port>, E<.Cm needfrag "
", srcfail , net-unknown , host-unknown>, E<.Cm isolated , net-prohib , host-"
"prohib , tosnet>, E<.Cm toshost , filter-prohib , host-precedence> or E<.Cm "
"precedence-cutoff>.  The search terminates."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1091
#, no-wrap
msgid "Cm unreach6 Ar code"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1102
msgid ""
"Discard packets that match this rule, and try to send an ICMPv6 unreachable "
"notice with code E<.Ar code>, where E<.Ar code> is a number from 0, 1, 3 or "
"4, or one of these aliases: E<.Cm no-route, admin-prohib, address> or E<.Cm "
"port>.  The search terminates."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1102
#, no-wrap
msgid "Cm netgraph Ar cookie"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1110
msgid ""
"Divert packet into netgraph with given E<.Ar cookie>.  The search terminates."
"  If packet is later returned from netgraph it is either accepted or "
"continues with the next rule, depending on E<.Va net.inet.ip.fw.one_pass> "
"sysctl variable."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1110
#, no-wrap
msgid "Cm ngtee Ar cookie"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1120
msgid ""
"A copy of packet is diverted into netgraph, original packet continues with "
"the next rule.  See E<.Xr ng_ipfw 4> for more information on E<.Cm netgraph> "
"and E<.Cm ngtee> actions."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1120
#, no-wrap
msgid "Cm setfib Ar fibnum | tablearg"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1132
msgid ""
"The packet is tagged so as to use the FIB (routing table)  E<.Ar fibnum> in "
"any subsequent forwarding decisions.  In the current implementation, this is "
"limited to the values 0 through 15, see E<.Xr setfib 2>.  Processing "
"continues at the next rule.  It is possible to use the E<.Cm tablearg> "
"keyword with setfib.  If the tablearg value is not within the compiled range "
"of fibs, the packet's fib is set to 0."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1132
#, no-wrap
msgid "Cm setdscp Ar DSCP | number | tablearg"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1136
msgid ""
"Set specified DiffServ codepoint for an IPv4/IPv6 packet.  Processing "
"continues at the next rule.  Supported values are:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1187
msgid ""
"E<.Cm cs0> E<.Pq Dv 000000>, E<.Cm cs1> E<.Pq Dv 001000>, E<.Cm cs2> E<.Pq "
"Dv 010000>, E<.Cm cs3> E<.Pq Dv 011000>, E<.Cm cs4> E<.Pq Dv 100000>, E<.Cm "
"cs5> E<.Pq Dv 101000>, E<.Cm cs6> E<.Pq Dv 110000>, E<.Cm cs7> E<.Pq Dv "
"111000>, E<.Cm af11> E<.Pq Dv 001010>, E<.Cm af12> E<.Pq Dv 001100>, E<.Cm "
"af13> E<.Pq Dv 001110>, E<.Cm af21> E<.Pq Dv 010010>, E<.Cm af22> E<.Pq Dv "
"010100>, E<.Cm af23> E<.Pq Dv 010110>, E<.Cm af31> E<.Pq Dv 011010>, E<.Cm "
"af32> E<.Pq Dv 011100>, E<.Cm af33> E<.Pq Dv 011110>, E<.Cm af41> E<.Pq Dv "
"100010>, E<.Cm af42> E<.Pq Dv 100100>, E<.Cm af43> E<.Pq Dv 100110>, E<.Cm "
"ef> E<.Pq Dv 101110>, E<.Cm be> E<.Pq Dv 000000>.  Additionally, DSCP value "
"can be specified by number (0..63).  It is also possible to use the E<.Cm "
"tablearg> keyword with setdscp.  If the tablearg value is not within the 0.."
"63 range, lower 6 bits of supplied value are used."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1187
#, no-wrap
msgid "Cm tcp-setmss Ar mss"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1201
msgid ""
"Set the Maximum Segment Size (MSS) in the TCP segment to value E<.Ar mss>.  "
"The kernel module E<.Cm ipfw_pmod> should be loaded or kernel should have E<."
"Cm options IPFIREWALL_PMOD> to be able use this action.  This command does "
"not change a packet if original MSS value is lower than specified value.  "
"Both TCP over IPv4 and over IPv6 are supported.  Regardless of matched a "
"packet or not by the E<.Cm tcp-setmss> rule, the search continues with the "
"next rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1201
#, no-wrap
msgid "Cm reass"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1212
msgid ""
"Queue and reassemble IPv4 fragments.  If the packet is not fragmented, "
"counters are updated and processing continues with the next rule.  If the "
"packet is the last logical fragment, the packet is reassembled and, if E<.Va "
"net.inet.ip.fw.one_pass> is set to 0, processing continues with the next "
"rule.  Otherwise, the packet is allowed to pass and the search terminates.  "
"If the packet is a fragment in the middle of a logical group of fragments, "
"it is consumed and processing stops immediately."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1220
msgid ""
"Fragment handling can be tuned via E<.Va net.inet.ip.maxfragpackets> and E<."
"Va net.inet.ip.maxfragsperpacket> which limit, respectively, the maximum "
"number of processable fragments (default: 800) and the maximum number of "
"fragments per packet (default: 16)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1232
msgid ""
"NOTA BENE: since fragments do not contain port numbers, they should be "
"avoided with the E<.Nm reass> rule.  Alternatively, direction-based (like E<."
"Nm in> / E<.Nm out> ) and source-based (like E<.Nm via> ) match patterns can "
"be used to select fragments."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1234
msgid "Usually a simple rule like:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1237
#, no-wrap
msgid "# reassemble incoming fragments\n"
"ipfw add reass all from any to any in\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1240
msgid "is all you need at the beginning of your ruleset."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1240
#, no-wrap
msgid "Cm abort"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1244 /usr/src/sbin/ipfw/ipfw.8:1248
msgid ""
"Discard packets that match this rule, and if the packet is an SCTP packet, "
"try to send an SCTP packet containing an ABORT chunk.  The search terminates."
""
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1244
#, no-wrap
msgid "Cm abort6"
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:1249
#, no-wrap
msgid "RULE BODY"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1261
msgid ""
"The body of a rule contains zero or more patterns (such as specific source "
"and destination addresses or ports, protocol options, incoming or outgoing "
"interfaces, etc.)  that the packet must match in order to be recognised.  In "
"general, the patterns are connected by (implicit)  E<.Cm and> operators -- i."
"e., all must match in order for the rule to match.  Individual patterns can "
"be prefixed by the E<.Cm not> operator to reverse the result of the match, "
"as in"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:1262
#, no-wrap
msgid "ipfw add 100 allow ip from not 1.2.3.4 to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1271
msgid ""
"Additionally, sets of alternative match patterns E<.Pq Em or-blocks> can be "
"constructed by putting the patterns in lists enclosed between parentheses ( "
") or braces { }, and using the E<.Cm or> operator as follows:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:1272
#, no-wrap
msgid "ipfw add 100 allow ip from { x or not y or z } to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1278
msgid ""
"Only one level of parentheses is allowed.  Beware that most shells have "
"special meanings for parentheses or braces, so it is advisable to put a "
"backslash \\e in front of them to prevent such interpretations."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1285
msgid ""
"The body of a rule must in general include a source and destination address "
"specifier.  The keyword E<.Ar any> can be used in various places to specify "
"that the content of a required field is irrelevant."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1287
msgid "The rule body has the following format:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1290
#, no-wrap
msgid "E<.Op Ar proto Cm from Ar src Cm to Ar dst>\n"
"E<.Op Ar options>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1301
msgid ""
"The first part (proto from src to dst) is for backward compatibility with "
"earlier versions of E<.Fx>.  In modern E<.Fx> any match pattern (including "
"MAC headers, IP protocols, addresses and ports) can be specified in the E<."
"Ar options> section."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1303
msgid "Rule fields have the following meaning:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1304
#, no-wrap
msgid "Ar proto : protocol | Cm { Ar protocol Cm or ... }"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1305
#, no-wrap
msgid "Ar protocol : Oo Cm not Oc Ar protocol-name | protocol-number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1310
msgid ""
"An IP protocol specified by number or name (for a complete list see E<.Pa /"
"etc/protocols>), or one of the following keywords:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1311
#, no-wrap
msgid "Cm ip4 | ipv4"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1313
msgid "Matches IPv4 packets."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1313
#, no-wrap
msgid "Cm ip6 | ipv6"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1315
msgid "Matches IPv6 packets."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1315
#, no-wrap
msgid "Cm ip | all"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1317
msgid "Matches any packet."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1329
msgid ""
"The E<.Cm ipv6> in E<.Cm proto> option will be treated as inner protocol.  "
"And, the E<.Cm ipv4> is not available in E<.Cm proto> option."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1335
msgid ""
"The E<.Cm { Ar protocol Cm or ... }> format (an E<.Em or-block>)  is "
"provided for convenience only but its use is deprecated."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1335
#, no-wrap
msgid ""
"Ar src No and Ar dst : Bro Cm addr | Cm { Ar addr Cm or ... } Brc Op Oo Cm "
"not Oc Ar ports"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1340
msgid ""
"An address (or a list, see below)  optionally followed by E<.Ar ports> "
"specifiers."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1345
msgid ""
"The second format E<.Em ( or-block> with multiple addresses) is provided for "
"convenience only and its use is discouraged."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1345
#, no-wrap
msgid "Ar addr : Oo Cm not Oc Bro"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1350
msgid ""
"E<.Cm any | me | me6 |> E<.Cm table Ns Pq Ar name Ns Op , Ns Ar value> E<.Ar "
"| addr-list | addr-set> E<.Brc>"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1351
#, no-wrap
msgid "Cm any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1353
msgid "Matches any IP address."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1353
#, no-wrap
msgid "Cm me"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1355
msgid "Matches any IP address configured on an interface in the system."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1355
#, no-wrap
msgid "Cm me6"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1359
msgid ""
"Matches any IPv6 address configured on an interface in the system.  The "
"address list is evaluated at the time the packet is analysed."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1359
#, no-wrap
msgid "Cm table Ns Pq Ar name Ns Op , Ns Ar value"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1368
msgid ""
"Matches any IPv4 or IPv6 address for which an entry exists in the lookup "
"table E<.Ar number>.  If an optional 32-bit unsigned E<.Ar value> is also "
"specified, an entry will match only if it has this value.  See the E<.Sx "
"LOOKUP TABLES> section below for more information on lookup tables."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1369
#, no-wrap
msgid "Ar addr-list : ip-addr Ns Op Ns , Ns Ar addr-list"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1370
#, no-wrap
msgid "Ar ip-addr :"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1372
msgid "A host or subnet address specified in one of the following ways:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1373 /usr/src/sbin/ipfw/ipfw.8:1433
#, no-wrap
msgid "Ar numeric-ip | hostname"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1376
msgid ""
"Matches a single IPv4 address, specified as dotted-quad or a hostname.  "
"Hostnames are resolved at the time the rule is added to the firewall list."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1376 /usr/src/sbin/ipfw/ipfw.8:1439
#, no-wrap
msgid "Ar addr Ns / Ns Ar masklen"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1385
msgid ""
"Matches all addresses with base E<.Ar addr> (specified as an IP address, a "
"network number, or a hostname)  and mask width of E<.Cm masklen> bits.  As "
"an example, 1.2.3.4/25 or 1.2.3.0/25 will match all IP numbers from 1.2.3.0 "
"to 1.2.3.127 ."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1385
#, no-wrap
msgid "Ar addr Ns : Ns Ar mask"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1400
msgid ""
"Matches all addresses with base E<.Ar addr> (specified as an IP address, a "
"network number, or a hostname)  and the mask of E<.Ar mask>, specified as a "
"dotted quad.  As an example, 1.2.3.4:255.0.255.0 or 1.0.3.0:255.0.255.0 will "
"match 1.*.3.*.  This form is advised only for non-contiguous masks.  It is "
"better to resort to the E<.Ar addr Ns / Ns Ar masklen> format for contiguous "
"masks, which is more compact and less error-prone."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1401
#, no-wrap
msgid ""
"Ar addr-set : addr Ns Oo Ns / Ns Ar masklen Oc Ns Cm { Ns Ar list Ns Cm }"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1402
#, no-wrap
msgid "Ar list : Bro Ar num | num-num Brc Ns Op Ns , Ns Ar list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1417
msgid ""
"Matches all addresses with base address E<.Ar addr> (specified as an IP "
"address, a network number, or a hostname)  and whose last byte is in the "
"list between braces { } .  Note that there must be no spaces between braces "
"and numbers (spaces after commas are allowed).  Elements of the list can be "
"specified as single entries or ranges.  The E<.Ar masklen> field is used to "
"limit the size of the set of addresses, and can have any value between 24 "
"and 32.  If not specified, it will be assumed as 24."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1423
msgid ""
"This format is particularly useful to handle sparse address sets within a "
"single rule.  Because the matching occurs using a bitmask, it takes constant "
"time and dramatically reduces the complexity of rulesets."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1427
msgid ""
"As an example, an address specified as 1.2.3.4/24{128,35-55,89} or 1.2.3.0/"
"24{128,35-55,89} will match the following IP addresses:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1429
msgid "1.2.3.128, 1.2.3.35 to 1.2.3.55, 1.2.3.89 ."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1429
#, no-wrap
msgid "Ar addr6-list : ip6-addr Ns Op Ns , Ns Ar addr6-list"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1430
#, no-wrap
msgid "Ar ip6-addr :"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1432
msgid "A host or subnet specified one of the following ways:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1439
msgid ""
"Matches a single IPv6 address as allowed by E<.Xr inet_pton 3> or a hostname."
"  Hostnames are resolved at the time the rule is added to the firewall list."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1448
msgid ""
"Matches all IPv6 addresses with base E<.Ar addr> (specified as allowed by E<."
"Xr inet_pton> or a hostname)  and mask width of E<.Cm masklen> bits."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1448
#, no-wrap
msgid "Ar addr Ns / Ns Ar mask"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1466
msgid ""
"Matches all IPv6 addresses with base E<.Ar addr> (specified as allowed by E<."
"Xr inet_pton> or a hostname)  and the mask of E<.Ar mask>, specified as "
"allowed by E<.Xr inet_pton.> As an example, fe::640:0:0/ffff::ffff:ffff:0:0 "
"will match fe:*:*:*:0:640:*:*.  This form is advised only for non-contiguous "
"masks.  It is better to resort to the E<.Ar addr Ns / Ns Ar masklen> format "
"for contiguous masks, which is more compact and less error-prone."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1470
msgid ""
"No support for sets of IPv6 addresses is provided because IPv6 addresses are "
"typically random past the initial prefix."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1470
#, no-wrap
msgid ""
"Ar ports : Bro Ar port | port Ns \\&- Ns Ar port Ns Brc Ns Op , Ns Ar ports"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1480
msgid ""
"For protocols which support port numbers (such as SCTP, TCP and UDP), "
"optional E<.Cm ports> may be specified as one or more ports or port ranges, "
"separated by commas but no spaces, and an optional E<.Cm not> operator.  The "
"E<.Ql \\&-> notation specifies a range of ports (including boundaries)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1490
msgid ""
"Service names (from E<.Pa /etc/services>)  may be used instead of numeric "
"port values.  The length of the port list is limited to 30 ports or ranges, "
"though one can specify larger ranges by using an E<.Em or-block> in the E<."
"Cm options> section of the rule."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1498
msgid ""
"A backslash E<.Pq Ql \\e> can be used to escape the dash E<.Pq Ql -> "
"character in a service name (from a shell, the backslash must be typed twice "
"to avoid the shell itself interpreting it as an escape character)."
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:1499
#, no-wrap
msgid "ipfw add count tcp from any ftp\\e\\e-data-ftp to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1507
msgid ""
"Fragmented packets which have a non-zero offset (i.e., not the first "
"fragment) will never match a rule which has one or more port specifications. "
" See the E<.Cm frag> option for details on matching fragmented packets."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:1508
#, no-wrap
msgid "RULE OPTIONS (MATCH PATTERNS)"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1517
msgid ""
"Additional match patterns can be used within rules.  Zero or more of these "
"so-called E<.Em options> can be present in a rule, optionally prefixed by "
"the E<.Cm not> operand, and possibly grouped into E<.Em or-blocks>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1519
msgid ""
"The following match patterns can be used (listed in alphabetical order):"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1520
#, no-wrap
msgid "Cm // this is a comment."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1526
msgid ""
"Inserts the specified text as a comment in the rule.  Everything following //"
" is considered as a comment and stored in the rule.  You can have comment-"
"only rules, which are listed as having a E<.Cm count> action followed by the "
"comment."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1526
#, no-wrap
msgid "Cm bridged"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1529
msgid "Alias for E<.Cm layer2>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1529
#, no-wrap
msgid "Cm defer-immediate-action | defer-action"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1544
msgid ""
"A rule with this option will not perform normal action upon a match. This "
"option is intended to be used with E<.Cm record-state> or E<.Cm keep-state> "
"as the dynamic rule, created but ignored on match, will work as intended.  "
"Rules with both E<.Cm record-state> and E<.Cm defer-immediate-action> create "
"a dynamic rule and continue with the next rule without actually performing "
"the action part of this rule. When the rule is later activated via the state "
"table, the action is performed as usual."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1544
#, no-wrap
msgid "Cm diverted"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1546
msgid "Matches only packets generated by a divert socket."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1546
#, no-wrap
msgid "Cm diverted-loopback"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1549
msgid ""
"Matches only packets coming from a divert socket back into the IP stack "
"input for delivery."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1549
#, no-wrap
msgid "Cm diverted-output"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1552
msgid ""
"Matches only packets going from a divert socket back outward to the IP stack "
"output for delivery."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1552
#, no-wrap
msgid "Cm dst-ip Ar ip-address"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1555
msgid ""
"Matches IPv4 packets whose destination IP is one of the address(es)  "
"specified as argument."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1555
#, no-wrap
msgid "Bro Cm dst-ip6 | dst-ipv6 Brc Ar ip6-address"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1558
msgid ""
"Matches IPv6 packets whose destination IP is one of the address(es)  "
"specified as argument."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1558
#, no-wrap
msgid "Cm dst-port Ar ports"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1561
msgid ""
"Matches IP packets whose destination port is one of the port(s)  specified "
"as argument."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1561
#, no-wrap
msgid "Cm established"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1563
msgid "Matches TCP packets that have the RST or ACK bits set."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1563
#, no-wrap
msgid "Cm ext6hdr Ar header"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1567
msgid ""
"Matches IPv6 packets containing the extended header given by E<.Ar header>.  "
"Supported headers are:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1584
msgid ""
"Fragment, E<.Pq Cm frag>, Hop-to-hop options E<.Pq Cm hopopt>, any type of "
"Routing Header E<.Pq Cm route>, Source routing Routing Header Type 0 E<.Pq "
"Cm rthdr0>, Mobile IPv6 Routing Header Type 2 E<.Pq Cm rthdr2>, Destination "
"options E<.Pq Cm dstopt>, IPSec authentication headers E<.Pq Cm ah>, and "
"IPsec encapsulated security payload headers E<.Pq Cm esp>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1584
#, no-wrap
msgid "Cm fib Ar fibnum"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1587
msgid ""
"Matches a packet that has been tagged to use the given FIB (routing table) "
"number."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1587
#, no-wrap
msgid "Cm flow Ar table Ns Pq Ar name Ns Op , Ns Ar value"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1594
msgid ""
"Search for the flow entry in lookup table E<.Ar name>.  If not found, the "
"match fails.  Otherwise, the match succeeds and E<.Cm tablearg> is set to "
"the value extracted from the table."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1600 /usr/src/sbin/ipfw/ipfw.8:1811
msgid ""
"This option can be useful to quickly dispatch traffic based on certain "
"packet fields.  See the E<.Sx LOOKUP TABLES> section below for more "
"information on lookup tables."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1600
#, no-wrap
msgid "Cm flow-id Ar labels"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1605
msgid ""
"Matches IPv6 packets containing any of the flow labels given in E<.Ar "
"labels>.  E<.Ar labels> is a comma separated list of numeric flow labels."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1605
#, no-wrap
msgid "Cm frag"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1611
msgid ""
"Matches packets that are fragments and not the first fragment of an IP "
"datagram.  Note that these packets will not have the next protocol header (e."
"g.\\& TCP, UDP) so options that look into these headers cannot match."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1611
#, no-wrap
msgid "Cm gid Ar group"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1617
msgid ""
"Matches all TCP or UDP packets sent by or received for a E<.Ar group>.  A E<."
"Ar group> may be specified by name or number."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1617
#, no-wrap
msgid "Cm jail Ar jail"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1621
msgid ""
"Matches all TCP or UDP packets sent by or received for the jail whose ID or "
"name is E<.Ar jail>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1621
#, no-wrap
msgid "Cm icmptypes Ar types"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1628
msgid ""
"Matches ICMP packets whose ICMP type is in the list E<.Ar types>.  The list "
"may be specified as any combination of individual types (numeric) separated "
"by commas.  E<.Em Ranges are not allowed>.  The supported ICMP types are:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1659
msgid ""
"echo reply E<.Pq Cm 0>, destination unreachable E<.Pq Cm 3>, source quench "
"E<.Pq Cm 4>, redirect E<.Pq Cm 5>, echo request E<.Pq Cm 8>, router "
"advertisement E<.Pq Cm 9>, router solicitation E<.Pq Cm 10>, time-to-live "
"exceeded E<.Pq Cm 11>, IP header bad E<.Pq Cm 12>, timestamp request E<.Pq "
"Cm 13>, timestamp reply E<.Pq Cm 14>, information request E<.Pq Cm 15>, "
"information reply E<.Pq Cm 16>, address mask request E<.Pq Cm 17> and "
"address mask reply E<.Pq Cm 18>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1659
#, no-wrap
msgid "Cm icmp6types Ar types"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1665
msgid ""
"Matches ICMP6 packets whose ICMP6 type is in the list of E<.Ar types>.  The "
"list may be specified as any combination of individual types (numeric) "
"separated by commas.  E<.Em Ranges are not allowed>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1665
#, no-wrap
msgid "Cm in | out"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1674
msgid ""
"Matches incoming or outgoing packets, respectively.  E<.Cm in> and E<.Cm "
"out> are mutually exclusive (in fact, E<.Cm out> is implemented as E<.Cm not "
"in Ns No ).>"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1674
#, no-wrap
msgid "Cm ipid Ar id-list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1682
msgid ""
"Matches IPv4 packets whose E<.Cm ip_id> field has value included in E<.Ar id-"
"list>, which is either a single value or a list of values or ranges "
"specified in the same way as E<.Ar ports>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1682
#, no-wrap
msgid "Cm iplen Ar len-list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1689
msgid ""
"Matches IP packets whose total length, including header and data, is in the "
"set E<.Ar len-list>, which is either a single value or a list of values or "
"ranges specified in the same way as E<.Ar ports>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1689
#, no-wrap
msgid "Cm ipoptions Ar spec"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1694
msgid ""
"Matches packets whose IPv4 header contains the comma separated list of "
"options specified in E<.Ar spec>.  The supported IP options are:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1706
msgid ""
"E<.Cm ssrr> (strict source route), E<.Cm lsrr> (loose source route), E<.Cm "
"rr> (record packet route) and E<.Cm ts> (timestamp).  The absence of a "
"particular option may be denoted with a E<.Ql \\&!>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1706
#, no-wrap
msgid "Cm ipprecedence Ar precedence"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1709
msgid ""
"Matches IPv4 packets whose precedence field is equal to E<.Ar precedence>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1709
#, no-wrap
msgid "Cm ipsec"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1713
msgid ""
"Matches packets that have IPSEC history associated with them (i.e., the "
"packet comes encapsulated in IPSEC, the kernel has IPSEC support, and can "
"correctly decapsulate it)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1720
msgid ""
"Note that specifying E<.Cm ipsec> is different from specifying E<.Cm proto "
"Ar ipsec> as the latter will only look at the specific IP protocol field, "
"irrespective of IPSEC kernel support and the validity of the IPSEC data."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1727
msgid ""
"Further note that this flag is silently ignored in kernels without IPSEC "
"support.  It does not affect rule processing when given and the rules are "
"handled as if with no E<.Cm ipsec> flag."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1727
#, no-wrap
msgid "Cm iptos Ar spec"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1734
msgid ""
"Matches IPv4 packets whose E<.Cm tos> field contains the comma separated "
"list of service types specified in E<.Ar spec>.  The supported IP types of "
"service are:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1748
msgid ""
"E<.Cm lowdelay> E<.Pq Dv IPTOS_LOWDELAY>, E<.Cm throughput> E<.Pq Dv "
"IPTOS_THROUGHPUT>, E<.Cm reliability> E<.Pq Dv IPTOS_RELIABILITY>, E<.Cm "
"mincost> E<.Pq Dv IPTOS_MINCOST>, E<.Cm congestion> E<.Pq Dv IPTOS_ECN_CE>.  "
"The absence of a particular type may be denoted with a E<.Ql \\&!>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1748
#, no-wrap
msgid "Cm dscp spec Ns Op , Ns Ar spec"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1759
msgid ""
"Matches IPv4/IPv6 packets whose E<.Cm DS> field value is contained in E<.Ar "
"spec> mask.  Multiple values can be specified via the comma separated list.  "
"Value can be one of keywords used in E<.Cm setdscp> action or exact number."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1759
#, no-wrap
msgid "Cm ipttl Ar ttl-list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1765
msgid ""
"Matches IPv4 packets whose time to live is included in E<.Ar ttl-list>, "
"which is either a single value or a list of values or ranges specified in "
"the same way as E<.Ar ports>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1765
#, no-wrap
msgid "Cm ipversion Ar ver"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1768
msgid "Matches IP packets whose IP version field is E<.Ar ver>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1768
#, no-wrap
msgid "Cm keep-state Op Ar :flowname"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1785
msgid ""
"Upon a match, the firewall will create a dynamic rule, whose default "
"behaviour is to match bidirectional traffic between source and destination "
"IP/port using the same protocol.  The rule has a limited lifetime "
"(controlled by a set of E<.Xr sysctl 8> variables), and the lifetime is "
"refreshed every time a matching packet is found.  The E<.Ar :flowname> is "
"used to assign additional to addresses, ports and protocol parameter to "
"dynamic rule. It can be used for more accurate matching by E<.Cm check-"
"state> rule.  The E<.Cm :default> keyword is special name used for "
"compatibility with old rulesets."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1785
#, no-wrap
msgid "Cm layer2"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1789
msgid ""
"Matches only layer2 packets, i.e., those passed to E<.Nm> from ether_demux() "
"and ether_output_frame()."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1789
#, no-wrap
msgid ""
"Cm limit Bro Cm src-addr | src-port | dst-addr | dst-port Brc Ar N Op Ar :"
"flowname"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1797
msgid ""
"The firewall will only allow E<.Ar N> connections with the same set of "
"parameters as specified in the rule.  One or more of source and destination "
"addresses and ports can be specified."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1797
#, no-wrap
msgid ""
"Cm lookup Bro Cm dst-ip | dst-port | src-ip | src-port | uid | jail Brc Ar "
"name"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1805
msgid ""
"Search an entry in lookup table E<.Ar name> that matches the field specified "
"as argument.  If not found, the match fails.  Otherwise, the match succeeds "
"and E<.Cm tablearg> is set to the value extracted from the table."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1811
#, no-wrap
msgid "Cm { MAC | mac } Ar dst-mac src-mac"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1822
msgid ""
"Match packets with a given E<.Ar dst-mac> and E<.Ar src-mac> addresses, "
"specified as the E<.Cm any> keyword (matching any MAC address), or six "
"groups of hex digits separated by colons, and optionally followed by a mask "
"indicating the significant bits.  The mask may be specified using either of "
"the following methods:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1828
msgid ""
"A slash E<.Pq /> followed by the number of significant bits.  For example, "
"an address with 33 significant bits could be specified as:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:1829
#, no-wrap
msgid "MAC 10:20:30:40:50:60/33 any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1837
msgid ""
"An ampersand E<.Pq &> followed by a bitmask specified as six groups of hex "
"digits separated by colons.  For example, an address in which the last 16 "
"bits are significant could be specified as:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:1838
#, no-wrap
msgid "MAC 10:20:30:40:50:60&00:00:00:00:ff:ff any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1842
msgid ""
"Note that the ampersand character has a special meaning in many shells and "
"should generally be escaped."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1847
msgid ""
"Note that the order of MAC addresses (destination first, source second) is "
"the same as on the wire, but the opposite of the one used for IP addresses."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1847
#, no-wrap
msgid "Cm mac-type Ar mac-type"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1860
msgid ""
"Matches packets whose Ethernet Type field corresponds to one of those "
"specified as argument.  E<.Ar mac-type> is specified in the same way as E<."
"Cm port numbers> (i.e., one or more comma-separated single values or ranges)."
"  You can use symbolic names for known values such as E<.Em vlan , ipv4, "
"ipv6>.  Values can be entered as decimal or hexadecimal (if prefixed by 0x), "
"and they are always printed as hexadecimal (unless the E<.Cm -N> option is "
"used, in which case symbolic resolution will be attempted)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1860
#, no-wrap
msgid "Cm proto Ar protocol"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1862
msgid "Matches packets with the corresponding IP protocol."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1862
#, no-wrap
msgid "Cm record-state"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1870
msgid ""
"Upon a match, the firewall will create a dynamic rule as if E<.Cm keep-"
"state> was specified.  However, this option doesn't imply an implicit E<.Cm "
"check-state> in contrast to E<.Cm keep-state>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1870
#, no-wrap
msgid ""
"Cm recv | xmit | via Brq Ar ifX | Ar if Ns Cm * | Ar table Ns Po Ar name Ns "
"Oo , Ns Ar value Oc Pc | Ar ipno | Ar any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1883
msgid ""
"Matches packets received, transmitted or going through, respectively, the "
"interface specified by exact name E<.Po Ar ifX Pc>, by device name E<.Po Ar "
"if* Pc>, by IP address, or through some interface.  Table E<.Ar name> may be "
"used to match interface by its kernel ifindex.  See the E<.Sx LOOKUP TABLES> "
"section below for more information on lookup tables."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1897
msgid ""
"The E<.Cm via> keyword causes the interface to always be checked.  If E<.Cm "
"recv> or E<.Cm xmit> is used instead of E<.Cm via>, then only the receive or "
"transmit interface (respectively)  is checked.  By specifying both, it is "
"possible to match packets based on both receive and transmit interface, e.g.:"
""
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:1898
#, no-wrap
msgid "ipfw add deny ip from any to any out recv ed0 xmit ed1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1913
msgid ""
"The E<.Cm recv> interface can be tested on either incoming or outgoing "
"packets, while the E<.Cm xmit> interface can only be tested on outgoing "
"packets.  So E<.Cm out> is required (and E<.Cm in> is invalid) whenever E<."
"Cm xmit> is used."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1918
msgid ""
"A packet might not have a receive or transmit interface: packets originating "
"from the local host have no receive interface, while packets destined for "
"the local host have no transmit interface."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1918
#, no-wrap
msgid "Cm set-limit Bro Cm src-addr | src-port | dst-addr | dst-port Brc Ar N"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1924
msgid ""
"Works like E<.Cm limit> but does not have an implicit E<.Cm check-state> "
"attached to it."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1924
#, no-wrap
msgid "Cm setup"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1928
msgid ""
"Matches TCP packets that have the SYN bit set but no ACK bit.  This is the "
"short form of E<.Dq Li tcpflags\\ syn,!ack>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1928
#, no-wrap
msgid "Cm sockarg"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1940
msgid ""
"Matches packets that are associated to a local socket and for which the "
"SO_USER_COOKIE socket option has been set to a non-zero value.  As a side "
"effect, the value of the option is made available as E<.Cm tablearg> value, "
"which in turn can be used as E<.Cm skipto> or E<.Cm pipe> number."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1940
#, no-wrap
msgid "Cm src-ip Ar ip-address"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1943
msgid ""
"Matches IPv4 packets whose source IP is one of the address(es)  specified as "
"an argument."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1943
#, no-wrap
msgid "Cm src-ip6 Ar ip6-address"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1946
msgid ""
"Matches IPv6 packets whose source IP is one of the address(es)  specified as "
"an argument."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1946
#, no-wrap
msgid "Cm src-port Ar ports"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1949
msgid ""
"Matches IP packets whose source port is one of the port(s)  specified as "
"argument."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1949
#, no-wrap
msgid "Cm tagged Ar tag-list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1958
msgid ""
"Matches packets whose tags are included in E<.Ar tag-list>, which is either "
"a single value or a list of values or ranges specified in the same way as E<."
"Ar ports>.  Tags can be applied to the packet using E<.Cm tag> rule action "
"parameter (see it's description for details on tags)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1958
#, no-wrap
msgid "Cm tcpack Ar ack"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1962
msgid ""
"TCP packets only.  Match if the TCP header acknowledgment number field is "
"set to E<.Ar ack>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1962
#, no-wrap
msgid "Cm tcpdatalen Ar tcpdatalen-list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1968
msgid ""
"Matches TCP packets whose length of TCP data is E<.Ar tcpdatalen-list>, "
"which is either a single value or a list of values or ranges specified in "
"the same way as E<.Ar ports>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1968
#, no-wrap
msgid "Cm tcpflags Ar spec"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1974
msgid ""
"TCP packets only.  Match if the TCP header contains the comma separated list "
"of flags specified in E<.Ar spec>.  The supported TCP flags are:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1992
msgid ""
"E<.Cm fin>, E<.Cm syn>, E<.Cm rst>, E<.Cm psh>, E<.Cm ack> and E<.Cm urg>.  "
"The absence of a particular flag may be denoted with a E<.Ql \\&!>.  A rule "
"which contains a E<.Cm tcpflags> specification can never match a fragmented "
"packet which has a non-zero offset.  See the E<.Cm frag> option for details "
"on matching fragmented packets."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1992
#, no-wrap
msgid "Cm tcpseq Ar seq"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:1996
msgid ""
"TCP packets only.  Match if the TCP header sequence number field is set to "
"E<.Ar seq>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:1996
#, no-wrap
msgid "Cm tcpwin Ar tcpwin-list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2002
msgid ""
"Matches TCP packets whose header window field is set to E<.Ar tcpwin-list>, "
"which is either a single value or a list of values or ranges specified in "
"the same way as E<.Ar ports>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2002
#, no-wrap
msgid "Cm tcpoptions Ar spec"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2008
msgid ""
"TCP packets only.  Match if the TCP header contains the comma separated list "
"of options specified in E<.Ar spec>.  The supported TCP options are:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2022
msgid ""
"E<.Cm mss> (maximum segment size), E<.Cm window> (tcp window advertisement), "
"E<.Cm sack> (selective ack), E<.Cm ts> (rfc1323 timestamp) and E<.Cm cc> "
"(rfc1644 t/tcp connection count).  The absence of a particular option may be "
"denoted with a E<.Ql \\&!>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2022
#, no-wrap
msgid "Cm uid Ar user"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2028
msgid ""
"Match all TCP or UDP packets sent by or received for a E<.Ar user>.  A E<.Ar "
"user> may be matched by name or identification number."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2028
#, no-wrap
msgid "Cm verrevpath"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2037
msgid ""
"For incoming packets, a routing table lookup is done on the packet's source "
"address.  If the interface on which the packet entered the system matches "
"the outgoing interface for the route, the packet matches.  If the interfaces "
"do not match up, the packet does not match.  All outgoing packets or packets "
"with no incoming interface match."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2040 /usr/src/sbin/ipfw/ipfw.8:2057
msgid ""
"The name and functionality of the option is intentionally similar to the "
"Cisco IOS command:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2041
#, no-wrap
msgid "ip verify unicast reverse-path"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2047
msgid ""
"This option can be used to make anti-spoofing rules to reject all packets "
"with source addresses not from this interface.  See also the option E<.Cm "
"antispoof>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2047
#, no-wrap
msgid "Cm versrcreach"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2054
msgid ""
"For incoming packets, a routing table lookup is done on the packet's source "
"address.  If a route to the source address exists, but not the default route "
"or a blackhole/reject route, the packet matches.  Otherwise, the packet does "
"not match.  All outgoing packets match."
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2058
#, no-wrap
msgid "ip verify unicast source reachable-via any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2062
msgid ""
"This option can be used to make anti-spoofing rules to reject all packets "
"whose source address is unreachable."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2062
#, no-wrap
msgid "Cm antispoof"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2071
msgid ""
"For incoming packets, the packet's source address is checked if it belongs "
"to a directly connected network.  If the network is directly connected, then "
"the interface the packet came on in is compared to the interface the network "
"is connected to.  When incoming interface and directly connected interface "
"are not the same, the packet does not match.  Otherwise, the packet does "
"match.  All outgoing packets match."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2079
msgid ""
"This option can be used to make anti-spoofing rules to reject all packets "
"that pretend to be from a directly connected network but do not come in "
"through that interface.  This option is similar to but more restricted than "
"E<.Cm verrevpath> because it engages only on packets with source addresses "
"of directly connected networks instead of all source addresses."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2098
msgid ""
"Lookup tables are useful to handle large sparse sets of addresses or other "
"search keys (e.g., ports, jail IDs, interface names).  In the rest of this "
"section we will use the term ``key''.  Table name needs to match the "
"following spec: E<.Ar table-name>.  Tables with the same name can be created "
"in different E<.Ar sets>.  However, rule links to the tables in E<.Ar set 0> "
"by default.  This behavior can be controlled by E<.Va net.inet.ip.fw."
"tables_sets> variable.  See the E<.Sx SETS OF RULES> section for more "
"information.  There may be up to 65535 different lookup tables."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2100
msgid "The following table types are supported:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2101
#, no-wrap
msgid "Ar table-type : Ar addr | iface | number | flow"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2102
#, no-wrap
msgid ""
"Ar table-key : Ar addr Ns Oo / Ns Ar masklen Oc | iface-name | number | flow-"
"spec"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2103
#, no-wrap
msgid "Ar flow-spec : Ar flow-field Ns Op , Ns Ar flow-spec"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2104
#, no-wrap
msgid "Ar flow-field : src-ip | proto | src-port | dst-ip | dst-port"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2105
#, no-wrap
msgid "Cm addr"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2119
msgid ""
"Matches IPv4 or IPv6 address.  Each entry is represented by an E<.Ar addr Ns "
"Op / Ns Ar masklen> and will match all addresses with base E<.Ar addr> "
"(specified as an IPv4/IPv6 address, or a hostname) and mask width of E<.Ar "
"masklen> bits.  If E<.Ar masklen> is not specified, it defaults to 32 for "
"IPv4 and 128 for IPv6.  When looking up an IP address in a table, the most "
"specific entry will match."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2119
#, no-wrap
msgid "Cm iface"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2123
msgid ""
"Matches interface names.  Each entry is represented by string treated as "
"interface name.  Wildcards are not supported."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2123
#, no-wrap
msgid "Cm number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2127
msgid ""
"Matches protocol ports, uids/gids or jail IDs.  Each entry is represented by "
"32-bit unsigned integer.  Ranges are not supported."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2127
#, no-wrap
msgid "Cm flow"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2131
msgid ""
"Matches packet fields specified by E<.Ar flow> type suboptions with table "
"entries."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2136
msgid "Tables require explicit creation via E<.Cm create> before use."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2138
msgid "The following creation options are supported:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2139
#, no-wrap
msgid "Ar create-options : Ar create-option | create-options"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2140
#, no-wrap
msgid ""
"Ar create-option : Cm type Ar table-type | Cm valtype Ar value-mask | Cm "
"algo Ar algo-desc |"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2142
msgid "E<.Cm limit Ar number | Cm locked>"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2142
#, no-wrap
msgid "Cm type"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2144
msgid "Table key type."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2144
#, no-wrap
msgid "Cm valtype"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2146
msgid "Table value mask."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2146
#, no-wrap
msgid "Cm algo"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2148
msgid "Table algorithm to use (see below)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2148 /usr/src/sbin/ipfw/ipfw.8:2161 /usr/src/sbin/ipfw/ipfw.8:2288 /usr/src/sbin/ipfw/ipfw.8:2817
#, no-wrap
msgid "Cm limit"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2150
msgid "Maximum number of items that may be inserted into table."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2150
#, no-wrap
msgid "Cm locked"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2152
msgid "Restrict any table modifications."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2158
msgid ""
"Some of these options may be modified later via E<.Cm modify> keyword.  The "
"following options can be changed:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2159
#, no-wrap
msgid "Ar modify-options : Ar modify-option | modify-options"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2160
#, no-wrap
msgid "Ar modify-option : Cm limit Ar number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2163
msgid "Alter maximum number of items that may be inserted into table."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2170
msgid ""
"Additionally, table can be locked or unlocked using E<.Cm lock> or E<.Cm "
"unlock> commands."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2179
msgid ""
"Tables of the same E<.Ar type> can be swapped with each other using E<.Cm "
"swap Ar name> command.  Swap may fail if tables limits are set and data "
"exchange would result in limits hit.  Operation is performed atomically."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2192
msgid ""
"One or more entries can be added to a table at once using E<.Cm add> command."
"  Addition of all items are performed atomically.  By default, error in "
"addition of one entry does not influence addition of other entries. However, "
"non-zero error code is returned in that case.  Special E<.Cm atomic> keyword "
"may be specified before E<.Cm add> to indicate all-or-none add request."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2199
msgid ""
"One or more entries can be removed from a table at once using E<.Cm delete> "
"command.  By default, error in removal of one entry does not influence "
"removing of other entries. However, non-zero error code is returned in that "
"case."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2207
msgid ""
"It may be possible to check what entry will be found on particular E<.Ar "
"table-key> using E<.Cm lookup> E<.Ar table-key> command.  This functionality "
"is optional and may be unsupported in some algorithms."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2213
msgid ""
"The following operations can be performed on E<.Ar one> or E<.Cm all> tables:"
""
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2214
#, no-wrap
msgid "Cm list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2216
msgid "List all entries."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2216
#, no-wrap
msgid "Cm flush"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2218
msgid "Removes all entries."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2218
#, no-wrap
msgid "Cm info"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2220
msgid "Shows generic table information."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2220
#, no-wrap
msgid "Cm detail"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2222
msgid "Shows generic table information and algo-specific data."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2225
msgid "The following lookup algorithms are supported:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2226
#, no-wrap
msgid "Ar algo-desc : algo-name | \"algo-name algo-data\""
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2227
#, no-wrap
msgid ""
"Ar algo-name: Ar addr:radix | addr:hash | iface:array | number:array | flow:"
"hash"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2228
#, no-wrap
msgid "Cm addr:radix"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2234
msgid ""
"Separate Radix trees for IPv4 and IPv6, the same way as the routing table "
"(see E<.Xr route 4>).  Default choice for E<.Ar addr> type."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2234
#, no-wrap
msgid "Cm addr:hash"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2243
msgid ""
"Separate auto-growing hashes for IPv4 and IPv6.  Accepts entries with the "
"same mask length specified initially via E<.Cm \"addr:hash masks=/v4,/v6\"> "
"algorithm creation options.  Assume /32 and /128 masks by default.  Search "
"removes host bits (according to mask) from supplied address and checks "
"resulting key in appropriate hash.  Mostly optimized for /64 and byte-ranged "
"IPv6 masks."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2243
#, no-wrap
msgid "Cm iface:array"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2246
msgid ""
"Array storing sorted indexes for entries which are presented in the system.  "
"Optimized for very fast lookup."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2246
#, no-wrap
msgid "Cm number:array"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2248
msgid "Array storing sorted u32 numbers."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2248
#, no-wrap
msgid "Cm flow:hash"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2252
msgid ""
"Auto-growing hash storing flow entries.  Search calculates hash on required "
"packet fields and searches for matching entries in selected bucket."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2261
msgid ""
"The E<.Cm tablearg> feature provides the ability to use a value, looked up "
"in the table, as the argument for a rule action, action parameter or rule "
"option.  This can significantly reduce number of rules in some "
"configurations.  If two tables are used in a rule, the result of the second "
"(destination)  is used."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2268
msgid ""
"Each record may hold one or more values according to E<.Ar value-mask>.  "
"This mask is set on table creation via E<.Cm valtype> option.  The following "
"value types are supported:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2269
#, no-wrap
msgid "Ar value-mask : Ar value-type Ns Op , Ns Ar value-mask"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2270
#, no-wrap
msgid "Ar value-type : Ar skipto | pipe | fib | nat | dscp | tag | divert |"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2272
msgid "E<.Ar netgraph | limit | ipv4>"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2272
#, no-wrap
msgid "Cm skipto"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2274
msgid "rule number to jump to."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2274
#, no-wrap
msgid "Cm pipe"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2276
msgid "Pipe number to use."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2276
#, no-wrap
msgid "Cm fib"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2278
msgid "fib number to match/set."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2278
#, no-wrap
msgid "Cm nat"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2280
msgid "nat number to jump to."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2280
#, no-wrap
msgid "Cm dscp"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2282
msgid "dscp value to match/set."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2282
#, no-wrap
msgid "Cm tag"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2284
msgid "tag number to match/set."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2284
#, no-wrap
msgid "Cm divert"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2286
msgid "port number to divert traffic to."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2286
#, no-wrap
msgid "Cm netgraph"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2288
msgid "hook number to move packet to."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2290
msgid "maximum number of connections."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2290
#, no-wrap
msgid "Cm ipv4"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2292
msgid "IPv4 nexthop to fwd packets to."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2292
#, no-wrap
msgid "Cm ipv6"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2294
msgid "IPv6 nexthop to fwd packets to."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2304
msgid ""
"The E<.Cm tablearg> argument can be used with the following actions: E<.Cm "
"nat, pipe , queue, divert, tee, netgraph, ngtee, fwd, skipto, setfib,> "
"action parameters: E<.Cm tag, untag,> rule options: E<.Cm limit, tagged.>"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2309
msgid ""
"When used with the E<.Cm skipto> action, the user should be aware that the "
"code will walk the ruleset up to a rule equal to, or past, the given number."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2313
msgid ""
"See the E<.Sx EXAMPLES> Section for example usage of tables and the tablearg "
"keyword."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:2313 /usr/src/sbin/ipfw/ipfw.8:4435
#, no-wrap
msgid "SETS OF RULES"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2318
msgid ""
"Each rule or table belongs to one of 32 different E<.Em sets> , numbered 0 "
"to 31.  Set 31 is reserved for the default rule."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2325
msgid ""
"By default, rules or tables are put in set 0, unless you use the E<.Cm set "
"N> attribute when adding a new rule or table.  Sets can be individually and "
"atomically enabled or disabled, so this mechanism permits an easy way to "
"store multiple configurations of the firewall and quickly (and atomically) "
"switch between them."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2332
msgid ""
"By default, tables from set 0 are referenced when adding rule with table "
"opcodes regardless of rule set.  This behavior can be changed by setting E<."
"Va net.inet.ip.fw.tables_sets> variable to 1.  Rule's set will then be used "
"for table references."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2334
msgid "The command to enable/disable sets is"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2337
#, no-wrap
msgid ""
"E<.Nm>\n"
"E<.Cm set Oo Cm disable Ar number ... Oc Op Cm enable Ar number ...>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2346
msgid ""
"where multiple E<.Cm enable> or E<.Cm disable> sections can be specified.  "
"Command execution is atomic on all the sets specified in the command.  By "
"default, all sets are enabled."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2349
msgid ""
"When you disable a set, its rules behave as if they do not exist in the "
"firewall configuration, with only one exception:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2355
#, no-wrap
msgid ""
"dynamic rules created from a rule before it had been disabled\n"
"will still be active until they expire.\n"
"In order to delete\n"
"dynamic rules you have to explicitly delete the parent rule\n"
"which generated them.\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2358
msgid "The set number of rules can be changed with the command"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2363
#, no-wrap
msgid ""
"E<.Nm>\n"
"E<.Cm set move>\n"
"E<.Brq Cm rule Ar rule-number | old-set>\n"
"E<.Cm to Ar new-set>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2366
msgid "Also, you can atomically swap two rulesets with the command"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2369
#, no-wrap
msgid "E<.Nm>\n"
"E<.Cm set swap Ar first-set second-set>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2374
msgid ""
"See the E<.Sx EXAMPLES> Section on some possible uses of sets of rules."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:2374
#, no-wrap
msgid "STATEFUL FIREWALL"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2385
msgid ""
"Stateful operation is a way for the firewall to dynamically create rules for "
"specific flows when packets that match a given pattern are detected.  "
"Support for stateful operation comes through the E<.Cm check-state , keep-"
"state , record-state , limit> and E<.Cm set-limit> options of E<.Nm rules>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2417
msgid ""
"Dynamic rules are created when a packet matches a E<.Cm keep-state>, E<.Cm "
"record-state>, E<.Cm limit> or E<.Cm set-limit> rule, causing the creation "
"of a E<.Em dynamic> rule which will match all and only packets with a given "
"E<.Em protocol> between a E<.Em src-ip/src-port dst-ip/dst-port> pair of "
"addresses E<.Em ( src> and E<.Em dst> are used here only to denote the "
"initial match addresses, but they are completely equivalent afterwards).  "
"Rules created by E<.Cm keep-state> option also have a E<.Ar :flowname> taken "
"from it.  This name is used in matching together with addresses, ports and "
"protocol.  Dynamic rules will be checked at the first E<.Cm check-state, "
"keep-state> or E<.Cm limit> occurrence, and the action performed upon a "
"match will be the same as in the parent rule."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2420
msgid ""
"Note that no additional attributes other than protocol and IP addresses and "
"ports and :flowname are checked on dynamic rules."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2425
msgid ""
"The typical use of dynamic rules is to keep a closed firewall configuration, "
"but let the first TCP SYN packet from the inside network install a dynamic "
"rule for the flow so that packets belonging to that session will be allowed "
"through the firewall:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2426 /usr/src/sbin/ipfw/ipfw.8:2434
#, no-wrap
msgid "ipfw add check-state :OUTBOUND"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2427
#, no-wrap
msgid "ipfw add allow tcp from my-subnet to any setup keep-state :OUTBOUND"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2428 /usr/src/sbin/ipfw/ipfw.8:4114
#, no-wrap
msgid "ipfw add deny tcp from any to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2433
msgid ""
"A similar approach can be used for UDP, where an UDP packet coming from the "
"inside will install a dynamic rule to let the response through the firewall:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2435
#, no-wrap
msgid "ipfw add allow udp from my-subnet to any keep-state :OUTBOUND"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2436
#, no-wrap
msgid "ipfw add deny udp from any to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2448
msgid ""
"Dynamic rules expire after some time, which depends on the status of the "
"flow and the setting of some E<.Cm sysctl> variables.  See Section E<.Sx "
"SYSCTL VARIABLES> for more details.  For TCP sessions, dynamic rules can be "
"instructed to periodically send keepalive packets to refresh the state of "
"the rule when it is about to expire."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2452
msgid ""
"See Section E<.Sx EXAMPLES> for more examples on how to use dynamic rules."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:2452
#, no-wrap
msgid "TRAFFIC SHAPER (DUMMYNET) CONFIGURATION"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2460
msgid ""
"E<.Nm> is also the user interface for the E<.Nm dummynet> traffic shaper, "
"packet scheduler and network emulator, a subsystem that can artificially "
"queue, delay or drop packets emulating the behaviour of certain network "
"links or queueing systems."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2468
msgid ""
"E<.Nm dummynet> operates by first using the firewall to select packets using "
"any match pattern that can be used in E<.Nm> rules.  Matching packets are "
"then passed to either of two different objects, which implement the traffic "
"regulation:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2469
#, no-wrap
msgid "Em pipe"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2480
msgid ""
"A E<.Em pipe> emulates a E<.Em link> with given bandwidth and propagation "
"delay, driven by a FIFO scheduler and a single queue with programmable queue "
"size and packet loss rate.  Packets are appended to the queue as they come "
"out from E<.Nm ipfw>, and then transferred in FIFO order to the link at the "
"desired rate."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2480
#, no-wrap
msgid "Em queue"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2497
msgid ""
"A E<.Em queue> is an abstraction used to implement packet scheduling using "
"one of several packet scheduling algorithms.  Packets sent to a E<.Em queue> "
"are first grouped into flows according to a mask on the 5-tuple.  Flows are "
"then passed to the scheduler associated to the E<.Em queue>, and each flow "
"uses scheduling parameters (weight and others)  as configured in the E<.Em "
"queue> itself.  A scheduler in turn is connected to an emulated link, and "
"arbitrates the link's bandwidth among backlogged flows according to weights "
"and to the features of the scheduling algorithm in use."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2504
msgid ""
"In practice, E<.Em pipes> can be used to set hard limits to the bandwidth "
"that a flow can use, whereas E<.Em queues> can be used to determine how "
"different flows share the available bandwidth."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2507
msgid ""
"A graphical representation of the binding of queues, flows, schedulers and "
"links is below."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2521
#, no-wrap
msgid ""
"                 (flow_mask|sched_mask)  sched_mask\n"
"         +---------+   weight Wx  +-------------+\n"
"         |         |-E<gt>-[flow]--E<gt>--|             |-+\n"
"    --E<gt>--| QUEUE x |   ...        |             | |\n"
"         |         |-E<gt>-[flow]--E<gt>--| SCHEDuler N | |\n"
"         +---------+              |             | |\n"
"             ...                  |             +--[LINK N]--E<gt>--\n"
"         +---------+   weight Wy  |             | +--[LINK N]--E<gt>--\n"
"         |         |-E<gt>-[flow]--E<gt>--|             | |\n"
"    --E<gt>--| QUEUE y |   ...        |             | |\n"
"         |         |-E<gt>-[flow]--E<gt>--|             | |\n"
"         +---------+              +-------------+ |\n"
"                                    +-------------+\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2524
msgid ""
"It is important to understand the role of the SCHED_MASK and FLOW_MASK, "
"which are configured through the commands"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2524
#, no-wrap
msgid "ipfw sched N config mask SCHED_MASK ..."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2526
msgid "and"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2526
#, no-wrap
msgid "\"ipfw queue X config mask FLOW_MASK ...\" ."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2533
msgid ""
"The SCHED_MASK is used to assign flows to one or more scheduler instances, "
"one for each value of the packet's 5-tuple after applying SCHED_MASK.  As an "
"example, using ``src-ip 0xffffff00'' creates one instance for each /24 "
"destination subnet."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2542
msgid ""
"The FLOW_MASK, together with the SCHED_MASK, is used to split packets into "
"flows.  As an example, using ``src-ip 0x000000ff'' together with the "
"previous SCHED_MASK makes a flow for each individual source address.  In "
"turn, flows for each /24 subnet will be sent to the same scheduler instance."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2552
msgid ""
"The above diagram holds even for the E<.Em pipe> case, with the only "
"restriction that a E<.Em pipe> only supports a SCHED_MASK, and forces the "
"use of a FIFO scheduler (these are for backward compatibility reasons; in "
"fact, internally, a E<.Nm dummynet's> pipe is implemented exactly as above)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2583
msgid ""
"There are two modes of E<.Nm dummynet> operation: E<.Dq normal> and E<.Dq "
"fast>.  The E<.Dq normal> mode tries to emulate a real link: the E<.Nm "
"dummynet> scheduler ensures that the packet will not leave the pipe faster "
"than it would on the real link with a given bandwidth.  The E<.Dq fast> mode "
"allows certain packets to bypass the E<.Nm dummynet> scheduler (if packet "
"flow does not exceed pipe's bandwidth).  This is the reason why the E<.Dq "
"fast> mode requires less CPU cycles per packet (on average) and packet "
"latency can be significantly lower in comparison to a real link with the "
"same bandwidth.  The default mode is E<.Dq normal>.  The E<.Dq fast> mode "
"can be enabled by setting the E<.Va net.inet.ip.dummynet.io_fast> E<.Xr "
"sysctl 8> variable to a non-zero value."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:2584
#, no-wrap
msgid "PIPE, QUEUE AND SCHEDULER CONFIGURATION"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2591
msgid ""
"The E<.Em pipe>, E<.Em queue> and E<.Em scheduler> configuration commands "
"are the following:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2593
#, no-wrap
msgid "E<.Cm pipe Ar number Cm config Ar pipe-configuration>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2595
#, no-wrap
msgid "E<.Cm queue Ar number Cm config Ar queue-configuration>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2597
#, no-wrap
msgid "E<.Cm sched Ar number Cm config Ar sched-configuration>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2600
msgid "The following parameters can be configured for a pipe:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2602
#, no-wrap
msgid "Cm bw Ar bandwidth | device"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2608
msgid ""
"Bandwidth, measured in E<.Sm off> E<.Op Cm K | M | G> E<.Brq Cm bit/s | Byte/"
"s>.  E<.Sm on>"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2611
msgid ""
"A value of 0 (default) means unlimited bandwidth.  The unit must immediately "
"follow the number, as in"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2612
#, no-wrap
msgid "ipfw pipe 1 config bw 300Kbit/s"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2615
msgid "If a device name is specified instead of a numeric value, as in"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:2616
#, no-wrap
msgid "ipfw pipe 1 config bw tun0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2624
msgid ""
"then the transmit clock is supplied by the specified device.  At the moment "
"only the E<.Xr tun 4> device supports this functionality, for use in "
"conjunction with E<.Xr ppp 8>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2625
#, no-wrap
msgid "Cm delay Ar ms-delay"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2634
msgid ""
"Propagation delay, measured in milliseconds.  The value is rounded to the "
"next multiple of the clock tick (typically 10ms, but it is a good practice "
"to run kernels with E<.Dq \"options HZ=1000\"> to reduce the granularity to "
"1ms or less).  The default value is 0, meaning no delay."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2635
#, no-wrap
msgid "Cm burst Ar size"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2653
msgid ""
"If the data to be sent exceeds the pipe's bandwidth limit (and the pipe was "
"previously idle), up to E<.Ar size> bytes of data are allowed to bypass the "
"E<.Nm dummynet> scheduler, and will be sent as fast as the physical link "
"allows.  Any additional data will be transmitted at the rate specified by "
"the E<.Nm pipe> bandwidth.  The burst size depends on how long the pipe has "
"been idle; the effective burst size is calculated as follows: MAX( E<.Ar "
"size> , E<.Nm bw> * pipe_idle_time)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2654
#, no-wrap
msgid "Cm profile Ar filename"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2657
msgid ""
"A file specifying the additional overhead incurred in the transmission of a "
"packet on the link."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2668
msgid ""
"Some link types introduce extra delays in the transmission of a packet, e.g."
", because of MAC level framing, contention on the use of the channel, MAC "
"level retransmissions and so on.  From our point of view, the channel is "
"effectively unavailable for this extra time, which is constant or variable "
"depending on the link type.  Additionally, packets may be dropped after this "
"time (e.g., on a wireless link after too many retransmissions).  We can "
"model the additional delay with an empirical curve that represents its "
"distribution."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2681
#, no-wrap
msgid ""
"      cumulative probability\n"
"      1.0 ^\n"
"          |\n"
"      L   +-- loss-level          x\n"
"          |                 ******\n"
"          |                *\n"
"          |           *****\n"
"          |          *\n"
"          |        **\n"
"          |       *\n"
"          +-------*-------------------E<gt>\n"
"                      delay\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2688
msgid ""
"The empirical curve may have both vertical and horizontal lines.  Vertical "
"lines represent constant delay for a range of probabilities.  Horizontal "
"lines correspond to a discontinuity in the delay distribution: the pipe will "
"use the largest delay for a given probability."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2691
msgid ""
"The file format is the following, with whitespace acting as a separator and "
"'#' indicating the beginning a comment:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2692
#, no-wrap
msgid "Cm name Ar identifier"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2695
msgid ""
"optional name (listed by \"ipfw pipe show\")  to identify the delay "
"distribution;"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2695
#, no-wrap
msgid "Cm bw Ar value"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2699
msgid ""
"the bandwidth used for the pipe.  If not specified here, it must be present "
"explicitly as a configuration parameter for the pipe;"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2699
#, no-wrap
msgid "Cm loss-level Ar L"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2702
msgid ""
"the probability above which packets are lost.  (0.0 E<lt>= L E<lt>= 1.0, "
"default 1.0 i.e., no loss);"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2702
#, no-wrap
msgid "Cm samples Ar N"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2705
msgid ""
"the number of samples used in the internal representation of the curve (2.."
"1024; default 100);"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2705
#, no-wrap
msgid "Cm \"delay prob\" | \"prob delay\""
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2708
msgid ""
"One of these two lines is mandatory and defines the format of the following "
"lines with data points."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2708
#, no-wrap
msgid "Ar XXX Ar YYY"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2719
msgid ""
"2 or more lines representing points in the curve, with either delay or "
"probability first, according to the chosen format.  The unit for delay is "
"milliseconds.  Data points do not need to be sorted.  Also, the number of "
"actual lines can be different from the value of the \"samples\" parameter: "
"E<.Nm> utility will sort and interpolate the curve as needed."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2722
msgid "Example of a profile file:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2734
#, no-wrap
msgid ""
"name    bla_bla_bla\n"
"samples 100\n"
"loss-level    0.86\n"
"prob    delay\n"
"0       200\t# minimum overhead is 200ms\n"
"0.5     200\n"
"0.5     300\n"
"0.8     1000\n"
"0.9     1300\n"
"1       1300\n"
"#configuration file end\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2738
msgid "The following parameters can be configured for a queue:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2744
msgid ""
"Connects a queue to the specified pipe.  Multiple queues (with the same or "
"different weights) can be connected to the same pipe, which specifies the "
"aggregate rate for the set of queues."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2745
#, no-wrap
msgid "Cm weight Ar weight"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2748
msgid ""
"Specifies the weight to be used for flows matching this queue.  The weight "
"must be in the range 1..100, and defaults to 1."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2752
msgid ""
"The following case-insensitive parameters can be configured for a scheduler:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2754
#, no-wrap
msgid "Cm type Ar {fifo | wf2q+ | rr | qfq | fq_codel | fq_pie}"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2756
msgid "specifies the scheduling algorithm to use."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2757
#, no-wrap
msgid "Cm fifo"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2763
msgid ""
"is just a FIFO scheduler (which means that all packets are stored in the "
"same queue as they arrive to the scheduler).  FIFO has O(1) per-packet time "
"complexity, with very low constants (estimate 60-80ns on a 2GHz desktop "
"machine)  but gives no service guarantees."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2763
#, no-wrap
msgid "Cm wf2q+"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2772
msgid ""
"implements the WF2Q+ algorithm, which is a Weighted Fair Queueing algorithm "
"which permits flows to share bandwidth according to their weights.  Note "
"that weights are not priorities; even a flow with a minuscule weight will "
"never starve.  WF2Q+ has O(log N) per-packet processing cost, where N is the "
"number of flows, and is the default algorithm used by previous versions "
"dummynet's queues."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2772
#, no-wrap
msgid "Cm rr"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2777
msgid ""
"implements the Deficit Round Robin algorithm, which has O(1) processing "
"costs (roughly, 100-150ns per packet)  and permits bandwidth allocation "
"according to weights, but with poor service guarantees."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2777
#, no-wrap
msgid "Cm qfq"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2781
msgid ""
"implements the QFQ algorithm, which is a very fast variant of WF2Q+, with "
"similar service guarantees and O(1) processing costs (roughly, 200-250ns per "
"packet)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2781
#, no-wrap
msgid "Cm fq_codel"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2789
msgid ""
"implements the FQ-CoDel (FlowQueue-CoDel) scheduler/AQM algorithm, which "
"uses a modified Deficit Round Robin scheduler to manage two lists of sub-"
"queues (old sub-queues and new sub-queues) for providing brief periods of "
"priority to lightweight or short burst flows.  By default, the total number "
"of sub-queues is 1024.  FQ-CoDel's internal, dynamically created sub-queues "
"are controlled by separate instances of CoDel AQM."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2789
#, no-wrap
msgid "Cm fq_pie"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2793
msgid ""
"implements the FQ-PIE (FlowQueue-PIE) scheduler/AQM algorithm, which similar "
"to E<.Cm fq_codel> but uses per sub-queue PIE AQM instance to control the "
"queue delay."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2808
msgid ""
"E<.Cm fq_codel> inherits AQM parameters and options from E<.Cm codel> (see "
"below), and E<.Cm fq_pie> inherits AQM parameters and options from E<.Cm "
"pie> (see below).  Additionally, both of E<.Cm fq_codel> and E<.Cm fq_pie> "
"have shared scheduler parameters which are:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2809
#, no-wrap
msgid "Cm quantum"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2817
msgid ""
"E<.Ar m> specifies the quantum (credit) of the scheduler.  E<.Ar m> is the "
"number of bytes a queue can serve before being moved to the tail of old "
"queues list.  The default is 1514 bytes, and the maximum acceptable value is "
"9000 bytes."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2824
msgid ""
"E<.Ar m> specifies the hard size limit (in unit of packets) of all queues "
"managed by an instance of the scheduler.  The default value of E<.Ar m> is "
"10240 packets, and the maximum acceptable value is 20480 packets."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2824
#, no-wrap
msgid "Cm flows"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2832
msgid ""
"E<.Ar m> specifies the total number of flow queues (sub-queues) that fq_* "
"creates and manages.  By default, 1024 sub-queues are created when an "
"instance of the fq_{codel/pie} scheduler is created.  The maximum acceptable "
"value is 65536."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2843
msgid ""
"Note that any token after E<.Cm fq_codel> or E<.Cm fq_pie> is considered a "
"parameter for fq_{codel/pie}.  So, ensure all scheduler configuration "
"options not related to fq_{codel/pie} are written before E<.Cm fq_codel/"
"fq_pie> tokens."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2847
msgid ""
"In addition to the type, all parameters allowed for a pipe can also be "
"specified for a scheduler."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2850
msgid ""
"Finally, the following parameters can be configured for both pipes and "
"queues:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2852
#, no-wrap
msgid "Cm buckets Ar hash-table-size"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2860
msgid ""
"Specifies the size of the hash table used for storing the various queues.  "
"Default value is 64 controlled by the E<.Xr sysctl 8> variable E<.Va net."
"inet.ip.dummynet.hash_size>, allowed range is 16 to 65536."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2861
#, no-wrap
msgid "Cm mask Ar mask-specifier"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2875
msgid ""
"Packets sent to a given pipe or queue by an E<.Nm> rule can be further "
"classified into multiple flows, each of which is then sent to a different E<."
"Em dynamic> pipe or queue.  A flow identifier is constructed by masking the "
"IP addresses, ports and protocol types as specified with the E<.Cm mask> "
"options in the configuration of the pipe or queue.  For each different flow "
"identifier, a new pipe or queue is created with the same parameters as the "
"original object, and matching packets are sent to it."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2884
msgid ""
"Thus, when E<.Em dynamic pipes> are used, each flow will get the same "
"bandwidth as defined by the pipe, whereas when E<.Em dynamic queues> are "
"used, each flow will share the parent's pipe bandwidth evenly with other "
"flows generated by the same queue (note that other queues with different "
"weights might be connected to the same pipe)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2886
msgid ""
"Available mask specifiers are a combination of one or more of the following:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2897
msgid ""
"E<.Cm dst-ip Ar mask>, E<.Cm dst-ip6 Ar mask>, E<.Cm src-ip Ar mask>, E<.Cm "
"src-ip6 Ar mask>, E<.Cm dst-port Ar mask>, E<.Cm src-port Ar mask>, E<.Cm "
"flow-id Ar mask>, E<.Cm proto Ar mask> or E<.Cm all>,"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2899
msgid "where the latter means all bits in all fields are significant."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2900
#, no-wrap
msgid "Cm noerror"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2910
msgid ""
"When a packet is dropped by a E<.Nm dummynet> queue or pipe, the error is "
"normally reported to the caller routine in the kernel, in the same way as it "
"happens when a device queue fills up.  Setting this option reports the "
"packet as successfully delivered, which can be needed for some experimental "
"setups where you want to simulate loss or congestion at a remote router."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2911
#, no-wrap
msgid "Cm plr Ar packet-loss-rate"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2918
msgid ""
"Packet loss rate.  Argument E<.Ar packet-loss-rate> is a floating-point "
"number between 0 and 1, with 0 meaning no loss, 1 meaning 100% loss.  The "
"loss rate is internally represented on 31 bits."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2919
#, no-wrap
msgid "Cm queue Brq Ar slots | size Ns Cm Kbytes"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2941
msgid ""
"Queue size, in E<.Ar slots> or E<.Cm KBytes>.  Default value is 50 slots, "
"which is the typical queue size for Ethernet devices.  Note that for slow "
"speed links you should keep the queue size short or your traffic might be "
"affected by a significant queueing delay.  E.g., 50 max-sized Ethernet "
"packets (1500 bytes) mean 600Kbit or 20s of queue on a 30Kbit/s pipe.  Even "
"worse effects can result if you get packets from an interface with a much "
"larger MTU, e.g.\\& the loopback interface with its 16KB packets.  The E<.Xr "
"sysctl 8> variables E<.Em net.inet.ip.dummynet.pipe_byte_limit> and E<.Em "
"net.inet.ip.dummynet.pipe_slot_limit> control the maximum lengths that can "
"be specified."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2942
#, no-wrap
msgid ""
"Cm red | gred Ar w_q Ns / Ns Ar min_th Ns / Ns Ar max_th Ns / Ns Ar max_p"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2962
msgid ""
"[ecn] Make use of the RED (Random Early Detection) queue management "
"algorithm.  E<.Ar w_q> and E<.Ar max_p> are floating point numbers between 0 "
"and 1 (inclusive), while E<.Ar min_th> and E<.Ar max_th> are integer numbers "
"specifying thresholds for queue management (thresholds are computed in bytes "
"if the queue has been defined in bytes, in slots otherwise).  The two "
"parameters can also be of the same value if needed. The E<.Nm dummynet> also "
"supports the gentle RED variant (gred) and ECN (Explicit Congestion "
"Notification) as optional. Three E<.Xr sysctl 8> variables can be used to "
"control the RED behaviour:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2963
#, no-wrap
msgid "Va net.inet.ip.dummynet.red_lookup_depth"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2966
msgid ""
"specifies the accuracy in computing the average queue when the link is idle "
"(defaults to 256, must be greater than zero)"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2966
#, no-wrap
msgid "Va net.inet.ip.dummynet.red_avg_pkt_size"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2969
msgid ""
"specifies the expected average packet size (defaults to 512, must be greater "
"than zero)"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2969
#, no-wrap
msgid "Va net.inet.ip.dummynet.red_max_pkt_size"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:2972
msgid ""
"specifies the expected maximum packet size, only used when queue thresholds "
"are in bytes (defaults to 1500, must be greater than zero)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:2974
#, no-wrap
msgid "Cm codel Oo Cm target Ar time Oc Oo Cm interval Ar time Oc Oo Cm ecn |"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3000
msgid ""
"E<.Cm noecn Oc> Make use of the CoDel (Controlled-Delay) queue management "
"algorithm.  E<.Ar time> is interpreted as milliseconds by default but "
"seconds (s), milliseconds (ms) or microseconds (us) can be specified instead."
"  CoDel drops or marks (ECN) packets depending on packet sojourn time in the "
"queue.  E<.Cm target> E<.Ar time> (5ms by default) is the minimum acceptable "
"persistent queue delay that CoDel allows.  CoDel does not drop packets "
"directly after packets sojourn time becomes higher than E<.Cm target> E<.Ar "
"time> but waits for E<.Cm interval> E<.Ar time> (100ms default) before "
"dropping.  E<.Cm interval> E<.Ar time> should be set to maximum RTT for all "
"expected connections.  E<.Cm ecn> enables (disabled by default) packet "
"marking (instead of dropping) for ECN-enabled TCP flows when queue delay "
"becomes high."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3008
msgid ""
"Note that any token after E<.Cm codel> is considered a parameter for CoDel.  "
"So, ensure all pipe/queue configuration options are written before E<.Cm "
"codel> token."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3016
msgid ""
"The E<.Xr sysctl 8> variables E<.Va net.inet.ip.dummynet.codel.target> and "
"E<.Va net.inet.ip.dummynet.codel.interval> can be used to set CoDel default "
"parameters."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3017
#, no-wrap
msgid "Cm pie Oo Cm target Ar time Oc Oo Cm tupdate Ar time Oc Oo"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3042
msgid ""
"E<.Cm alpha Ar n Oc Oo Cm beta Ar n Oc Oo Cm max_burst Ar time Oc Oo> E<.Cm "
"max_ecnth Ar n Oc Oo Cm ecn | Cm noecn Oc Oo Cm capdrop |> E<.Cm nocapdrop "
"Oc Oo Cm drand | Cm nodrand Oc Oo Cm onoff> E<.Oc Oo Cm dre | Cm ts Oc> Make "
"use of the PIE (Proportional Integral controller Enhanced) queue management "
"algorithm.  PIE drops or marks packets depending on a calculated drop "
"probability during en-queue process, with the aim of achieving high "
"throughput while keeping queue delay low.  At regular time intervals of E<."
"Cm tupdate> E<.Ar time> (15ms by default) a background process "
"(re)calculates the probability based on queue delay deviations from E<.Cm "
"target> E<.Ar time> (15ms by default) and queue delay trends.  PIE "
"approximates current queue delay by using a departure rate estimation "
"method, or (optionally) by using a packet timestamp method similar to CoDel. "
" E<.Ar time> is interpreted as milliseconds by default but seconds (s), "
"milliseconds (ms) or microseconds (us) can be specified instead.  The other "
"PIE parameters and options are as follows:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3043
#, no-wrap
msgid "Cm alpha Ar n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3048
msgid ""
"E<.Ar n> is a floating point number between 0 and 7 which specifies the "
"weight of queue delay deviations that is used in drop probability "
"calculation.  0.125 is the default."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3048
#, no-wrap
msgid "Cm beta Ar n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3053
msgid ""
"E<.Ar n> is a floating point number between 0 and 7 which specifies is the "
"weight of queue delay trend that is used in drop probability calculation.  1."
"25 is the default."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3053
#, no-wrap
msgid "Cm max_burst Ar time"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3057
msgid ""
"The maximum period of time that PIE does not drop/mark packets.  150ms is "
"the default and 10s is the maximum value."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3057
#, no-wrap
msgid "Cm max_ecnth Ar n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3062
msgid ""
"Even when ECN is enabled, PIE drops packets instead of marking them when "
"drop probability becomes higher than ECN probability threshold E<.Cm "
"max_ecnth Ar n> , the default is 0.1 (i.e 10%) and 1 is the maximum value."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3062
#, no-wrap
msgid "Cm ecn | noecn"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3065
msgid ""
"enable or disable ECN marking for ECN-enabled TCP flows.  Disabled by "
"default."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3065
#, no-wrap
msgid "Cm capdrop | nocapdrop"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3068
msgid ""
"enable or disable cap drop adjustment.  Cap drop adjustment is enabled by "
"default."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3068
#, no-wrap
msgid "Cm drand | nodrand"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3073
msgid ""
"enable or disable drop probability de-randomisation.  De-randomisation "
"eliminates the problem of dropping packets too close or too far.  De-"
"randomisation is enabled by default."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3073
#, no-wrap
msgid "Cm onoff"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3079
msgid ""
"enable turning PIE on and off depending on queue load.  If this option is "
"enabled, PIE turns on when over 1/3 of queue becomes full.  This option is "
"disabled by default."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3079
#, no-wrap
msgid "Cm dre | ts"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3086
msgid ""
"Calculate queue delay using departure rate estimation E<.Cm dre> or "
"timestamps E<.Cm ts>.  E<.Cm dre> is used by default."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3102
msgid ""
"Note that any token after E<.Cm pie> is considered a parameter for PIE.  So "
"ensure all pipe/queue the configuration options are written before E<.Cm "
"pie> token.  E<.Xr sysctl 8> variables can be used to control the E<.Cm pie> "
"default parameters.  See the E<.Sx SYSCTL VARIABLES> section for more "
"details."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3113
msgid ""
"When used with IPv6 data, E<.Nm dummynet> currently has several limitations. "
" Information necessary to route link-local packets to an interface is not "
"available after processing by E<.Nm dummynet> so those packets are dropped "
"in the output path.  Care should be taken to ensure that link-local packets "
"are not passed to E<.Nm dummynet>."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:3113
#, no-wrap
msgid "CHECKLIST"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3116
msgid "Here are some important points to consider when designing your rules:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3123
msgid ""
"Remember that you filter both packets going E<.Cm in> and E<.Cm out>.  Most "
"connections need packets going in both directions."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3129
msgid ""
"Remember to test very carefully.  It is a good idea to be near the console "
"when doing this.  If you cannot be near the console, use an auto-recovery "
"script such as the one in E<.Pa /usr/share/examples/ipfw/change_rules.sh>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3131
msgid "Do not forget the loopback interface."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:3132
#, no-wrap
msgid "FINE POINTS"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3146
msgid ""
"There are circumstances where fragmented datagrams are unconditionally "
"dropped.  TCP packets are dropped if they do not contain at least 20 bytes "
"of TCP header, UDP packets are dropped if they do not contain a full 8 byte "
"UDP header, and ICMP packets are dropped if they do not contain 4 bytes of "
"ICMP header, enough to specify the ICMP type, code, and checksum.  These "
"packets are simply logged as E<.Dq pullup failed> since there may not be "
"enough good data in the packet to produce a meaningful log entry."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3153
msgid ""
"Another type of packet is unconditionally dropped, a TCP packet with a "
"fragment offset of one.  This is a valid packet, but it only has one use, to "
"try to circumvent firewalls.  When logging is enabled, these packets are "
"reported as being dropped by rule -1."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3160
msgid ""
"If you are logged in over a network, loading the E<.Xr kld 4> version of E<."
"Nm> is probably not as straightforward as you would think.  The following "
"command line is recommended:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3163
#, no-wrap
msgid "kldload ipfw && \\e\n"
"ipfw add 32000 allow ip from any to any\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3166
msgid "Along the same lines, doing an"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3168
#, no-wrap
msgid "ipfw flush\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3171
msgid "in similar surroundings is also a bad idea."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3179
msgid ""
"The E<.Nm> filter list may not be modified if the system security level is "
"set to 3 or higher (see E<.Xr init 8> for information on system security "
"levels)."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:3180
#, no-wrap
msgid "PACKET DIVERSION"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3188
msgid ""
"A E<.Xr divert 4> socket bound to the specified port will receive all "
"packets diverted to that port.  If no socket is bound to the destination "
"port, or if the divert module is not loaded, or if the kernel was not "
"compiled with divert socket support, the packets are dropped."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:3188
#, no-wrap
msgid "NETWORK ADDRESS TRANSLATION (NAT)"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3197
msgid ""
"E<.Nm> support in-kernel NAT using the kernel version of E<.Xr libalias 3>.  "
"The kernel module E<.Cm ipfw_nat> should be loaded or kernel should have E<."
"Cm options IPFIREWALL_NAT> to be able use NAT."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3199
msgid "The nat configuration command is the following:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3206
#, no-wrap
msgid ""
"E<.Bk -words>\n"
"E<.Cm nat>\n"
"E<.Ar nat_number>\n"
"E<.Cm config>\n"
"E<.Ar nat-configuration>\n"
"E<.Ek>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3209 /usr/src/sbin/ipfw/ipfw.8:3359 /usr/src/sbin/ipfw/ipfw.8:3481 /usr/src/sbin/ipfw/ipfw.8:3535 /usr/src/sbin/ipfw/ipfw.8:3585
msgid "The following parameters can be configured:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3210
#, no-wrap
msgid "Cm ip Ar ip_address"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3212
msgid "Define an ip address to use for aliasing."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3212
#, no-wrap
msgid "Cm if Ar nic"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3215
msgid ""
"Use ip address of NIC for aliasing, dynamically changing it if NIC's ip "
"address changes."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3215 /usr/src/sbin/ipfw/ipfw.8:3427 /usr/src/sbin/ipfw/ipfw.8:3493 /usr/src/sbin/ipfw/ipfw.8:3543
#, no-wrap
msgid "Cm log"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3217
msgid "Enable logging on this nat instance."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3217
#, no-wrap
msgid "Cm deny_in"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3219
msgid "Deny any incoming connection from outside world."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3219
#, no-wrap
msgid "Cm same_ports"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3222
msgid ""
"Try to leave the alias port numbers unchanged from the actual local port "
"numbers."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3222
#, no-wrap
msgid "Cm unreg_only"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3225
msgid ""
"Traffic on the local network not originating from an unregistered address "
"spaces will be ignored."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3227
msgid "Reset table of the packet aliasing engine on address change."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3227
#, no-wrap
msgid "Cm reverse"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3229
msgid "Reverse the way libalias handles aliasing."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3229
#, no-wrap
msgid "Cm proxy_only"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3231
msgid "Obey transparent proxy rules only, packet aliasing is not performed."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3231
#, no-wrap
msgid "Cm skip_global"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3233
msgid "Skip instance in case of global state lookup (see below)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3237
msgid "Some specials value can be supplied instead of E<.Va nat_number:>"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3238
#, no-wrap
msgid "Cm global"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3248
msgid ""
"Looks up translation state in all configured nat instances.  If an entry is "
"found, packet is aliased according to that entry.  If no entry was found in "
"any of the instances, packet is passed unchanged, and no new entry will be "
"created.  See section E<.Sx MULTIPLE INSTANCES> in E<.Xr natd 8> for more "
"information."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3248
#, no-wrap
msgid "Cm tablearg"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3253
msgid ""
"Uses argument supplied in lookup table.  See E<.Sx LOOKUP TABLES> section "
"below for more information on lookup tables."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3263
msgid ""
"To let the packet continue after being (de)aliased, set the sysctl variable "
"E<.Va net.inet.ip.fw.one_pass> to 0.  For more information about aliasing "
"modes, refer to E<.Xr libalias 3>.  See Section E<.Sx EXAMPLES> for some "
"examples about nat usage."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:3263
#, no-wrap
msgid "REDIRECT AND LSNAT SUPPORT IN IPFW"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3269
msgid ""
"Redirect and LSNAT support follow closely the syntax used in E<.Xr natd 8>.  "
"See Section E<.Sx EXAMPLES> for some examples on how to do redirect and "
"lsnat."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:3269
#, no-wrap
msgid "SCTP NAT SUPPORT"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3279
msgid ""
"SCTP nat can be configured in a similar manner to TCP through the E<.Nm> "
"command line tool.  The main difference is that E<.Nm sctp nat> does not do "
"port translation.  Since the local and global side ports will be the same, "
"there is no need to specify both.  Ports are redirected as follows:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3288
#, no-wrap
msgid ""
"E<.Bk -words>\n"
"E<.Cm nat>\n"
"E<.Ar nat_number>\n"
"E<.Cm config if>\n"
"E<.Ar nic>\n"
"E<.Cm redirect_port sctp>\n"
"E<.Ar ip_address [,addr_list] {[port | port-port] [,ports]}>\n"
"E<.Ek>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3302
msgid ""
"Most E<.Nm sctp nat> configuration can be done in real-time through the E<."
"Xr sysctl 8> interface.  All may be changed dynamically, though the "
"hash_table size will only change for new E<.Nm nat> instances.  See E<.Sx "
"SYSCTL VARIABLES> for more info."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:3302
#, no-wrap
msgid "IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION"
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:3303
#, no-wrap
msgid "Stateful translation"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3317
msgid ""
"E<.Nm> supports in-kernel IPv6/IPv4 network address and protocol translation."
"  Stateful NAT64 translation allows IPv6-only clients to contact IPv4 "
"servers using unicast TCP, UDP or ICMP protocols.  One or more IPv4 "
"addresses assigned to a stateful NAT64 translator are shared among several "
"IPv6-only clients.  When stateful NAT64 is used in conjunction with DNS64, "
"no changes are usually required in the IPv6 client or the IPv4 server.  The "
"kernel module E<.Cm ipfw_nat64> should be loaded or kernel should have E<.Cm "
"options IPFIREWALL_NAT64> to be able use stateful NAT64 translator."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3325
msgid ""
"Stateful NAT64 uses a bunch of memory for several types of objects.  When "
"IPv6 client initiates connection, NAT64 translator creates a host entry in "
"the states table.  Each host entry uses preallocated IPv4 alias entry.  Each "
"alias entry has a number of ports group entries allocated on demand.  Ports "
"group entries contains connection state entries.  There are several options "
"to control limits and lifetime for these objects."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3333
msgid ""
"NAT64 translator follows RFC7915 when does ICMPv6/ICMP translation, "
"unsupported message types will be silently dropped.  IPv6 needs several "
"ICMPv6 message types to be explicitly allowed for correct operation.  Make "
"sure that ND6 neighbor solicitation (ICMPv6 type 135) and neighbor "
"advertisement (ICMPv6 type 136) messages will not be handled by translation "
"rules."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3347
msgid ""
"After translation NAT64 translator by default sends packets through "
"corresponding netisr queue.  Thus translator host should be configured as "
"IPv4 and IPv6 router.  Also this means, that a packet is handled by firewall "
"twice.  First time an original packet is handled and consumed by translator, "
"and then it is handled again as translated packet.  This behavior can be "
"changed by sysctl variable E<.Va net.inet.ip.fw.nat64_direct_output>.  Also "
"translated packet can be tagged using E<.Cm tag> rule action, and then "
"matched by E<.Cm tagged> opcode to avoid loops and extra overhead."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3349
msgid "The stateful NAT64 configuration command is the following:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3356
#, no-wrap
msgid ""
"E<.Bk -words>\n"
"E<.Cm nat64lsn>\n"
"E<.Ar name>\n"
"E<.Cm create>\n"
"E<.Ar create-options>\n"
"E<.Ek>\n"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3360
#, no-wrap
msgid "Cm prefix4 Ar ipv4_prefix/plen"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3368
msgid ""
"The IPv4 prefix with mask defines the pool of IPv4 addresses used as source "
"address after translation.  Stateful NAT64 module translates IPv6 source "
"address of client to one IPv4 address from this pool.  Note that incoming "
"IPv4 packets that don't have corresponding state entry in the states table "
"will be dropped by translator.  Make sure that translation rules handle "
"packets, destined to configured prefix."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3368 /usr/src/sbin/ipfw/ipfw.8:3482
#, no-wrap
msgid "Cm prefix6 Ar ipv6_prefix/length"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3379
msgid ""
"The IPv6 prefix defines IPv4-embedded IPv6 addresses used by translator to "
"represent IPv4 addresses. This IPv6 prefix should be configured in DNS64.  "
"The translator implementation follows RFC6052, that restricts the length of "
"prefixes to one of following: 32, 40, 48, 56, 64, or 96.  The Well-Known "
"IPv6 Prefix 64:ff9b:: must be 96 bits long.  The special E<.Ar ::/length> "
"prefix can be used to handle several IPv6 prefixes with one NAT64 instance.  "
"The NAT64 instance will determine a destination IPv4 address from prefix E<."
"Ar length>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3379
#, no-wrap
msgid "Cm states_chunks Ar number"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3384
msgid ""
"The number of states chunks in single ports group.  Each ports group by "
"default can keep 64 state entries in single chunk.  The above value affects "
"the maximum number of states that can be associated with single IPv4 alias "
"address and port.  The value must be power of 2, and up to 128."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3384
#, no-wrap
msgid "Cm host_del_age Ar seconds"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3389
msgid ""
"The number of seconds until the host entry for a IPv6 client will be deleted "
"and all its resources will be released due to inactivity.  Default value is "
"E<.Ar 3600>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3389
#, no-wrap
msgid "Cm pg_del_age Ar seconds"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3394
msgid ""
"The number of seconds until a ports group with unused state entries will be "
"released.  Default value is E<.Ar 900>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3394
#, no-wrap
msgid "Cm tcp_syn_age Ar seconds"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3401
msgid ""
"The number of seconds while a state entry for TCP connection with only SYN "
"sent will be kept.  If TCP connection establishing will not be finished, "
"state entry will be deleted.  Default value is E<.Ar 10>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3401
#, no-wrap
msgid "Cm tcp_est_age Ar seconds"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3406
msgid ""
"The number of seconds while a state entry for established TCP connection "
"will be kept.  Default value is E<.Ar 7200>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3406
#, no-wrap
msgid "Cm tcp_close_age Ar seconds"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3417
msgid ""
"The number of seconds while a state entry for closed TCP connection will be "
"kept.  Keeping state entries for closed connections is needed, because IPv4 "
"servers typically keep closed connections in a TIME_WAIT state for a several "
"minutes.  Since translator's IPv4 addresses are shared among all IPv6 "
"clients, new connections from the same addresses and ports may be rejected "
"by server, because these connections are still in a TIME_WAIT state.  "
"Keeping them in translator's state table protects from such rejects.  "
"Default value is E<.Ar 180>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3417
#, no-wrap
msgid "Cm udp_age Ar seconds"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3422
msgid ""
"The number of seconds while translator keeps state entry in a waiting for "
"reply to the sent UDP datagram.  Default value is E<.Ar 120>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3422
#, no-wrap
msgid "Cm icmp_age Ar seconds"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3427
msgid ""
"The number of seconds while translator keeps state entry in a waiting for "
"reply to the sent ICMP message.  Default value is E<.Ar 60>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3442
msgid ""
"Turn on logging of all handled packets via BPF through E<.Ar ipfwlog0> "
"interface.  E<.Ar ipfwlog0> is a pseudo interface and can be created after a "
"boot manually with E<.Cm ifconfig> command.  Note that it has different "
"purpose than E<.Ar ipfw0> interface.  Translators sends to BPF an additional "
"information with each packet.  With E<.Cm tcpdump> you are able to see each "
"handled packet before and after translation."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3442 /usr/src/sbin/ipfw/ipfw.8:3497 /usr/src/sbin/ipfw/ipfw.8:3547
#, no-wrap
msgid "Cm -log"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3444 /usr/src/sbin/ipfw/ipfw.8:3499 /usr/src/sbin/ipfw/ipfw.8:3549
msgid "Turn off logging of all handled packets via BPF."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3444 /usr/src/sbin/ipfw/ipfw.8:3499 /usr/src/sbin/ipfw/ipfw.8:3549
#, no-wrap
msgid "Cm allow_private"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3448 /usr/src/sbin/ipfw/ipfw.8:3503
msgid ""
"Turn on processing private IPv4 addresses. By default IPv6 packets with "
"destinations mapped to private address ranges defined by RFC1918 are not "
"processed."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3448 /usr/src/sbin/ipfw/ipfw.8:3503 /usr/src/sbin/ipfw/ipfw.8:3554
#, no-wrap
msgid "Cm -allow_private"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3452 /usr/src/sbin/ipfw/ipfw.8:3507
msgid "Turn off private address handling in E<.Nm nat64> instance."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3455
msgid ""
"To inspect a states table of stateful NAT64 the following command can be "
"used:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3461
#, no-wrap
msgid ""
"E<.Bk -words>\n"
"E<.Cm nat64lsn>\n"
"E<.Ar name>\n"
"E<.Cm show Cm states>\n"
"E<.Ek>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3469
msgid ""
"Stateless NAT64 translator doesn't use a states table for translation and "
"converts IPv4 addresses to IPv6 and vice versa solely based on the mappings "
"taken from configured lookup tables.  Since a states table doesn't used by "
"stateless translator, it can be configured to pass IPv4 clients to IPv6-only "
"servers."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3471
msgid "The stateless NAT64 configuration command is the following:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3478
#, no-wrap
msgid ""
"E<.Bk -words>\n"
"E<.Cm nat64stl>\n"
"E<.Ar name>\n"
"E<.Cm create>\n"
"E<.Ar create-options>\n"
"E<.Ek>\n"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3485
msgid ""
"The IPv6 prefix defines IPv4-embedded IPv6 addresses used by translator to "
"represent IPv4 addresses. This IPv6 prefix should be configured in DNS64."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3485
#, no-wrap
msgid "Cm table4 Ar table46"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3489
msgid ""
"The lookup table E<.Ar table46> contains mapping how IPv4 addresses should "
"be translated to IPv6 addresses."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3489
#, no-wrap
msgid "Cm table6 Ar table64"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3493
msgid ""
"The lookup table E<.Ar table64> contains mapping how IPv6 addresses should "
"be translated to IPv4 addresses."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3497 /usr/src/sbin/ipfw/ipfw.8:3547
msgid ""
"Turn on logging of all handled packets via BPF through E<.Ar ipfwlog0> "
"interface."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3513
msgid ""
"Note that the behavior of stateless translator with respect to not matched "
"packets differs from stateful translator.  If corresponding addresses was "
"not found in the lookup tables, the packet will not be dropped and the "
"search continues."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:3515
#, no-wrap
msgid "XLAT464 CLAT translation"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3523
msgid ""
"XLAT464 CLAT NAT64 translator implements client-side stateless translation "
"as defined in RFC6877 and is very similar to statless NAT64 translator "
"explained above. Instead of lookup tables it uses one-to-one mapping between "
"IPv4 and IPv6 addresses using configured prefixes.  This mode can be used as "
"a replacement of DNS64 service for applications that are not using it (e.g. "
"VoIP) allowing them to access IPv4-only Internet over IPv6-only networks "
"with help of remote NAT64 translator."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3525
msgid "The CLAT NAT64 configuration command is the following:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3532
#, no-wrap
msgid ""
"E<.Bk -words>\n"
"E<.Cm nat64clat>\n"
"E<.Ar name>\n"
"E<.Cm create>\n"
"E<.Ar create-options>\n"
"E<.Ek>\n"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3536
#, no-wrap
msgid "Cm clat_prefix Ar ipv6_prefix/length"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3539
msgid ""
"The IPv6 prefix defines IPv4-embedded IPv6 addresses used by translator to "
"represent source IPv4 addresses."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3539
#, no-wrap
msgid "Cm plat_prefix Ar ipv6_prefix/length"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3543
msgid ""
"The IPv6 prefix defines IPv4-embedded IPv6 addresses used by translator to "
"represent destination IPv4 addresses. This IPv6 prefix should be configured "
"on a remote NAT64 translator."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3554
msgid ""
"Turn on processing private IPv4 addresses. By default E<.Nm nat64clat> "
"instance will not process IPv4 packets with destination address from private "
"ranges as defined in RFC1918."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3558
msgid "Turn off private address handling in E<.Nm nat64clat> instance."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3564
msgid ""
"Note that the behavior of CLAT translator with respect to not matched "
"packets differs from stateful translator.  If corresponding addresses were "
"not matched against prefixes configured, the packet will not be dropped and "
"the search continues."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:3564
#, no-wrap
msgid "IPv6-to-IPv6 NETWORK PREFIX TRANSLATION (NPTv6)"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3573
msgid ""
"E<.Nm> supports in-kernel IPv6-to-IPv6 network prefix translation as "
"described in RFC6296.  The kernel module E<.Cm ipfw_nptv6> should be loaded "
"or kernel should has E<.Cm options IPFIREWALL_NPTV6> to be able use NPTv6 "
"translator."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3575
msgid "The NPTv6 configuration command is the following:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3582
#, no-wrap
msgid ""
"E<.Bk -words>\n"
"E<.Cm nptv6>\n"
"E<.Ar name>\n"
"E<.Cm create>\n"
"E<.Ar create-options>\n"
"E<.Ek>\n"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3586
#, no-wrap
msgid "Cm int_prefix Ar ipv6_prefix"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3589
msgid ""
"IPv6 prefix used in internal network.  NPTv6 module translates source "
"address when it matches this prefix."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3589
#, no-wrap
msgid "Cm ext_prefix Ar ipv6_prefix"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3592
msgid ""
"IPv6 prefix used in external network.  NPTv6 module translates destination "
"address when it matches this prefix."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3592
#, no-wrap
msgid "Cm ext_if Ar nic"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3601
msgid ""
"The NPTv6 module will use first global IPv6 address from interface E<.Ar "
"nic> as external prefix.  It can be useful when IPv6 prefix of external "
"network is dynamically obtained.  E<.Cm ext_prefix> and E<.Cm ext_if> "
"options are mutually exclusive."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3601
#, no-wrap
msgid "Cm prefixlen Ar length"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3603
msgid ""
"The length of specified IPv6 prefixes. It must be in range from 8 to 64."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3610
msgid ""
"Note that the prefix translation rules are silently ignored when IPv6 packet "
"forwarding is disabled.  To enable the packet forwarding, set the sysctl "
"variable E<.Va net.inet6.ip6.forwarding> to 1."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3614
msgid ""
"To let the packet continue after being translated, set the sysctl variable "
"E<.Va net.inet.ip.fw.one_pass> to 0."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:3614
#, no-wrap
msgid "LOADER TUNABLES"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3622
msgid ""
"Tunables can be set in E<.Xr loader 8> prompt, E<.Xr loader.conf 5> or E<.Xr "
"kenv 1> before ipfw module gets loaded."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3623
#, no-wrap
msgid "Va net.inet.ip.fw.default_to_accept: No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3628
msgid ""
"Defines ipfw last rule behavior.  This value overrides E<.Cd \"options "
"IPFW_DEFAULT_TO_(ACCEPT|DENY)\"> from kernel configuration file."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3628
#, no-wrap
msgid "Va net.inet.ip.fw.tables_max: No 128"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3631
msgid ""
"Defines number of tables available in ipfw.  Number cannot exceed 65534."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:3632
#, no-wrap
msgid "SYSCTL VARIABLES"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3642
msgid ""
"A set of E<.Xr sysctl 8> variables controls the behaviour of the firewall "
"and associated modules E<.Pq Nm dummynet , bridge , sctp nat>.  These are "
"shown below together with their default value (but always check with the E<."
"Xr sysctl 8> command what value is actually in use) and meaning:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3643
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.accept_global_ootb_addip: No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3647
msgid ""
"Defines how the E<.Nm nat> responds to receipt of global OOTB ASCONF-AddIP:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3648 /usr/src/sbin/ipfw/ipfw.8:3678 /usr/src/sbin/ipfw/ipfw.8:3759 /usr/src/sbin/ipfw/ipfw.8:4055
#, no-wrap
msgid "Cm 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3651
msgid ""
"No response (unless a partially matching association exists - ports and "
"vtags match but global address does not)"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3651 /usr/src/sbin/ipfw/ipfw.8:3680 /usr/src/sbin/ipfw/ipfw.8:4065
#, no-wrap
msgid "Cm 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3654
msgid "E<.Nm nat> will accept and process all OOTB global AddIP messages."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3659
msgid ""
"Option 1 should never be selected as this forms a security risk.  An "
"attacker can establish multiple fake associations by sending AddIP messages."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3659
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.chunk_proc_limit: No 5"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3669
msgid ""
"Defines the maximum number of chunks in an SCTP packet that will be parsed "
"for a packet that matches an existing association.  This value is enforced "
"to be greater or equal than E<.Cm net.inet.ip.alias.sctp."
"initialising_chunk_proc_limit>.  A high value is a DoS risk yet setting too "
"low a value may result in important control chunks in the packet not being "
"located and parsed."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3669
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.error_on_ootb: No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3677
msgid ""
"Defines when the E<.Nm nat> responds to any Out-of-the-Blue (OOTB) packets "
"with ErrorM packets.  An OOTB packet is a packet that arrives with no "
"existing association registered in the E<.Nm nat> and is not an INIT or "
"ASCONF-AddIP packet:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3680
msgid "ErrorM is never sent in response to OOTB packets."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3682
msgid "ErrorM is only sent to OOTB packets received on the local side."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3682
#, no-wrap
msgid "Cm 2"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3688
msgid ""
"ErrorM is sent to the local side and on the global side ONLY if there is a "
"partial match (ports and vtags match but the source global IP does not).  "
"This value is only useful if the E<.Nm nat> is tracking global IP addresses."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3688
#, no-wrap
msgid "Cm 3"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3692
msgid ""
"ErrorM is sent in response to all OOTB packets on both the local and global "
"side (DoS risk)."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3706
msgid ""
"At the moment the default is 0, since the ErrorM packet is not yet supported "
"by most SCTP stacks.  When it is supported, and if not tracking global "
"addresses, we recommend setting this value to 1 to allow multi-homed local "
"hosts to function with the E<.Nm nat>.  To track global addresses, we "
"recommend setting this value to 2 to allow global hosts to be informed when "
"they need to (re)send an ASCONF-AddIP.  Value 3 should never be chosen "
"(except for debugging) as the E<.Nm nat> will respond to all OOTB global "
"packets (a DoS risk)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3706
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.hashtable_size: No 2003"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3725
msgid ""
"Size of hash tables used for E<.Nm nat> lookups (100 E<lt> prime_number "
"E<gt> 1000001).  This value sets the E<.Nm hash table> size for any future "
"created E<.Nm nat> instance and therefore must be set prior to creating a E<."
"Nm nat> instance.  The table sizes may be changed to suit specific needs.  "
"If there will be few concurrent associations, and memory is scarce, you may "
"make these smaller.  If there will be many thousands (or millions) of "
"concurrent associations, you should make these larger.  A prime number is "
"best for the table size.  The sysctl update function will adjust your input "
"value to the next highest prime number."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3725
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.holddown_time: No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3730
msgid ""
"Hold association in table for this many seconds after receiving a SHUTDOWN-"
"COMPLETE.  This allows endpoints to correct shutdown gracefully if a "
"shutdown_complete is lost and retransmissions are required."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3730
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.init_timer: No 15"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3733
msgid ""
"Timeout value while waiting for (INIT-ACK|AddIP-ACK).  This value cannot be "
"0."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3733
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.initialising_chunk_proc_limit: No 2"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3740
msgid ""
"Defines the maximum number of chunks in an SCTP packet that will be parsed "
"when no existing association exists that matches that packet.  Ideally this "
"packet will only be an INIT or ASCONF-AddIP packet.  A higher value may "
"become a DoS risk as malformed packets can consume processing resources."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3740
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.param_proc_limit: No 25"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3745
msgid ""
"Defines the maximum number of parameters within a chunk that will be parsed "
"in a packet.  As for other similar sysctl variables, larger values pose a "
"DoS risk."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3745
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.log_level: No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3750
msgid ""
"Level of detail in the system log messages (0 \\- minimal, 1 \\- event, 2 \\-"
" info, 3 \\- detail, 4 \\- debug, 5 \\- max debug).  May be a good option in "
"high loss environments."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3750
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.shutdown_time: No 15"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3753
msgid ""
"Timeout value while waiting for SHUTDOWN-COMPLETE.  This value cannot be 0."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3753
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.track_global_addresses: No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3758
msgid ""
"Enables/disables global IP address tracking within the E<.Nm nat> and places "
"an upper limit on the number of addresses tracked for each association:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3761
msgid "Global tracking is disabled"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3761
#, no-wrap
msgid "Cm E<gt>1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3764
msgid ""
"Enables tracking, the maximum number of addresses tracked for each "
"association is limited to this value"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3780
msgid ""
"This variable is fully dynamic, the new value will be adopted for all newly "
"arriving associations, existing associations are treated as they were "
"previously.  Global tracking will decrease the number of collisions within "
"the E<.Nm nat> at a cost of increased processing load, memory usage, "
"complexity, and possible E<.Nm nat> state problems in complex networks with "
"multiple E<.Nm nats>.  We recommend not tracking global IP addresses, this "
"will still result in a fully functional E<.Nm nat>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3780
#, no-wrap
msgid "Va net.inet.ip.alias.sctp.up_timer: No 300"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3783
msgid ""
"Timeout value to keep an association up with no traffic.  This value cannot "
"be 0."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3783
#, no-wrap
msgid "Va net.inet.ip.dummynet.codel.interval : No 100000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3788
msgid ""
"Default E<.Cm codel> AQM interval in microseconds.  The value must be in the "
"range 1..5000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3788
#, no-wrap
msgid "Va net.inet.ip.dummynet.codel.target : No 5000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3794
msgid ""
"Default E<.Cm codel> AQM target delay time in microseconds (the minimum "
"acceptable persistent queue delay).  The value must be in the range 1.."
"5000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3794
#, no-wrap
msgid "Va net.inet.ip.dummynet.expire : No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3798
msgid ""
"Lazily delete dynamic pipes/queue once they have no pending traffic.  You "
"can disable this by setting the variable to 0, in which case the pipes/"
"queues will only be deleted when the threshold is reached."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3798
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqcodel.flows : No 1024"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3803
msgid ""
"Defines the default total number of flow queues (sub-queues) that E<.Cm "
"fq_codel> creates and manages.  The value must be in the range 1..65536."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3803
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqcodel.interval : No 100000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3808
msgid ""
"Default E<.Cm fq_codel> scheduler/AQM interval in microseconds.  The value "
"must be in the range 1..5000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3808
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqcodel.limit : No 10240"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3814
msgid ""
"The default hard size limit (in unit of packet) of all queues managed by an "
"instance of the E<.Cm fq_codel> scheduler.  The value must be in the range 1."
".20480."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3814
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqcodel.quantum : No 1514"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3819
msgid ""
"The default quantum (credit) of the E<.Cm fq_codel> in unit of byte.  The "
"value must be in the range 1..9000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3819
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqcodel.target : No 5000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3825
msgid ""
"Default E<.Cm fq_codel> scheduler/AQM target delay time in microseconds (the "
"minimum acceptable persistent queue delay).  The value must be in the range "
"1..5000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3825
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.alpha : No 125"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3832
msgid ""
"The default E<.Ar alpha> parameter (scaled by 1000) for E<.Cm fq_pie> "
"scheduler/AQM.  The value must be in the range 1..7000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3832
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.beta : No 1250"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3839
msgid ""
"The default E<.Ar beta> parameter (scaled by 1000) for E<.Cm fq_pie> "
"scheduler/AQM.  The value must be in the range 1..7000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3839
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.flows : No 1024"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3844
msgid ""
"Defines the default total number of flow queues (sub-queues) that E<.Cm "
"fq_pie> creates and manages.  The value must be in the range 1..65536."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3844
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.limit : No 10240"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3850
msgid ""
"The default hard size limit (in unit of packet) of all queues managed by an "
"instance of the E<.Cm fq_pie> scheduler.  The value must be in the range 1.."
"20480."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3850
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.max_burst : No 150000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3855
msgid ""
"The default maximum period of microseconds that E<.Cm fq_pie> scheduler/AQM "
"does not drop/mark packets.  The value must be in the range 1..10000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3855
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.max_ecnth : No 99"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3860
msgid ""
"The default maximum ECN probability threshold (scaled by 1000) for E<.Cm "
"fq_pie> scheduler/AQM.  The value must be in the range 1..7000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3860
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.quantum : No 1514"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3865
msgid ""
"The default quantum (credit) of the E<.Cm fq_pie> in unit of byte.  The "
"value must be in the range 1..9000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3865
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.target : No 15000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3872
msgid ""
"The default E<.Cm target> delay of the E<.Cm fq_pie> in unit of microsecond. "
" The value must be in the range 1..5000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3872
#, no-wrap
msgid "Va net.inet.ip.dummynet.fqpie.tupdate : No 15000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3879
msgid ""
"The default E<.Cm tupdate> of the E<.Cm fq_pie> in unit of microsecond.  The "
"value must be in the range 1..5000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3879
#, no-wrap
msgid "Va net.inet.ip.dummynet.hash_size : No 64"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3884
msgid ""
"Default size of the hash table used for dynamic pipes/queues.  This value is "
"used when no E<.Cm buckets> option is specified when configuring a pipe/"
"queue."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3884
#, no-wrap
msgid "Va net.inet.ip.dummynet.io_fast : No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3891
msgid ""
"If set to a non-zero value, the E<.Dq fast> mode of E<.Nm dummynet> "
"operation (see above) is enabled."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3891
#, no-wrap
msgid "Va net.inet.ip.dummynet.io_pkt"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3894
msgid "Number of packets passed to E<.Nm dummynet>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3894
#, no-wrap
msgid "Va net.inet.ip.dummynet.io_pkt_drop"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3897
msgid "Number of packets dropped by E<.Nm dummynet>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3897
#, no-wrap
msgid "Va net.inet.ip.dummynet.io_pkt_fast"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3901
msgid "Number of packets bypassed by the E<.Nm dummynet> scheduler."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3901
#, no-wrap
msgid "Va net.inet.ip.dummynet.max_chain_len : No 16"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3908
msgid ""
"Target value for the maximum number of pipes/queues in a hash bucket.  The "
"product E<.Cm max_chain_len*hash_size> is used to determine the threshold "
"over which empty pipes/queues will be expired even when E<.Cm net.inet.ip."
"dummynet.expire=0>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3908
#, no-wrap
msgid "Va net.inet.ip.dummynet.red_lookup_depth : No 256"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3909
#, no-wrap
msgid "Va net.inet.ip.dummynet.red_avg_pkt_size : No 512"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3910
#, no-wrap
msgid "Va net.inet.ip.dummynet.red_max_pkt_size : No 1500"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3913
msgid ""
"Parameters used in the computations of the drop probability for the RED "
"algorithm."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3913
#, no-wrap
msgid "Va net.inet.ip.dummynet.pie.alpha : No 125"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3920
msgid ""
"The default E<.Ar alpha> parameter (scaled by 1000) for E<.Cm pie> AQM.  The "
"value must be in the range 1..7000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3920
#, no-wrap
msgid "Va net.inet.ip.dummynet.pie.beta : No 1250"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3927
msgid ""
"The default E<.Ar beta> parameter (scaled by 1000) for E<.Cm pie> AQM.  The "
"value must be in the range 1..7000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3927
#, no-wrap
msgid "Va net.inet.ip.dummynet.pie.max_burst : No 150000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3932
msgid ""
"The default maximum period of microseconds that E<.Cm pie> AQM does not drop/"
"mark packets.  The value must be in the range 1..10000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3932
#, no-wrap
msgid "Va net.inet.ip.dummynet.pie.max_ecnth : No 99"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3937
msgid ""
"The default maximum ECN probability threshold (scaled by 1000) for E<.Cm "
"pie> AQM.  The value must be in the range 1..7000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3937
#, no-wrap
msgid "Va net.inet.ip.dummynet.pie.target : No 15000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3944
msgid ""
"The default E<.Cm target> delay of E<.Cm pie> AQM in unit of microsecond.  "
"The value must be in the range 1..5000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3944
#, no-wrap
msgid "Va net.inet.ip.dummynet.pie.tupdate : No 15000"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3951
msgid ""
"The default E<.Cm tupdate> of E<.Cm pie> AQM in unit of microsecond.  The "
"value must be in the range 1..5000000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3951
#, no-wrap
msgid "Va net.inet.ip.dummynet.pipe_byte_limit : No 1048576"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3952
#, no-wrap
msgid "Va net.inet.ip.dummynet.pipe_slot_limit : No 100"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3958
msgid ""
"The maximum queue size that can be specified in bytes or packets.  These "
"limits prevent accidental exhaustion of resources such as mbufs.  If you "
"raise these limits, you should make sure the system is configured so that "
"sufficient resources are available."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3958
#, no-wrap
msgid "Va net.inet.ip.fw.autoinc_step : No 100"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3961
msgid ""
"Delta between rule numbers when auto-generating them.  The value must be in "
"the range 1..1000."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3961
#, no-wrap
msgid "Va net.inet.ip.fw.curr_dyn_buckets : Va net.inet.ip.fw.dyn_buckets"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3964
msgid ""
"The current number of buckets in the hash table for dynamic rules (readonly)."
""
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3964
#, no-wrap
msgid "Va net.inet.ip.fw.debug : No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3967
msgid "Controls debugging messages produced by E<.Nm>."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3967
#, no-wrap
msgid "Va net.inet.ip.fw.default_rule : No 65535"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3972
msgid ""
"The default rule number (read-only).  By the design of E<.Nm , the default "
"rule is the last one, so its number> can also serve as the highest number "
"allowed for a rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3972
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_buckets : No 256"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3979
msgid ""
"The number of buckets in the hash table for dynamic rules.  Must be a power "
"of 2, up to 65536.  It only takes effect when all dynamic rules have "
"expired, so you are advised to use a E<.Cm flush> command to make sure that "
"the hash table is resized."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3979
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_count : No 3"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3982
msgid "Current number of dynamic rules (read-only)."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3982
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_keepalive : No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3989
msgid ""
"Enables generation of keepalive packets for E<.Cm keep-state> rules on TCP "
"sessions.  A keepalive is generated to both sides of the connection every 5 "
"seconds for the last 20 seconds of the lifetime of the rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3989
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_max : No 8192"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:3993
msgid ""
"Maximum number of dynamic rules.  When you hit this limit, no more dynamic "
"rules can be installed until old ones expire."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3993
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_ack_lifetime : No 300"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3994
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_syn_lifetime : No 20"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3995
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_fin_lifetime : No 1"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3996
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_rst_lifetime : No 1"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3997
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_udp_lifetime : No 5"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:3998
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_short_lifetime : No 30"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4011
msgid ""
"These variables control the lifetime, in seconds, of dynamic rules.  Upon "
"the initial SYN exchange the lifetime is kept short, then increased after "
"both SYN have been seen, then decreased again during the final FIN exchange "
"or when a RST is received.  Both E<.Em dyn_fin_lifetime> and E<.Em "
"dyn_rst_lifetime> must be strictly lower than 5 seconds, the period of "
"repetition of keepalives.  The firewall enforces that."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4011
#, no-wrap
msgid "Va net.inet.ip.fw.dyn_keep_states: No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4016
msgid ""
"Keep dynamic states on rule/set deletion.  States are relinked to default "
"rule (65535).  This can be handly for ruleset reload.  Turned off by default."
""
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4016
#, no-wrap
msgid "Va net.inet.ip.fw.enable : No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4020
msgid ""
"Enables the firewall.  Setting this variable to 0 lets you run your machine "
"without firewall even if compiled in."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4020
#, no-wrap
msgid "Va net.inet6.ip6.fw.enable : No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4022
msgid "provides the same functionality as above for the IPv6 case."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4022
#, no-wrap
msgid "Va net.inet.ip.fw.one_pass : No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4030
msgid ""
"When set, the packet exiting from the E<.Nm dummynet> pipe or from E<.Xr "
"ng_ipfw 4> node is not passed though the firewall again.  Otherwise, after "
"an action, the packet is reinjected into the firewall at the next rule."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4030
#, no-wrap
msgid "Va net.inet.ip.fw.tables_max : No 128"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4032
msgid "Maximum number of tables."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4032
#, no-wrap
msgid "Va net.inet.ip.fw.verbose : No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4034
msgid "Enables verbose messages."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4034
#, no-wrap
msgid "Va net.inet.ip.fw.verbose_limit : No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4036
msgid "Limits the number of messages produced by a verbose firewall."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4036
#, no-wrap
msgid "Va net.inet6.ip6.fw.deny_unknown_exthdrs : No 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4038
msgid "If enabled packets with unknown IPv6 Extension Headers will be denied."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4038
#, no-wrap
msgid "Va net.link.ether.ipfw : No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4042
msgid "Controls whether layer-2 packets are passed to E<.Nm>.  Default is no."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4042
#, no-wrap
msgid "Va net.link.bridge.ipfw : No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4046
msgid "Controls whether bridged packets are passed to E<.Nm>.  Default is no."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4046
#, no-wrap
msgid "Va net.inet.ip.fw.nat64_debug : No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4050
msgid "Controls debugging messages produced by E<.Nm ipfw_nat64> module."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4050
#, no-wrap
msgid "Va net.inet.ip.fw.nat64_direct_output : No 0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4054
msgid "Controls the output method used by E<.Nm ipfw_nat64> module:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4065
msgid ""
"A packet is handled by E<.Nm ipfw> twice.  First time an original packet is "
"handled by E<.Nm ipfw> and consumed by E<.Nm ipfw_nat64> translator.  Then "
"translated packet is queued via netisr to input processing again."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4070
msgid ""
"A packet is handled by E<.Nm ipfw> only once, and after translation it will "
"be pushed directly to outgoing interface."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4076
msgid ""
"There are some commands that may be useful to understand current state of "
"certain subsystems inside kernel module.  These commands provide debugging "
"output which may change without notice."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4080
msgid ""
"Currently the following commands are available as E<.Cm internal> sub-"
"options:"
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4081
#, no-wrap
msgid "Cm iflist"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4085
msgid ""
"Lists all interface which are currently tracked by E<.Nm> with their in-"
"kernel status."
msgstr ""

#. type: It
#: /usr/src/sbin/ipfw/ipfw.8:4085
#, no-wrap
msgid "Cm talist"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4087
msgid "List all table lookup algorithms currently available."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:4088
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4092
msgid ""
"There are far too many possible uses of E<.Nm> so this Section will only "
"give a small set of examples."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:4093
#, no-wrap
msgid "BASIC PACKET FILTERING"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4099
msgid ""
"This command adds an entry which denies all tcp packets from E<.Em cracker."
"evil.org> to the telnet port of E<.Em wolf.tambov.su> from being forwarded "
"by the host:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4100
#, no-wrap
msgid "ipfw add deny tcp from cracker.evil.org to wolf.tambov.su telnet"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4104
msgid ""
"This one disallows any connection from the entire cracker's network to my "
"host:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4105
#, no-wrap
msgid "ipfw add deny ip from 123.45.67.0/24 to my.host.org"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4109
msgid ""
"A first and efficient way to limit access (not using dynamic rules)  is the "
"use of the following rules:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4110
#, no-wrap
msgid "ipfw add allow tcp from any to any established"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4111
#, no-wrap
msgid "ipfw add allow tcp from net1 portlist1 to net2 portlist2 setup"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4112
#, no-wrap
msgid "ipfw add allow tcp from net3 portlist3 to net3 portlist3 setup"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4113 /usr/src/sbin/ipfw/ipfw.8:4397 /usr/src/sbin/ipfw/ipfw.8:4402 /usr/src/sbin/ipfw/ipfw.8:4412
#, no-wrap
msgid "..."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4124
msgid ""
"The first rule will be a quick match for normal TCP packets, but it will not "
"match the initial SYN packet, which will be matched by the E<.Cm setup> "
"rules only for selected source/destination pairs.  All other SYN packets "
"will be rejected by the final E<.Cm deny> rule."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4129
msgid ""
"If you administer one or more subnets, you can take advantage of the address "
"sets and or-blocks and write extremely compact rulesets which selectively "
"enable services to blocks of clients, as below:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4130
#, no-wrap
msgid "goodguys=\\*q{ 10.1.2.0/24{20,35,66,18} or 10.2.3.0/28{6,3,11} }\\*q"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4131
#, no-wrap
msgid "badguys=\\*q10.1.2.0/24{8,38,60}\\*q"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4133
#, no-wrap
msgid "ipfw add allow ip from ${goodguys} to any"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4134
#, no-wrap
msgid "ipfw add deny ip from ${badguys} to any"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4135
#, no-wrap
msgid "... normal policies ..."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4141
msgid ""
"The E<.Cm verrevpath> option could be used to do automated anti-spoofing by "
"adding the following to the top of a ruleset:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4142
#, no-wrap
msgid "ipfw add deny ip from any to any not verrevpath in"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4149
msgid ""
"This rule drops all incoming packets that appear to be coming to the system "
"on the wrong interface.  For example, a packet with a source address "
"belonging to a host on a protected internal network would be dropped if it "
"tried to enter the system from an external interface."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4154
msgid ""
"The E<.Cm antispoof> option could be used to do similar but more restricted "
"anti-spoofing by adding the following to the top of a ruleset:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4155
#, no-wrap
msgid "ipfw add deny ip from any to any not antispoof in"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4166
msgid ""
"This rule drops all incoming packets that appear to be coming from another "
"directly connected system but on the wrong interface.  For example, a packet "
"with a source address of E<.Li 192.168.0.0/24>, configured on E<.Li fxp0>, "
"but coming in on E<.Li fxp1> would be dropped."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4171
msgid ""
"The E<.Cm setdscp> option could be used to (re)mark user traffic, by adding "
"the following to the appropriate place in ruleset:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4172
#, no-wrap
msgid "ipfw add setdscp be ip from any to any dscp af11,af21"
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:4173
#, no-wrap
msgid "SELECTIVE MIRRORING"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4178
msgid ""
"If your network has network traffic analyzer connected to your host directly "
"via dedicated interface or remotely via RSPAN vlan, you can selectively "
"mirror some Ethernet layer2 frames to the analyzer."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4181
msgid ""
"First, make sure your firewall is already configured and runs.  Then, enable "
"layer2 processing if not already enabled:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4182
#, no-wrap
msgid "sysctl net.link.ether.ipfw=1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4185
msgid "Next, load needed additional kernel modules:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4186
#, no-wrap
msgid "kldload ng_ether ng_ipfw"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4190
msgid "Optionally, make system load these modules automatically at startup:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4191
#, no-wrap
msgid "sysrc kld_list+=\"ng_ether ng_ipfw\""
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4197
msgid ""
"Next, configure E<.Xr ng_ipfw 4> kernel module to transmit mirrored copies "
"of layer2 frames out via vlan900 interface:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4198
#, no-wrap
msgid "ngctl connect ipfw: vlan900: 1 lower"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4206
msgid ""
"Think of \"1\" here as of \"mirroring instance index\" and vlan900 is its "
"destination.  You can have arbitrary number of instances.  Refer to E<.Xr "
"ng_ipfw 4> for details."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4209
msgid ""
"At last, actually start mirroring of selected frames using \"instance 1\".  "
"For frames incoming from em0 interface:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4210
#, no-wrap
msgid "ipfw add ngtee 1 ip from any to 192.168.0.1 layer2 in recv em0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4213
msgid "For frames outgoing to em0 interface:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4214
#, no-wrap
msgid "ipfw add ngtee 1 ip from any to 192.168.0.1 layer2 out xmit em0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4217
msgid "For both incoming and outgoing frames while flowing through em0:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4218
#, no-wrap
msgid "ipfw add ngtee 1 ip from any to 192.168.0.1 layer2 via em0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4222
msgid ""
"Make sure you do not perform mirroring for already duplicated frames or "
"kernel may hang as there is no safety net."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:4222
#, no-wrap
msgid "DYNAMIC RULES"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4225
msgid ""
"In order to protect a site from flood attacks involving fake TCP packets, it "
"is safer to use dynamic rules:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4226 /usr/src/sbin/ipfw/ipfw.8:4546
#, no-wrap
msgid "ipfw add check-state"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4227
#, no-wrap
msgid "ipfw add deny tcp from any to any established"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4228
#, no-wrap
msgid "ipfw add allow tcp from my-net to any setup keep-state"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4245
msgid ""
"This will let the firewall install dynamic rules only for those connection "
"which start with a regular SYN packet coming from the inside of our network. "
" Dynamic rules are checked when encountering the first occurrence of a E<.Cm "
"check-state>, E<.Cm keep-state> or E<.Cm limit> rule.  A E<.Cm check-state> "
"rule should usually be placed near the beginning of the ruleset to minimize "
"the amount of work scanning the ruleset.  Your mileage may vary."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4254
msgid ""
"For more complex scenarios with dynamic rules E<.Cm record-state > and E<.Cm "
"defer-action> can be used to precisely control creation and checking of "
"dynamic rules.  Example of usage of these options are provided in E<.Sx "
"NETWORK ADDRESS TRANSLATION (NAT)> Section."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4257
msgid ""
"To limit the number of connections a user can open you can use the following "
"type of rules:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4258
#, no-wrap
msgid "ipfw add allow tcp from my-net/24 to any setup limit src-addr 10"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4259
#, no-wrap
msgid "ipfw add allow tcp from any to me setup limit src-addr 4"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4265
msgid ""
"The former (assuming it runs on a gateway) will allow each host on a /24 "
"network to open at most 10 TCP connections.  The latter can be placed on a "
"server to make sure that a single client does not use more than 4 "
"simultaneous connections."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4273
msgid ""
"E<.Em BEWARE>: stateful rules can be subject to denial-of-service attacks by "
"a SYN-flood which opens a huge number of dynamic rules.  The effects of such "
"attacks can be partially limited by acting on a set of E<.Xr sysctl 8> "
"variables which control the operation of the firewall."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4277
msgid ""
"Here is a good usage of the E<.Cm list> command to see accounting records "
"and timestamp information:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4278
#, no-wrap
msgid "ipfw -at list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4281
msgid "or in short form without timestamps:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4282
#, no-wrap
msgid "ipfw -a list"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4285
msgid "which is equivalent to:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4286
#, no-wrap
msgid "ipfw show"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4290
msgid ""
"Next rule diverts all incoming packets from 192.168.2.0/24 to divert port "
"5000:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4291
#, no-wrap
msgid "ipfw divert 5000 ip from 192.168.2.0/24 to any in"
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:4292
#, no-wrap
msgid "TRAFFIC SHAPING"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4298
msgid ""
"The following rules show some of the applications of E<.Nm> and E<.Nm "
"dummynet> for simulations and the like."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4301
msgid "This rule drops random incoming packets with a probability of 5%:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4302
#, no-wrap
msgid "ipfw add prob 0.05 deny ip from any to any in"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4307
msgid "A similar effect can be achieved making use of E<.Nm dummynet> pipes:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4308
#, no-wrap
msgid "ipfw add pipe 10 ip from any to any"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4309
#, no-wrap
msgid "ipfw pipe 10 config plr 0.05"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4314
msgid ""
"We can use pipes to artificially limit bandwidth, e.g.\\& on a machine "
"acting as a router, if we want to limit traffic from local clients on 192."
"168.2.0/24 we do:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4315 /usr/src/sbin/ipfw/ipfw.8:4382
#, no-wrap
msgid "ipfw add pipe 1 ip from 192.168.2.0/24 to any out"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4316
#, no-wrap
msgid "ipfw pipe 1 config bw 300Kbit/s queue 50KBytes"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4324
msgid ""
"note that we use the E<.Cm out> modifier so that the rule is not used twice. "
" Remember in fact that E<.Nm> rules are checked both on incoming and "
"outgoing packets."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4327
msgid ""
"Should we want to simulate a bidirectional link with bandwidth limitations, "
"the correct way is the following:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4328 /usr/src/sbin/ipfw/ipfw.8:4355
#, no-wrap
msgid "ipfw add pipe 1 ip from any to any out"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4329 /usr/src/sbin/ipfw/ipfw.8:4356
#, no-wrap
msgid "ipfw add pipe 2 ip from any to any in"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4330
#, no-wrap
msgid "ipfw pipe 1 config bw 64Kbit/s queue 10Kbytes"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4331
#, no-wrap
msgid "ipfw pipe 2 config bw 64Kbit/s queue 10Kbytes"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4341
msgid ""
"The above can be very useful, e.g.\\& if you want to see how your fancy Web "
"page will look for a residential user who is connected only through a slow "
"link.  You should not use only one pipe for both directions, unless you want "
"to simulate a half-duplex medium (e.g.\\& AppleTalk, Ethernet, IRDA).  It is "
"not necessary that both pipes have the same configuration, so we can also "
"simulate asymmetric links."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4344
msgid ""
"Should we want to verify network performance with the RED queue management "
"algorithm:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4345 /usr/src/sbin/ipfw/ipfw.8:4365
#, no-wrap
msgid "ipfw add pipe 1 ip from any to any"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4346
#, no-wrap
msgid "ipfw pipe 1 config bw 500Kbit/s queue 100 red 0.002/30/80/0.1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4354
msgid ""
"Another typical application of the traffic shaper is to introduce some delay "
"in the communication.  This can significantly affect applications which do a "
"lot of Remote Procedure Calls, and where the round-trip-time of the "
"connection often becomes a limiting factor much more than bandwidth:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4357
#, no-wrap
msgid "ipfw pipe 1 config delay 250ms bw 1Mbit/s"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4358
#, no-wrap
msgid "ipfw pipe 2 config delay 250ms bw 1Mbit/s"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4362
msgid ""
"Per-flow queueing can be useful for a variety of purposes.  A very simple "
"one is counting traffic:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4363
#, no-wrap
msgid "ipfw add pipe 1 tcp from any to any"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4364
#, no-wrap
msgid "ipfw add pipe 1 udp from any to any"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4366
#, no-wrap
msgid "ipfw pipe 1 config mask all"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4378
msgid ""
"The above set of rules will create queues (and collect statistics) for all "
"traffic.  Because the pipes have no limitations, the only effect is "
"collecting statistics.  Note that we need 3 rules, not just the last one, "
"because when E<.Nm> tries to match IP packets it will not consider ports, so "
"we would not see connections on separate ports as different ones."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4381
msgid ""
"A more sophisticated example is limiting the outbound traffic on a net with "
"per-host limits, rather than per-network limits:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4383
#, no-wrap
msgid "ipfw add pipe 2 ip from any to 192.168.2.0/24 in"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4384
#, no-wrap
msgid "ipfw pipe 1 config mask src-ip 0x000000ff bw 200Kbit/s queue 20Kbytes"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4385
#, no-wrap
msgid "ipfw pipe 2 config mask dst-ip 0x000000ff bw 200Kbit/s queue 20Kbytes"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4394
msgid ""
"In the following example, we need to create several traffic bandwidth "
"classes and we need different hosts/networks to fall into different classes. "
" We create one pipe for each class and configure them accordingly.  Then we "
"create a single table and fill it with IP subnets and addresses.  For each "
"subnet/host we set the argument equal to the number of the pipe that it "
"should use.  Then we classify traffic using a single rule:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4395
#, no-wrap
msgid "ipfw pipe 1 config bw 1000Kbyte/s"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4396
#, no-wrap
msgid "ipfw pipe 4 config bw 4000Kbyte/s"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4398
#, no-wrap
msgid "ipfw table T1 create type addr"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4399
#, no-wrap
msgid "ipfw table T1 add 192.168.2.0/24 1"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4400
#, no-wrap
msgid "ipfw table T1 add 192.168.0.0/27 4"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4401
#, no-wrap
msgid "ipfw table T1 add 192.168.0.2 1"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4403
#, no-wrap
msgid "ipfw add pipe tablearg ip from 'table(T1)' to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4408
msgid ""
"Using the E<.Cm fwd> action, the table entries may include hostnames and IP "
"addresses."
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4409
#, no-wrap
msgid "ipfw table T2 create type addr ftype ip"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4410
#, no-wrap
msgid "ipfw table T2 add 192.168.2.0/24 10.23.2.1"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4411
#, no-wrap
msgid "ipfw table T21 add 192.168.0.0/27 router1.dmz"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4413
#, no-wrap
msgid "ipfw add 100 fwd tablearg ip from any to table(1)"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4416
msgid "In the following example per-interface firewall is created:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4417
#, no-wrap
msgid "ipfw table IN create type iface valtype skipto,fib"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4418
#, no-wrap
msgid "ipfw table IN add vlan20 12000,12"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4419
#, no-wrap
msgid "ipfw table IN add vlan30 13000,13"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4420
#, no-wrap
msgid "ipfw table OUT create type iface valtype skipto"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4421
#, no-wrap
msgid "ipfw table OUT add vlan20 22000"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4422
#, no-wrap
msgid "ipfw table OUT add vlan30 23000"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4423 /usr/src/sbin/ipfw/ipfw.8:4433
#, no-wrap
msgid ".."
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4424
#, no-wrap
msgid "ipfw add 100 setfib tablearg ip from any to any recv 'table(IN)' in"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4425
#, no-wrap
msgid "ipfw add 200 skipto tablearg ip from any to any recv 'table(IN)' in"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4426
#, no-wrap
msgid "ipfw add 300 skipto tablearg ip from any to any xmit 'table(OUT)' out"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4429
msgid "The following example illustrate usage of flow tables:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4430
#, no-wrap
msgid "ipfw table fl create type flow:src-ip,proto,dst-ip,dst-port"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4431
#, no-wrap
msgid "ipfw table fl add 2a02:6b8:77::88,tcp,2a02:6b8:77::99,80 11"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4432
#, no-wrap
msgid "ipfw table fl add 10.0.0.1,udp,10.0.0.2,53 12"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4434
#, no-wrap
msgid "ipfw add 100 allow ip from any to any flow 'table(fl,11)' recv ix0"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4437
msgid "To add a set of rules atomically, e.g.\\& set 18:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4438 /usr/src/sbin/ipfw/ipfw.8:4448
#, no-wrap
msgid "ipfw set disable 18"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4439 /usr/src/sbin/ipfw/ipfw.8:4449
#, no-wrap
msgid "ipfw add NN set 18 ...         # repeat as needed"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4440
#, no-wrap
msgid "ipfw set enable 18"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4443
msgid "To delete a set of rules atomically the command is simply:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4444
#, no-wrap
msgid "ipfw delete set 18"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4447
msgid ""
"To test a ruleset and disable it and regain control if something goes wrong:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4450
#, no-wrap
msgid "ipfw set enable 18; echo done; sleep 30 && ipfw set disable 18"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4457
msgid ""
"Here if everything goes well, you press control-C before the \"sleep\" "
"terminates, and your ruleset will be left active.  Otherwise, e.g.\\& if you "
"cannot access your box, the ruleset will be disabled after the sleep "
"terminates thus restoring the previous situation."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4459
msgid "To show rules of the specific set:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4460
#, no-wrap
msgid "ipfw set 18 show"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4463
msgid "To show rules of the disabled set:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4464
#, no-wrap
msgid "ipfw -S set 18 show"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4467
msgid "To clear a specific rule counters of the specific set:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4468
#, no-wrap
msgid "ipfw set 18 zero NN"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4471
msgid "To delete a specific rule of the specific set:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4472
#, no-wrap
msgid "ipfw set 18 delete NN"
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:4473
#, no-wrap
msgid "NAT, REDIRECT AND LSNAT"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4475
msgid "First redirect all the traffic to nat instance 123:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4476
#, no-wrap
msgid "ipfw add nat 123 all from any to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4482
msgid ""
"Then to configure nat instance 123 to alias all the outgoing traffic with ip "
"192.168.0.123, blocking all incoming connections, trying to keep same ports "
"on both sides, clearing aliasing table on address change and keeping a log "
"of traffic/link statistics:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4483
#, no-wrap
msgid "ipfw nat 123 config ip 192.168.0.123 log deny_in reset same_ports"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4487
msgid ""
"Or to change address of instance 123, aliasing table will be cleared (see "
"reset option):"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4488
#, no-wrap
msgid "ipfw nat 123 config ip 10.0.0.1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4491
msgid "To see configuration of nat instance 123:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4492
#, no-wrap
msgid "ipfw nat 123 show config"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4495
msgid "To show logs of all the instances in range 111-999:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4496
#, no-wrap
msgid "ipfw nat 111-999 show"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4499
msgid "To see configurations of all instances:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4500
#, no-wrap
msgid "ipfw nat show config"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4503
msgid "Or a redirect rule with mixed modes could looks like:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4504
#, no-wrap
msgid "ipfw nat 123 config redirect_addr 10.0.0.1 10.0.0.66"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4505
#, no-wrap
msgid "\t\t\t redirect_port tcp 192.168.0.1:80 500"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4506
#, no-wrap
msgid "\t\t\t redirect_proto udp 192.168.1.43 192.168.1.1"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4507
#, no-wrap
msgid "\t\t\t redirect_addr 192.168.0.10,192.168.0.11"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4508
#, no-wrap
msgid "\t\t\t \t    10.0.0.100\t# LSNAT"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4509
#, no-wrap
msgid "\t\t\t redirect_port tcp 192.168.0.1:80,192.168.0.10:22"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4510
#, no-wrap
msgid "\t\t\t \t    500\t\t# LSNAT"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4513
msgid "or it could be split in:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4514
#, no-wrap
msgid "ipfw nat 1 config redirect_addr 10.0.0.1 10.0.0.66"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4515
#, no-wrap
msgid "ipfw nat 2 config redirect_port tcp 192.168.0.1:80 500"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4516
#, no-wrap
msgid "ipfw nat 3 config redirect_proto udp 192.168.1.43 192.168.1.1"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4517
#, no-wrap
msgid "ipfw nat 4 config redirect_addr 192.168.0.10,192.168.0.11,192.168.0.12"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4518
#, no-wrap
msgid "\t\t\t\t         10.0.0.100"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4519
#, no-wrap
msgid "ipfw nat 5 config redirect_port tcp"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4520
#, no-wrap
msgid "\t\t\t192.168.0.1:80,192.168.0.10:22,192.168.0.20:25 500"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4534
msgid ""
"Sometimes you may want to mix NAT and dynamic rules. It could be achieved "
"with E<.Cm record-state> and E<.Cm defer-action> options. Problem is, you "
"need to create dynamic rule before NAT and check it after NAT actions (or "
"vice versa) to have consistent addresses and ports.  Rule with E<.Cm keep-"
"state> option will trigger activation of existing dynamic state, and action "
"of such rule will be performed as soon as rule is matched. In case of NAT "
"and E<.Cm allow> rule packet need to be passed to NAT, not allowed as soon "
"is possible."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4537
msgid ""
"There is example of set of rules to achieve this. Bear in mind that this is "
"exmaple only and it is not very useful by itself."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4539
msgid "On way out, after all checks place this rules:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4540
#, no-wrap
msgid "ipfw add allow record-state skip-action"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4541 /usr/src/sbin/ipfw/ipfw.8:4545
#, no-wrap
msgid "ipfw add nat 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4544
msgid "And on way in there should be something like this:"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4555
msgid ""
"Please note, that first rule on way out doesn't allow packet and doesn't "
"execute existing dynamic rules. All it does, create new dynamic rule with E<."
"Cm allow> action, if it is not created yet. Later, this dynamic rule is used "
"on way in by E<.Cm check-state> rule."
msgstr ""

#. type: Ss
#: /usr/src/sbin/ipfw/ipfw.8:4555
#, no-wrap
msgid "CONFIGURING CODEL, PIE, FQ-CODEL and FQ-PIE AQM"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4564
msgid ""
"E<.Cm codel> and E<.Cm pie> AQM can be configured for E<.Nm dummynet> E<.Cm "
"pipe> or E<.Cm queue.>"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4571
msgid ""
"To configure a E<.Cm pipe> with E<.Cm codel> AQM using default configuration "
"for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4572
#, no-wrap
msgid "ipfw pipe 1 config bw 1mbits/s codel"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4573 /usr/src/sbin/ipfw/ipfw.8:4594
#, no-wrap
msgid "ipfw add 100 pipe 1 ip from 192.168.0.0/24 to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4581
msgid ""
"To configure a E<.Cm queue> with E<.Cm codel> AQM using different "
"configurations parameters for traffic from 192.168.0.0/24 and 1Mbits/s rate "
"limit, we do:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4582 /usr/src/sbin/ipfw/ipfw.8:4603 /usr/src/sbin/ipfw/ipfw.8:4619 /usr/src/sbin/ipfw/ipfw.8:4641
#, no-wrap
msgid "ipfw pipe 1 config bw 1mbits/s"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4583
#, no-wrap
msgid "ipfw queue 1 config pipe 1 codel target 8ms interval 160ms ecn"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4584 /usr/src/sbin/ipfw/ipfw.8:4605 /usr/src/sbin/ipfw/ipfw.8:4622 /usr/src/sbin/ipfw/ipfw.8:4644
#, no-wrap
msgid "ipfw add 100 queue 1 ip from 192.168.0.0/24 to any"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4592
msgid ""
"To configure a E<.Cm pipe> with E<.Cm pie> AQM using default configuration "
"for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4593
#, no-wrap
msgid "ipfw pipe 1 config bw 1mbits/s pie"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4602
msgid ""
"To configure a E<.Cm queue> with E<.Cm pie> AQM using different "
"configuration parameters for traffic from 192.168.0.0/24 and 1Mbits/s rate "
"limit, we do:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4604
#, no-wrap
msgid "ipfw queue 1 config pipe 1 pie target 20ms tupdate 30ms ecn"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4613
msgid ""
"E<.Cm fq_codel> and E<.Cm fq_pie> AQM can be configured for E<.Nm dummynet> "
"schedulers."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4618
msgid ""
"To configure E<.Cm fq_codel> scheduler using different configurations "
"parameters for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4620
#, no-wrap
msgid "ipfw sched 1 config pipe 1 type fq_codel"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4621 /usr/src/sbin/ipfw/ipfw.8:4643
#, no-wrap
msgid "ipfw queue 1 config sched 1"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4631
msgid ""
"To change E<.Cm fq_codel> default configuration for a E<.Cm sched> such as "
"disable ECN and change the E<.Ar target> to 10ms, we do:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4632
#, no-wrap
msgid "ipfw sched 1 config pipe 1 type fq_codel target 10ms noecn"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4640
msgid ""
"Similar to E<.Cm fq_codel,> to configure E<.Cm fq_pie> scheduler using "
"different configurations parameters for traffic from 192.168.0.0/24 and "
"1Mbits/s rate limit, we do:"
msgstr ""

#. type: Dl
#: /usr/src/sbin/ipfw/ipfw.8:4642
#, no-wrap
msgid "ipfw sched 1 config pipe 1 type fq_pie"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4651
msgid ""
"The configurations of E<.Cm fq_pie> E<.Cm sched> can be changed in a similar "
"way as for E<.Cm fq_codel>"
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:4651
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4670
msgid ""
"E<.Xr cpp 1>, E<.Xr m4 1>, E<.Xr altq 4>, E<.Xr divert 4>, E<.Xr dummynet "
"4>, E<.Xr if_bridge 4>, E<.Xr ip 4>, E<.Xr ipfirewall 4>, E<.Xr ng_ether 4>, "
"E<.Xr ng_ipfw 4>, E<.Xr protocols 5>, E<.Xr services 5>, E<.Xr init 8>, E<."
"Xr kldload 8>, E<.Xr reboot 8>, E<.Xr sysctl 8>, E<.Xr sysrc 8>, E<.Xr "
"syslogd 8>"
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:4670
#, no-wrap
msgid "HISTORY"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4682
msgid ""
"The E<.Nm> utility first appeared in E<.Fx 2.0>.  E<.Nm dummynet> was "
"introduced in E<.Fx 2.2.8>.  Stateful extensions were introduced in E<.Fx 4."
"0>.  E<.Nm ipfw2> was introduced in Summer 2002."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:4682
#, no-wrap
msgid "AUTHORS"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4689
msgid ""
"E<.An Ugen J. S. Antsilevich>, E<.An Poul-Henning Kamp>, E<.An Alex Nash>, "
"E<.An Archie Cobbs>, E<.An Luigi Rizzo>, E<.An Rasool Al-Saadi>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4694
msgid ""
"E<.An -nosplit> API based upon code written by E<.An Daniel Boulet> for BSDI."
""
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4696
msgid "Dummynet has been introduced by Luigi Rizzo in 1997-1998."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4700
msgid ""
"Some early work (1999-2000) on the E<.Nm dummynet> traffic shaper supported "
"by Akamba Corp."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4706
msgid ""
"The ipfw core (ipfw2) has been completely redesigned and reimplemented by "
"Luigi Rizzo in summer 2002.  Further actions and options have been added by "
"various developers over the years."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4711
msgid ""
"E<.An -nosplit> In-kernel NAT support written by E<.An Paolo Pisati Aq Mt "
"piso@FreeBSD.org> as part of a Summer of Code 2005 project."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4719
msgid ""
"SCTP E<.Nm nat> support has been developed by E<.An The Centre for Advanced "
"Internet Architectures (CAIA) Aq http://www.caia.swin.edu.au>.  The primary "
"developers and maintainers are David Hayes and Jason But.  For further "
"information visit: E<.Aq http://www.caia.swin.edu.au/urp/SONATA>"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4723
msgid ""
"Delay profiles have been developed by Alessandro Cerri and Luigi Rizzo, "
"supported by the European Commission within Projects Onelab and Onelab2."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4729
msgid ""
"CoDel, PIE, FQ-CoDel and FQ-PIE AQM for Dummynet have been implemented by E<."
"An The Centre for Advanced Internet Architectures (CAIA)> in 2016, supported "
"by The Comcast Innovation Fund.  The primary developer is Rasool Al-Saadi."
msgstr ""

#. type: Sh
#: /usr/src/sbin/ipfw/ipfw.8:4729
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4733
msgid ""
"The syntax has grown over the years and sometimes it might be confusing.  "
"Unfortunately, backward compatibility prevents cleaning up mistakes made in "
"the definition of the syntax."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4735
msgid "E<.Em !!! WARNING !!!>"
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4739
msgid ""
"Misconfiguring the firewall can put your computer in an unusable state, "
"possibly shutting down network services and requiring console access to "
"regain control of it."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4745
msgid ""
"Incoming packet fragments diverted by E<.Cm divert> are reassembled before "
"delivery to the socket.  The action used on those packet is the one from the "
"rule which matches the first fragment of the packet."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4758
msgid ""
"Packets diverted to userland, and then reinserted by a userland process may "
"lose various packet attributes.  The packet source interface name will be "
"preserved if it is shorter than 8 bytes and the userland process saves and "
"reuses the sockaddr_in (as does E<.Xr natd 8>); otherwise, it may be lost.  "
"If a packet is reinserted in this manner, later rules may be incorrectly "
"applied, making the order of E<.Cm divert> rules in the rule sequence very "
"important."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4760
msgid "Dummynet drops all packets with IPv6 link-local addresses."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4772
msgid ""
"Rules using E<.Cm uid> or E<.Cm gid> may not behave as expected.  In "
"particular, incoming SYN packets may have no uid or gid associated with them "
"since they do not yet belong to a TCP connection, and the uid/gid associated "
"with a packet may not be as expected if the associated process calls E<.Xr "
"setuid 2> or similar system calls."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4776
msgid ""
"Rule syntax is subject to the command line environment and some patterns may "
"need to be escaped with the backslash character or quoted appropriately."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4783
msgid ""
"Due to the architecture of E<.Xr libalias 3>, ipfw nat is not compatible "
"with the TCP segmentation offloading (TSO).  Thus, to reliably nat your "
"network traffic, please disable TSO on your NICs using E<.Xr ifconfig 8>."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4789
msgid ""
"ICMP error messages are not implicitly matched by dynamic rules for the "
"respective conversations.  To avoid failures of network error detection and "
"path MTU discovery, ICMP error messages may need to be allowed explicitly "
"through static rules."
msgstr ""

#. type: Plain text
#: /usr/src/sbin/ipfw/ipfw.8:4803
msgid ""
"Rules using E<.Cm call> and E<.Cm return> actions may lead to confusing "
"behaviour if ruleset has mistakes, and/or interaction with other subsystems "
"(netgraph, dummynet, etc.) is used.  One possible case for this is packet "
"leaving E<.Nm> in subroutine on the input pass, while later on output "
"encountering unpaired E<.Cm return> first.  As the call stack is kept intact "
"after input pass, packet will suddenly return to the rule number used on "
"input pass, not on output one.  Order of processing should be checked "
"carefully to avoid such mistakes."
msgstr ""
