# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-05-18 14:32-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Dd
#: /usr/src/contrib/binutils/ld/ld.7:1
#, no-wrap
msgid "2015-03-02"
msgstr ""

#. type: Dt
#: /usr/src/contrib/binutils/ld/ld.7:2
#, no-wrap
msgid "LD 7"
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:4
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6
msgid "E<.Nm ld>"
msgstr ""

#. type: Nd
#: /usr/src/contrib/binutils/ld/ld.7:6
#, no-wrap
msgid "The GNU Linker"
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:7
#, no-wrap
msgid "LD"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:9
msgid ""
"This file documents the GNU linker ld version \"2.17.50 [FreeBSD] "
"2007-07-03\"."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:13
msgid ""
"This document is distributed under the terms of the GNU Free Documentation "
"License. A copy of the license is included in the section entitled \\(lqGNU "
"Free Documentation License\\(rq."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:14
#, no-wrap
msgid "Overview"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:19
msgid ""
"E<.Xr ld> combines a number of object and archive files, relocates their "
"data and ties up symbol references. Usually the last step in compiling a "
"program is to run E<.Xr ld>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:24
msgid ""
"E<.Xr ld> accepts Linker Command Language files written in a superset of "
"AT&T's Link Editor Command Language syntax, to provide explicit and total "
"control over the linking process."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:36
msgid ""
"This version of E<.Xr ld> uses the general purpose BFD libraries to operate "
"on object files. This allows E<.Xr ld> to read, combine, and write object "
"files in many different formats---for example, COFF or E<.Li a.out>.  "
"Different formats may be linked together to produce any available kind of "
"object file.See Section E<.Dq BFD>, for more information."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:43
msgid ""
"Aside from its flexibility, the GNU linker is more helpful than other "
"linkers in providing diagnostic information. Many linkers abandon execution "
"immediately upon encountering an error; whenever possible, E<.Xr ld> "
"continues executing, allowing you to identify other errors (or, in some "
"cases, to get an output file in spite of the error)."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:44
#, no-wrap
msgid "Invocation"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:50
msgid ""
"The GNU linker E<.Xr ld> is meant to cover a broad range of situations, and "
"to be as compatible as possible with other linkers. As a result, you have "
"many choices to control its behavior."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:51
#, no-wrap
msgid "Command Line Options"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:59
msgid ""
"The linker supports a plethora of command-line options, but in actual "
"practice few of them are used in any particular context. For instance, a "
"frequent use of E<.Xr ld> is to link standard Unix object files on a "
"standard, supported Unix system.  On such a system, to link a file E<.Li "
"hello.o>:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:62
#, no-wrap
msgid "ld -o output /lib/crt0.o hello.o -lc\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:78
msgid ""
"This tells E<.Xr ld> to produce a file called E<.Va output> as the result of "
"linking the file E<.Li /lib/crt0.o> with E<.Li hello.o> and the library "
"E<.Li libc.a>, which will come from the standard search directories. (See "
"the discussion of the E<.Li -l> option below.)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:92
msgid ""
"Some of the command-line options to E<.Xr ld> may be specified at any point "
"in the command line. However, options which refer to files, such as E<.Li "
"-l> or E<.Li -T>, cause the file to be read at the point at which the option "
"appears in the command line, relative to the object files and other file "
"options. Repeating non-file options with a different argument will either "
"have no further effect, or override prior occurrences (those further to the "
"left on the command line)  of that option. Options which may be meaningfully "
"specified more than once are noted in the descriptions below."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:96
msgid ""
"Non-option arguments are object files or archives which are to be linked "
"together.  They may follow, precede, or be mixed in with command-line "
"options, except that an object file argument may not be placed between an "
"option and its argument."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:106
msgid ""
"Usually the linker is invoked with at least one object file, but you can "
"specify other forms of binary input files using E<.Li -l>, E<.Li -R>, and "
"the script command language. If E<.Em no> binary input files at all are "
"specified, the linker does not produce any output, and issues the message "
"E<.Li No input files>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:123
msgid ""
"If the linker cannot recognize the format of an object file, it will assume "
"that it is a linker script. A script specified in this way augments the main "
"linker script used for the link (either the default linker script or the one "
"specified by using E<.Li -T>).  This feature permits the linker to link "
"against a file which appears to be an object or an archive, but actually "
"merely defines some symbol values, or uses E<.Li INPUT> or E<.Li GROUP> to "
"load other objects. Note that specifying a script in this way merely "
"augments the main linker script; use the E<.Li -T> option to replace the "
"default linker script entirely.See Section E<.Dq Scripts>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:127
msgid ""
"For options whose names are a single letter, option arguments must either "
"follow the option letter without intervening whitespace, or be given as "
"separate arguments immediately following the option that requires them."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:144
msgid ""
"For options whose names are multiple letters, either one dash or two can "
"precede the option name; for example, E<.Li -trace-symbol> and E<.Li "
"--trace-symbol> are equivalent. Note---there is one exception to this "
"rule. Multiple letter options that start with a lower case 'o' can only be "
"preceded by two dashes.  This is to reduce confusion with the E<.Li -o> "
"option. So for example E<.Li -omagic> sets the output file name to E<.Li "
"magic> whereas E<.Li --omagic> sets the NMAGIC flag on the output."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:153
msgid ""
"Arguments to multiple-letter options must either be separated from the "
"option name by an equals sign, or be given as separate arguments immediately "
"following the option that requires them. For example, E<.Li --trace-symbol "
"foo> and E<.Li --trace-symbol=foo> are equivalent. Unique abbreviations of "
"the names of multiple-letter options are accepted."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:159
msgid ""
"Note---if the linker is being invoked indirectly, via a compiler driver "
"(e.g.  E<.Li gcc>)  then all the linker command line options should be "
"prefixed by E<.Li -Wl,> (or whatever is appropriate for the particular "
"compiler driver) like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:162
#, no-wrap
msgid "  gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:166
msgid ""
"This is important, because otherwise the compiler driver program may "
"silently drop the linker options, resulting in a bad link."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:168
msgid ""
"Here is a table of the generic command line switches accepted by the GNU "
"linker:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:170
#, no-wrap
msgid "@ Va file"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:179
msgid ""
"Read command-line options from E<.Va file>.  The options read are inserted "
"in place of the original @ E<.Va file> option. If E<.Va file> does not "
"exist, or cannot be read, then the option will be treated literally, and not "
"removed."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:190
msgid ""
"Options in E<.Va file> are separated by whitespace. A whitespace character "
"may be included in an option by surrounding the entire option in either "
"single or double quotes.  Any character (including a backslash) may be "
"included by prefixing the character to be included with a backslash. The "
"E<.Va file> may itself contain additional @ E<.Va file> options; any such "
"options will be processed recursively."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:191
#, no-wrap
msgid "-a Va keyword"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:205
msgid ""
"This option is supported for HP/UX compatibility. The E<.Va keyword> "
"argument must be one of the strings E<.Li archive>, E<.Li shared>, or E<.Li "
"default>.  E<.Li -aarchive> is functionally equivalent to E<.Li -Bstatic>, "
"and the other two keywords are functionally equivalent to E<.Li -Bdynamic>.  "
"This option may be used any number of times."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:206
#, no-wrap
msgid "-A Va architecture"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:207
#, no-wrap
msgid "--architecture= Va architecture"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:218
msgid ""
"In the current release of E<.Xr ld>, this option is useful only for the "
"Intel 960 family of architectures. In that E<.Xr ld> configuration, the "
"E<.Va architecture> argument identifies the particular architecture in the "
"960 family, enabling some safeguards and modifying the archive-library "
"search path.See Section E<.Dq i960>, for details."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:222
msgid ""
"Future releases of E<.Xr ld> may support similar functionality for other "
"architecture families."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:223
#, no-wrap
msgid "-b Va input-format"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:224
#, no-wrap
msgid "--format= Va input-format"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:243
msgid ""
"E<.Xr ld> may be configured to support more than one kind of object file. If "
"your E<.Xr ld> is configured this way, you can use the E<.Li -b> option to "
"specify the binary format for input object files that follow this option on "
"the command line. Even when E<.Xr ld> is configured to support alternative "
"object formats, you don't usually need to specify this, as E<.Xr ld> should "
"be configured to expect as a default input format the most usual format on "
"each machine.  E<.Va input-format> is a text string, the name of a "
"particular format supported by the BFD libraries.  (You can list the "
"available binary formats with E<.Li objdump -i>.)  See Section.Dq BFD ."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:251
msgid ""
"You may want to use this option if you are linking files with an unusual "
"binary format. You can also use E<.Li -b> to switch formats explicitly (when "
"linking object files of different formats), by including E<.Li -b Va "
"input-format> before each group of object files in a particular format."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:258
msgid ""
"The default format is taken from the environment variable E<.Li GNUTARGET>.  "
"See Section.Dq Environment .  You can also define the input format from a "
"script, using the command E<.Li TARGET>; see Format Commands."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:259
#, no-wrap
msgid "-c Va MRI-commandfile"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:260
#, no-wrap
msgid "--mri-script= Va MRI-commandfile"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:278
msgid ""
"For compatibility with linkers produced by MRI, E<.Xr ld> accepts script "
"files written in an alternate, restricted command language, described in "
"MRI,,MRI Compatible Script Files. Introduce MRI script files with the option "
"E<.Li -c>; use the E<.Li -T> option to run linker scripts written in the "
"general-purpose E<.Xr ld> scripting language. If E<.Va MRI-cmdfile> does not "
"exist, E<.Xr ld> looks for it in the directories specified by any E<.Li -L> "
"options."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:279
#, no-wrap
msgid "-d"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:280
#, no-wrap
msgid "-dc"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:281
#, no-wrap
msgid "-dp"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:290
msgid ""
"These three options are equivalent; multiple forms are supported for "
"compatibility with other linkers. They assign space to common symbols even "
"if a relocatable output file is specified (with E<.Li -r>).  The script "
"command E<.Li FORCE_COMMON_ALLOCATION> has the same effect.See Section E<.Dq "
"Miscellaneous Commands>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:291
#, no-wrap
msgid "-e Va entry"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:292
#, no-wrap
msgid "--entry= Va entry"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:308
msgid ""
"Use E<.Va entry> as the explicit symbol for beginning execution of your "
"program, rather than the default entry point. If there is no symbol named "
"E<.Va entry>, the linker will try to parse E<.Va entry> as a number, and use "
"that as the entry address (the number will be interpreted in base 10; you "
"may use a leading E<.Li 0x> for base 16, or a leading E<.Li 0> for base "
"8).See Section E<.Dq Entry Point>, for a discussion of defaults and other "
"ways of specifying the entry point."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:309
#, no-wrap
msgid "--exclude-libs Va lib, Va lib,..."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:318
msgid ""
"Specifies a list of archive libraries from which symbols should not be "
"automatically exported. The library names may be delimited by commas or "
"colons. Specifying E<.Li --exclude-libs ALL> excludes symbols in all archive "
"libraries from automatic export. This option is available only for the i386 "
"PE targeted port of the linker and for ELF targeted ports. For i386 PE, "
"symbols explicitly listed in a .def file are still exported, regardless of "
"this option. For ELF targeted ports, symbols affected by this option will be "
"treated as hidden."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:319
#, no-wrap
msgid "-E"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:320
#, no-wrap
msgid "--export-dynamic"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:324
msgid ""
"When creating a dynamically linked executable, add all symbols to the "
"dynamic symbol table. The dynamic symbol table is the set of symbols which "
"are visible from dynamic objects at run time."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:328
msgid ""
"If you do not use this option, the dynamic symbol table will normally "
"contain only those symbols which are referenced by some dynamic object "
"mentioned in the link."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:334
msgid ""
"If you use E<.Li dlopen> to load a dynamic object which needs to refer back "
"to the symbols defined by the program, rather than some other dynamic "
"object, then you will probably need to use this option when linking the "
"program itself."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:339
msgid ""
"You can also use the dynamic list to control what symbols should be added to "
"the dynamic symbol table if the output format supports it. See the "
"description of E<.Li --dynamic-list>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:340
#, no-wrap
msgid "-EB"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:342
msgid "Link big-endian objects. This affects the default output format."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:343
#, no-wrap
msgid "-EL"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:345
msgid "Link little-endian objects. This affects the default output format."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:346
#, no-wrap
msgid "-f"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:347
#, no-wrap
msgid "--auxiliary Va name"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:353
msgid ""
"When creating an ELF shared object, set the internal DT_AUXILIARY field to "
"the specified name. This tells the dynamic linker that the symbol table of "
"the shared object should be used as an auxiliary filter on the symbol table "
"of the shared object E<.Va name>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:366
msgid ""
"If you later link a program against this filter object, then, when you run "
"the program, the dynamic linker will see the DT_AUXILIARY field. If the "
"dynamic linker resolves any symbols from the filter object, it will first "
"check whether there is a definition in the shared object E<.Va name>.  If "
"there is one, it will be used instead of the definition in the filter "
"object.  The shared object E<.Va name> need not exist. Thus the shared "
"object E<.Va name> may be used to provide an alternative implementation of "
"certain functions, perhaps for debugging or for machine specific "
"performance."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:369
msgid ""
"This option may be specified more than once. The DT_AUXILIARY entries will "
"be created in the order in which they appear on the command line."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:370
#, no-wrap
msgid "-F Va name"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:371
#, no-wrap
msgid "--filter Va name"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:377
msgid ""
"When creating an ELF shared object, set the internal DT_FILTER field to the "
"specified name. This tells the dynamic linker that the symbol table of the "
"shared object which is being created should be used as a filter on the "
"symbol table of the shared object E<.Va name>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:387
msgid ""
"If you later link a program against this filter object, then, when you run "
"the program, the dynamic linker will see the DT_FILTER field. The dynamic "
"linker will resolve symbols according to the symbol table of the filter "
"object as usual, but it will actually link to the definitions found in the "
"shared object E<.Va name>.  Thus the filter object can be used to select a "
"subset of the symbols provided by the object E<.Va name>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:403
msgid ""
"Some older linkers used the E<.Op -F> option throughout a compilation "
"toolchain for specifying object-file format for both input and output object "
"files. The GNU linker uses other mechanisms for this purpose: the E<.Op -b>, "
"E<.Op --format>, E<.Op --oformat> options, the E<.Li TARGET> command in "
"linker scripts, and the E<.Li GNUTARGET> environment variable. The GNU "
"linker will ignore the E<.Op -F> option when not creating an ELF shared "
"object."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:404
#, no-wrap
msgid "-fini Va name"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:410
msgid ""
"When creating an ELF executable or shared object, call NAME when the "
"executable or shared object is unloaded, by setting DT_FINI to the address "
"of the function.  By default, the linker uses E<.Li _fini> as the function "
"to call."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:411
#, no-wrap
msgid "-g"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:413
msgid "Ignored. Provided for compatibility with other tools."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:414
#, no-wrap
msgid "-G Va value"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:415
#, no-wrap
msgid "--gpsize= Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:421
msgid ""
"Set the maximum size of objects to be optimized using the GP register to "
"E<.Va size>.  This is only meaningful for object file formats such as MIPS "
"ECOFF which supports putting large and small objects into different "
"sections. This is ignored for other object file formats."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:422
#, no-wrap
msgid "-h Va name"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:423
#, no-wrap
msgid "-soname= Va name"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:429
msgid ""
"When creating an ELF shared object, set the internal DT_SONAME field to the "
"specified name. When an executable is linked with a shared object which has "
"a DT_SONAME field, then when the executable is run the dynamic linker will "
"attempt to load the shared object specified by the DT_SONAME field rather "
"than the using the file name given to the linker."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:430
#, no-wrap
msgid "-i"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:433
msgid "Perform an incremental link (same as option E<.Li -r>)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:434
#, no-wrap
msgid "-init Va name"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:440
msgid ""
"When creating an ELF executable or shared object, call NAME when the "
"executable or shared object is loaded, by setting DT_INIT to the address of "
"the function.  By default, the linker uses E<.Li _init> as the function to "
"call."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:441
#, no-wrap
msgid "-l Va namespec"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:442
#, no-wrap
msgid "--library= Va namespec"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:455
msgid ""
"Add the archive or object file specified by E<.Va namespec> to the list of "
"files to link. This option may be used any number of times.  If E<.Va "
"namespec> is of the form E<.Pa : Va filename>, E<.Xr ld> will search the "
"library path for a file called E<.Va filename>, otherise it will search the "
"library path for a file called E<.Pa lib Va namespec.a>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:473
msgid ""
"On systems which support shared libraries, E<.Xr ld> may also search for "
"files other than E<.Pa lib Va namespec.a>.  Specifically, on ELF and SunOS "
"systems, E<.Xr ld> will search a directory for a library called E<.Pa lib Va "
"namespec.so> before searching for one called E<.Pa lib Va namespec.a>.  (By "
"convention, a E<.Li .so> extension indicates a shared library.) Note that "
"this behavior does not apply to E<.Pa : Va filename>, which always specifies "
"a file called E<.Va filename>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:480
msgid ""
"The linker will search an archive only once, at the location where it is "
"specified on the command line. If the archive defines a symbol which was "
"undefined in some object which appeared before the archive on the command "
"line, the linker will include the appropriate file(s) from the "
"archive. However, an undefined symbol in an object appearing later on the "
"command line will not cause the linker to search the archive again."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:484
msgid ""
"See the E<.Op -(> option for a way to force the linker to search archives "
"multiple times."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:486
msgid "You may list the same archive multiple times on the command line."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:491
msgid ""
"This type of archive searching is standard for Unix linkers. However, if you "
"are using E<.Xr ld> on AIX, note that it is different from the behaviour of "
"the AIX linker."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:492
#, no-wrap
msgid "-L Va searchdir"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:493
#, no-wrap
msgid "--library-path= Va searchdir"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:508
msgid ""
"Add path E<.Va searchdir> to the list of paths that E<.Xr ld> will search "
"for archive libraries and E<.Xr ld> control scripts. You may use this option "
"any number of times. The directories are searched in the order in which they "
"are specified on the command line.  Directories specified on the command "
"line are searched before the default directories. All E<.Op -L> options "
"apply to all E<.Op -l> options, regardless of the order in which the options "
"appear."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:518
msgid ""
"If E<.Va searchdir> begins with E<.Li =>, then the E<.Li => will be replaced "
"by the E<.Em sysroot prefix>, a path specified when the linker is "
"configured."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:525
msgid ""
"The default set of paths searched (without being specified with E<.Li -L>)  "
"depends on which emulation mode E<.Xr ld> is using, and in some cases also "
"on how it was configured.See Section E<.Dq Environment>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:530
msgid ""
"The paths can also be specified in a link script with the E<.Li SEARCH_DIR> "
"command. Directories specified this way are searched at the point in which "
"the linker script appears in the command line."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:531
#, no-wrap
msgid "-m Va emulation"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:539
msgid ""
"Emulate the E<.Va emulation> linker. You can list the available emulations "
"with the E<.Li --verbose> or E<.Li -V> options."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:545
msgid ""
"If the E<.Li -m> option is not used, the emulation is taken from the E<.Li "
"LDEMULATION> environment variable, if that is defined."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:547
msgid "Otherwise, the default emulation depends upon how the linker was configured."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:548
#, no-wrap
msgid "-M"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:549
#, no-wrap
msgid "--print-map"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:552
msgid ""
"Print a link map to the standard output. A link map provides information "
"about the link, including the following:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:556
msgid "Where object files are mapped into memory."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:558
msgid "How common symbols are allocated."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:561
msgid ""
"All archive members included in the link, with a mention of the symbol which "
"caused the archive member to be brought in."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:563
msgid "The values assigned to symbols."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:570
msgid ""
"Note - symbols whose values are computed by an expression which involves a "
"reference to a previous value of the same symbol may not have correct result "
"displayed in the link map. This is because the linker discards intermediate "
"results and only retains the final value of an expression. Under such "
"circumstances the linker will display the final value enclosed by square "
"brackets. Thus for example a linker script containing:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:575
#, no-wrap
msgid ""
"   foo = 1\n"
"   foo = foo * 4\n"
"   foo = foo + 8\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:580
msgid ""
"will produce the following output in the link map if the E<.Op -M> option is "
"used:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:585
#, no-wrap
msgid ""
"   0x00000001                foo = 0x1\n"
"   [0x0000000c]                foo = (foo * 0x4)\n"
"   [0x0000000c]                foo = (foo + 0x8)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:588
msgid "See Expressions for more information about expressions in linker scripts."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:590
#, no-wrap
msgid "-n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:591
#, no-wrap
msgid "--nmagic"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:595
msgid ""
"Turn off page alignment of sections, and mark the output as E<.Li NMAGIC> if "
"possible."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:596
#, no-wrap
msgid "-N"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:597
#, no-wrap
msgid "--omagic"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:604
msgid ""
"Set the text and data sections to be readable and writable. Also, do not "
"page-align the data segment, and disable linking against shared "
"libraries. If the output format supports Unix style magic numbers, mark the "
"output as E<.Li OMAGIC>.  Note: Although a writable text section is allowed "
"for PE-COFF targets, it does not conform to the format specification "
"published by Microsoft."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:605
#, no-wrap
msgid "--no-omagic"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:613
msgid ""
"This option negates most of the effects of the E<.Op -N> option. It sets the "
"text section to be read-only, and forces the data segment to be "
"page-aligned. Note - this option does not enable linking against shared "
"libraries. Use E<.Op -Bdynamic> for this."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:614
#, no-wrap
msgid "-o Va output"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:615
#, no-wrap
msgid "--output= Va output"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:625
msgid ""
"Use E<.Va output> as the name for the program produced by E<.Xr ld>; if this "
"option is not specified, the name E<.Pa a.out> is used by default. The "
"script command E<.Li OUTPUT> can also specify the output file name."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:626
#, no-wrap
msgid "-O Va level"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:633
msgid ""
"If E<.Va level> is a numeric values greater than zero E<.Xr ld> optimizes "
"the output. This might take significantly longer and therefore probably "
"should only be enabled for the final binary."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:634
#, no-wrap
msgid "-q"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:635
#, no-wrap
msgid "--emit-relocs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:639
msgid ""
"Leave relocation sections and contents in fully linked executables. Post "
"link analysis and optimization tools may need this information in order to "
"perform correct modifications of executables. This results in larger "
"executables."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:641
msgid "This option is currently only supported on ELF platforms."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:642
#, no-wrap
msgid "--force-dynamic"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:645
msgid ""
"Force the output file to have dynamic sections. This option is specific to "
"VxWorks targets."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:646
#, no-wrap
msgid "-r"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:647
#, no-wrap
msgid "--relocatable"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:661
msgid ""
"Generate relocatable output---i.e., generate an output file that can in turn "
"serve as input to E<.Xr ld>.  This is often called E<.Em partial linking>.  "
"As a side effect, in environments that support standard Unix magic numbers, "
"this option also sets the output file's magic number to E<.Li OMAGIC>.  If "
"this option is not specified, an absolute file is produced. When linking C++ "
"programs, this option E<.Em will not> resolve references to constructors; to "
"do that, use E<.Li -Ur>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:668
msgid ""
"When an input file does not have the same format as the output file, partial "
"linking is only supported if that input file does not contain any "
"relocations.  Different output formats can have further restrictions; for "
"example some E<.Li a.out> -based formats do not support partial linking with "
"input files in other formats at all."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:671
msgid "This option does the same thing as E<.Li -i>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:672
#, no-wrap
msgid "-R Va filename"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:673
#, no-wrap
msgid "--just-symbols= Va filename"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:679
msgid ""
"Read symbol names and their addresses from E<.Va filename>, but do not "
"relocate it or include it in the output. This allows your output file to "
"refer symbolically to absolute locations of memory defined in other "
"programs. You may use this option more than once."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:686 /usr/src/contrib/binutils/ld/ld.7:1390
msgid ""
"For compatibility with other ELF linkers, if the E<.Op -R> option is "
"followed by a directory name, rather than a file name, it is treated as the "
"E<.Op -rpath> option."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:687
#, no-wrap
msgid "-s"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:688
#, no-wrap
msgid "--strip-all"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:690
msgid "Omit all symbol information from the output file."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:691
#, no-wrap
msgid "-S"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:692
#, no-wrap
msgid "--strip-debug"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:694
msgid "Omit debugger symbol information (but not all symbols) from the output file."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:695
#, no-wrap
msgid "-t"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:696
#, no-wrap
msgid "--trace"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:700
msgid "Print the names of the input files as E<.Xr ld> processes them."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:701
#, no-wrap
msgid "-T Va scriptfile"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:702
#, no-wrap
msgid "--script= Va scriptfile"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:720
msgid ""
"Use E<.Va scriptfile> as the linker script. This script replaces E<.Xr ld> "
"\\&'s default linker script (rather than adding to it), so E<.Va "
"commandfile> must specify everything necessary to describe the output "
"file.See Section E<.Dq Scripts>.  If E<.Va scriptfile> does not exist in the "
"current directory, E<.Li ld> looks for it in the directories specified by "
"any preceding E<.Li -L> options. Multiple E<.Li -T> options accumulate."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:721
#, no-wrap
msgid "-dT Va scriptfile"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:722
#, no-wrap
msgid "--default-script= Va scriptfile"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:727
msgid ""
"Use E<.Va scriptfile> as the default linker script.See Section E<.Dq "
"Scripts>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:738
msgid ""
"This option is similar to the E<.Op --script> option except that processing "
"of the script is delayed until after the rest of the command line has been "
"processed. This allows options placed after the E<.Op --default-script> "
"option on the command line to affect the behaviour of the linker script, "
"which can be important when the linker command line cannot be directly "
"controlled by the user. (eg because the command line is being constructed by "
"another tool, such as E<.Li gcc>)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:739
#, no-wrap
msgid "-u Va symbol"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:740
#, no-wrap
msgid "--undefined= Va symbol"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:750
msgid ""
"Force E<.Va symbol> to be entered in the output file as an undefined "
"symbol. Doing this may, for example, trigger linking of additional modules "
"from standard libraries.  E<.Li -u> may be repeated with different option "
"arguments to enter additional undefined symbols. This option is equivalent "
"to the E<.Li EXTERN> linker script command."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:751
#, no-wrap
msgid "-Ur"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:771
msgid ""
"For anything other than C++ programs, this option is equivalent to E<.Li "
"-r>: it generates relocatable output---i.e., an output file that can in turn "
"serve as input to E<.Xr ld>.  When linking C++ programs, E<.Li -Ur> E<.Em "
"does> resolve references to constructors, unlike E<.Li -r>.  It does not "
"work to use E<.Li -Ur> on files that were themselves linked with E<.Li -Ur>; "
"once the constructor table has been built, it cannot be added to. Use E<.Li "
"-Ur> only for the last partial link, and E<.Li -r> for the others."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:772
#, no-wrap
msgid "--unique[= Va SECTION]"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:782
msgid ""
"Creates a separate output section for every input section matching E<.Va "
"SECTION>, or if the optional wildcard E<.Va SECTION> argument is missing, "
"for every orphan input section. An orphan section is one not specifically "
"mentioned in a linker script. You may use this option multiple times on the "
"command line; It prevents the normal merging of input sections with the same "
"name, overriding output section assignments in a linker script."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:783
#, no-wrap
msgid "-v"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:784
#, no-wrap
msgid "--version"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:785
#, no-wrap
msgid "-V"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:791
msgid ""
"Display the version number for E<.Xr ld>.  The E<.Op -V> option also lists "
"the supported emulations."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:792
#, no-wrap
msgid "-x"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:793
#, no-wrap
msgid "--discard-all"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:795
msgid "Delete all local symbols."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:796
#, no-wrap
msgid "-X"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:797
#, no-wrap
msgid "--discard-locals"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:804
msgid ""
"Delete all temporary local symbols. (These symbols start with "
"system-specific local label prefixes, typically E<.Li .L> for ELF systems or "
"E<.Li L> for traditional a.out systems.)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:805
#, no-wrap
msgid "-y Va symbol"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:806
#, no-wrap
msgid "--trace-symbol= Va symbol"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:811
msgid ""
"Print the name of each linked file in which E<.Va symbol> appears. This "
"option may be given any number of times. On many systems it is necessary to "
"prepend an underscore."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:814
msgid ""
"This option is useful when you have an undefined symbol in your link but "
"don't know where the reference is coming from."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:815
#, no-wrap
msgid "-Y Va path"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:819
msgid ""
"Add E<.Va path> to the default library search path. This option exists for "
"Solaris compatibility."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:820
#, no-wrap
msgid "-z Va keyword"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:822
msgid "The recognized keywords are:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:823
#, no-wrap
msgid "combreloc"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:826
msgid ""
"Combines multiple reloc sections and sorts them to make dynamic symbol "
"lookup caching possible."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:827
#, no-wrap
msgid "defs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:830
msgid ""
"Disallows undefined symbols in object files. Undefined symbols in shared "
"libraries are still allowed."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:831
#, no-wrap
msgid "execstack"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:833
msgid "Marks the object as requiring executable stack."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:834
#, no-wrap
msgid "initfirst"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:840
msgid ""
"This option is only meaningful when building a shared object. It marks the "
"object so that its runtime initialization will occur before the runtime "
"initialization of any other objects brought into the process at the same "
"time. Similarly the runtime finalization of the object will occur after the "
"runtime finalization of any other objects."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:841
#, no-wrap
msgid "interpose"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:844
msgid ""
"Marks the object that its symbol table interposes before all symbols but the "
"primary executable."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:845
#, no-wrap
msgid "lazy"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:849
msgid ""
"When generating an executable or shared library, mark it to tell the dynamic "
"linker to defer function call resolution to the point when the function is "
"called (lazy binding), rather than at load time. Lazy binding is the "
"default."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:850
#, no-wrap
msgid "loadfltr"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:852
msgid "Marks the object that its filters be processed immediately at runtime."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:853
#, no-wrap
msgid "muldefs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:855
msgid "Allows multiple definitions."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:856
#, no-wrap
msgid "nocombreloc"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:858
msgid "Disables multiple reloc sections combining."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:859
#, no-wrap
msgid "nocopyreloc"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:861
msgid "Disables production of copy relocs."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:862
#, no-wrap
msgid "nodefaultlib"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:865
msgid ""
"Marks the object that the search for dependencies of this object will ignore "
"any default library search paths."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:866
#, no-wrap
msgid "nodelete"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:868
msgid "Marks the object shouldn't be unloaded at runtime."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:869
#, no-wrap
msgid "nodlopen"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:872
msgid "Marks the object not available to E<.Li dlopen>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:873
#, no-wrap
msgid "nodump"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:876
msgid "Marks the object can not be dumped by E<.Li dldump>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:877
#, no-wrap
msgid "noexecstack"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:879
msgid "Marks the object as not requiring executable stack."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:880
#, no-wrap
msgid "norelro"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:884
msgid "Don't create an ELF E<.Li PT_GNU_RELRO> segment header in the object."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:885
#, no-wrap
msgid "now"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:890
msgid ""
"When generating an executable or shared library, mark it to tell the dynamic "
"linker to resolve all symbols when the program is started, or when the "
"shared library is linked to using dlopen, instead of deferring function call "
"resolution to the point when the function is first called."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:891
#, no-wrap
msgid "origin"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:893
msgid "Marks the object may contain $ORIGIN."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:894
#, no-wrap
msgid "relro"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:898
msgid "Create an ELF E<.Li PT_GNU_RELRO> segment header in the object."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:899
#, no-wrap
msgid "max-page-size= Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:902
msgid "Set the emulation maximum page size to E<.Va value>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:903
#, no-wrap
msgid "common-page-size= Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:906
msgid "Set the emulation common page size to E<.Va value>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:909
msgid "Other keywords are ignored for Solaris compatibility."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:910
#, no-wrap
msgid "-( Va archives -)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:911
#, no-wrap
msgid "--start-group Va archives --end-group"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:918
msgid ""
"The E<.Va archives> should be a list of archive files. They may be either "
"explicit file names, or E<.Li -l> options."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:926
msgid ""
"The specified archives are searched repeatedly until no new undefined "
"references are created. Normally, an archive is searched only once in the "
"order that it is specified on the command line. If a symbol in that archive "
"is needed to resolve an undefined symbol referred to by an object in an "
"archive that appears later on the command line, the linker would not be able "
"to resolve that reference. By grouping the archives, they all be searched "
"repeatedly until all possible references are resolved."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:929
msgid ""
"Using this option has a significant performance cost. It is best to use it "
"only when there are unavoidable circular references between two or more "
"archives."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:930
#, no-wrap
msgid "--accept-unknown-input-arch"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:931
#, no-wrap
msgid "--no-accept-unknown-input-arch"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:939
msgid ""
"Tells the linker to accept input files whose architecture cannot be "
"recognised.  The assumption is that the user knows what they are doing and "
"deliberately wants to link in these unknown input files. This was the "
"default behaviour of the linker, before release 2.14. The default behaviour "
"from release 2.14 onwards is to reject such input files, and so the E<.Li "
"--accept-unknown-input-arch> option has been added to restore the old "
"behaviour."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:940
#, no-wrap
msgid "--as-needed"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:941
#, no-wrap
msgid "--no-as-needed"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:954
msgid ""
"This option affects ELF DT_NEEDED tags for dynamic libraries mentioned on "
"the command line after the E<.Op --as-needed> option. Normally, the linker "
"will add a DT_NEEDED tag for each dynamic library mentioned on the command "
"line, regardless of whether the library is actually needed.  E<.Op "
"--as-needed> causes DT_NEEDED tags to only be emitted for libraries that "
"satisfy some symbol reference from regular objects which is undefined at the "
"point that the library was linked.  E<.Op --no-as-needed> restores the "
"default behaviour."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:955
#, no-wrap
msgid "--add-needed"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:956
#, no-wrap
msgid "--no-add-needed"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:967
msgid ""
"This option affects the treatment of dynamic libraries from ELF DT_NEEDED "
"tags in dynamic libraries mentioned on the command line after the E<.Op "
"--no-add-needed> option. Normally, the linker will add a DT_NEEDED tag for "
"each dynamic library from DT_NEEDED tags.  E<.Op --no-add-needed> causes "
"DT_NEEDED tags will never be emitted for those libraries from DT_NEEDED "
"tags.  E<.Op --add-needed> restores the default behaviour."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:968
#, no-wrap
msgid "-assert Va keyword"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:970
msgid "This option is ignored for SunOS compatibility."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:971
#, no-wrap
msgid "-Bdynamic"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:972
#, no-wrap
msgid "-dy"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:973
#, no-wrap
msgid "-call_shared"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:981
msgid ""
"Link against dynamic libraries. This is only meaningful on platforms for "
"which shared libraries are supported. This option is normally the default on "
"such platforms. The different variants of this option are for compatibility "
"with various systems. You may use this option multiple times on the command "
"line: it affects library searching for E<.Op -l> options which follow it."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:982
#, no-wrap
msgid "-Bgroup"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:992
msgid ""
"Set the E<.Li DF_1_GROUP> flag in the E<.Li DT_FLAGS_1> entry in the dynamic "
"section. This causes the runtime linker to handle lookups in this object and "
"its dependencies to be performed only inside the group.  E<.Op "
"--unresolved-symbols=report-all> is implied. This option is only meaningful "
"on ELF platforms which support shared libraries."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:993
#, no-wrap
msgid "-Bstatic"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:994
#, no-wrap
msgid "-dn"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:995
#, no-wrap
msgid "-non_shared"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:996
#, no-wrap
msgid "-static"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1009
msgid ""
"Do not link against shared libraries. This is only meaningful on platforms "
"for which shared libraries are supported. The different variants of this "
"option are for compatibility with various systems. You may use this option "
"multiple times on the command line: it affects library searching for E<.Op "
"-l> options which follow it. This option also implies E<.Op "
"--unresolved-symbols=report-all>.  This option can be used with E<.Op "
"-shared>.  Doing so means that a shared library is being created but that "
"all of the library's external references must be resolved by pulling in "
"entries from static libraries."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1010
#, no-wrap
msgid "-Bsymbolic"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1016
msgid ""
"When creating a shared library, bind references to global symbols to the "
"definition within the shared library, if any. Normally, it is possible for a "
"program linked against a shared library to override the definition within "
"the shared library. This option is only meaningful on ELF platforms which "
"support shared libraries."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1017
#, no-wrap
msgid "-Bsymbolic-functions"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1021
msgid ""
"When creating a shared library, bind references to global function symbols "
"to the definition within the shared library, if any. This option is only "
"meaningful on ELF platforms which support shared libraries."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1022
#, no-wrap
msgid "--dynamic-list= Va dynamic-list-file"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1029
msgid ""
"Specify the name of a dynamic list file to the linker. This is typically "
"used when creating shared libraries to specify a list of global symbols "
"whose references shouldn't be bound to the definition within the shared "
"library, or creating dynamically linked executables to specify a list of "
"symbols which should be added to the symbol table in the executable. This "
"option is only meaningful on ELF platforms which support shared libraries."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1032
msgid ""
"The format of the dynamic list is the same as the version node without scope "
"and node name. See VERSION for more information."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1033
#, no-wrap
msgid "--dynamic-list-data"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1035
msgid "Include all global data symbols to the dynamic list."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1036
#, no-wrap
msgid "--dynamic-list-cpp-new"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1039
msgid ""
"Provide the builtin dynamic list for C++ operator new and delete. It is "
"mainly useful for building shared libstdc++."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1040
#, no-wrap
msgid "--dynamic-list-cpp-typeinfo"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1042
msgid "Provide the builtin dynamic list for C++ runtime type identification."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1043
#, no-wrap
msgid "--check-sections"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1044
#, no-wrap
msgid "--no-check-sections"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1053
msgid ""
"Asks the linker E<.Em not> to check section addresses after they have been "
"assigned to see if there are any overlaps. Normally the linker will perform "
"this check, and if it finds any overlaps it will produce suitable error "
"messages. The linker does know about, and does make allowances for sections "
"in overlays. The default behaviour can be restored by using the command line "
"switch E<.Op --check-sections>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1054
#, no-wrap
msgid "--cref"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1058
msgid ""
"Output a cross reference table. If a linker map file is being generated, the "
"cross reference table is printed to the map file. Otherwise, it is printed "
"on the standard output."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1064
msgid ""
"The format of the table is intentionally simple, so that it may be easily "
"processed by a script if necessary. The symbols are printed out, sorted by "
"name. For each symbol, a list of file names is given. If the symbol is "
"defined, the first file listed is the location of the definition. The "
"remaining files contain references to the symbol."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1065
#, no-wrap
msgid "--no-define-common"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1071
msgid ""
"This option inhibits the assignment of addresses to common symbols. The "
"script command E<.Li INHIBIT_COMMON_ALLOCATION> has the same effect.See "
"Section E<.Dq Miscellaneous Commands>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1083
msgid ""
"The E<.Li --no-define-common> option allows decoupling the decision to "
"assign addresses to Common symbols from the choice of the output file type; "
"otherwise a non-Relocatable output type forces assigning addresses to Common "
"symbols. Using E<.Li --no-define-common> allows Common symbols that are "
"referenced from a shared library to be assigned addresses only in the main "
"program. This eliminates the unused duplicate space in the shared library, "
"and also prevents any possible confusion over resolving to the wrong "
"duplicate when there are many dynamic modules with specialized search paths "
"for runtime symbol resolution."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1084
#, no-wrap
msgid "--defsym Va symbol= Va expression"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1104
msgid ""
"Create a global symbol in the output file, containing the absolute address "
"given by E<.Va expression>.  You may use this option as many times as "
"necessary to define multiple symbols in the command line. A limited form of "
"arithmetic is supported for the E<.Va expression> in this context: you may "
"give a hexadecimal constant or the name of an existing symbol, or use E<.Li "
"+> and E<.Li -> to add or subtract hexadecimal constants or symbols. If you "
"need more elaborate expressions, consider using the linker command language "
"from a script (see Section E<.Dq Assignments>).  E<.Em Note:> there should "
"be no white space between E<.Va symbol>, the equals sign (\\(lq=\\(rq), and "
"E<.Va expression>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1105
#, no-wrap
msgid "--demangle[= Va style]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1106
#, no-wrap
msgid "--no-demangle"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1117
msgid ""
"These options control whether to demangle symbol names in error messages and "
"other output. When the linker is told to demangle, it tries to present "
"symbol names in a readable fashion: it strips leading underscores if they "
"are used by the object file format, and converts C++ mangled symbol names "
"into user readable names. Different compilers have different mangling "
"styles. The optional demangling style argument can be used to choose an "
"appropriate demangling style for your compiler. The linker will demangle by "
"default unless the environment variable E<.Li COLLECT_NO_DEMANGLE> is "
"set. These options may be used to override the default."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1118
#, no-wrap
msgid "--dynamic-linker Va file"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1122
msgid ""
"Set the name of the dynamic linker. This is only meaningful when generating "
"dynamically linked ELF executables. The default dynamic linker is normally "
"correct; don't use this unless you know what you are doing."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1123
#, no-wrap
msgid "--fatal-warnings"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1125
msgid "Treat all warnings as errors."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1126
#, no-wrap
msgid "--force-exe-suffix"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1128
msgid "Make sure that an output file has a .exe suffix."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1141
msgid ""
"If a successfully built fully linked output file does not have a E<.Li .exe> "
"or E<.Li .dll> suffix, this option forces the linker to copy the output file "
"to one of the same name with a E<.Li .exe> suffix. This option is useful "
"when using unmodified Unix makefiles on a Microsoft Windows host, since some "
"versions of Windows won't run an image unless it ends in a E<.Li .exe> "
"suffix."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1142
#, no-wrap
msgid "--gc-sections"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1143
#, no-wrap
msgid "--no-gc-sections"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1153
msgid ""
"Enable garbage collection of unused input sections. It is ignored on targets "
"that do not support this option. This option is not compatible with E<.Li "
"-r> or E<.Li --emit-relocs>.  The default behaviour (of not performing this "
"garbage collection) can be restored by specifying E<.Li --no-gc-sections> on "
"the command line."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1154
#, no-wrap
msgid "--print-gc-sections"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1155
#, no-wrap
msgid "--no-print-gc-sections"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1164
msgid ""
"List all sections removed by garbage collection. The listing is printed on "
"stderr. This option is only effective if garbage collection has been enabled "
"via the E<.Li --gc-sections>)  option. The default behaviour (of not listing "
"the sections that are removed)  can be restored by specifying E<.Li "
"--no-print-gc-sections> on the command line."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1165
#, no-wrap
msgid "--help"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1167
msgid "Print a summary of the command-line options on the standard output and exit."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1168
#, no-wrap
msgid "--target-help"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1171
msgid ""
"Print a summary of all target specific options on the standard output and "
"exit."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1172
#, no-wrap
msgid "-Map Va mapfile"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1178
msgid ""
"Print a link map to the file E<.Va mapfile>.  See the description of the "
"E<.Op -M> option, above."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1179
#, no-wrap
msgid "--no-keep-memory"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1188
msgid ""
"E<.Xr ld> normally optimizes for speed over memory usage by caching the "
"symbol tables of input files in memory. This option tells E<.Xr ld> to "
"instead optimize for memory usage, by rereading the symbol tables as "
"necessary.  This may be required if E<.Xr ld> runs out of memory space while "
"linking a large executable."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1189
#, no-wrap
msgid "--no-undefined"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1190
#, no-wrap
msgid "-z defs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1196
msgid ""
"Report unresolved symbol references from regular object files. This is done "
"even if the linker is creating a non-symbolic shared library. The switch "
"E<.Op --[no-]allow-shlib-undefined> controls the behaviour for reporting "
"unresolved references found in shared libraries being linked in."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1197
#, no-wrap
msgid "--allow-multiple-definition"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1198
#, no-wrap
msgid "-z muldefs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1202
msgid ""
"Normally when a symbol is defined multiple times, the linker will report a "
"fatal error. These options allow multiple definitions and the first "
"definition will be used."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1203
#, no-wrap
msgid "--allow-shlib-undefined"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1204
#, no-wrap
msgid "--no-allow-shlib-undefined"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1211
msgid ""
"Allows (the default) or disallows undefined symbols in shared "
"libraries. This switch is similar to E<.Op --no-undefined> except that it "
"determines the behaviour when the undefined symbols are in a shared library "
"rather than a regular object file. It does not affect how undefined symbols "
"in regular object files are handled."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1222
msgid ""
"The reason that E<.Op --allow-shlib-undefined> is the default is that the "
"shared library being specified at link time may not be the same as the one "
"that is available at load time, so the symbols might actually be resolvable "
"at load time. Plus there are some systems, (eg BeOS) where undefined symbols "
"in shared libraries is normal. (The kernel patches them at load time to "
"select which function is most appropriate for the current architecture. This "
"is used for example to dynamically select an appropriate memset "
"function). Apparently it is also normal for HPPA shared libraries to have "
"undefined symbols."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1223
#, no-wrap
msgid "--no-undefined-version"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1227
msgid ""
"Normally when a symbol has an undefined version, the linker will ignore it.  "
"This option disallows symbols with undefined version and a fatal error will "
"be issued instead."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1228
#, no-wrap
msgid "--default-symver"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1231
msgid ""
"Create and use a default symbol version (the soname) for unversioned "
"exported symbols."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1232
#, no-wrap
msgid "--default-imported-symver"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1235
msgid ""
"Create and use a default symbol version (the soname) for unversioned "
"imported symbols."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1236
#, no-wrap
msgid "--no-warn-mismatch"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1246
msgid ""
"Normally E<.Xr ld> will give an error if you try to link together input "
"files that are mismatched for some reason, perhaps because they have been "
"compiled for different processors or for different endiannesses. This option "
"tells E<.Xr ld> that it should silently permit such possible errors. This "
"option should only be used with care, in cases when you have taken some "
"special action that ensures that the linker errors are inappropriate."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1247
#, no-wrap
msgid "--no-warn-search-mismatch"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1252
msgid ""
"Normally E<.Xr ld> will give a warning if it finds an incompatible library "
"during a library search.  This option silences the warning."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1253
#, no-wrap
msgid "--no-whole-archive"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1257
msgid ""
"Turn off the effect of the E<.Op --whole-archive> option for subsequent "
"archive files."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1258
#, no-wrap
msgid "--noinhibit-exec"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1263
msgid ""
"Retain the executable output file whenever it is still usable. Normally, the "
"linker will not produce an output file if it encounters errors during the "
"link process; it exits without writing an output file when it issues any "
"error whatsoever."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1264
#, no-wrap
msgid "-nostdlib"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1268
msgid ""
"Only search library directories explicitly specified on the command line.  "
"Library directories specified in linker scripts (including linker scripts "
"specified on the command line) are ignored."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1269
#, no-wrap
msgid "--oformat Va output-format"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1290
msgid ""
"E<.Xr ld> may be configured to support more than one kind of object file. If "
"your E<.Xr ld> is configured this way, you can use the E<.Li --oformat> "
"option to specify the binary format for the output object file. Even when "
"E<.Xr ld> is configured to support alternative object formats, you don't "
"usually need to specify this, as E<.Xr ld> should be configured to produce "
"as a default output format the most usual format on each machine.  E<.Va "
"output-format> is a text string, the name of a particular format supported "
"by the BFD libraries.  (You can list the available binary formats with E<.Li "
"objdump -i>.)  The script command E<.Li OUTPUT_FORMAT> can also specify the "
"output format, but this option overrides it.See Section E<.Dq BFD>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1291
#, no-wrap
msgid "-pie"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1292
#, no-wrap
msgid "--pic-executable"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1299
msgid ""
"Create a position independent executable. This is currently only supported "
"on ELF platforms. Position independent executables are similar to shared "
"libraries in that they are relocated by the dynamic linker to the virtual "
"address the OS chooses for them (which can vary between invocations). Like "
"normal dynamically linked executables they can be executed and symbols "
"defined in the executable cannot be overridden by shared libraries."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1300
#, no-wrap
msgid "-qmagic"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1302
msgid "This option is ignored for Linux compatibility."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1303
#, no-wrap
msgid "-Qy"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1305
msgid "This option is ignored for SVR4 compatibility."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1306
#, no-wrap
msgid "--relax"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1314
msgid ""
"An option with machine dependent effects. This option is only supported on a "
"few targets.See Section E<.Dq H8/300>.  See Section.Dq i960 .  See "
"Section.Dq Xtensa .  See Section.Dq M68HC11/68HC12 .  See Section.Dq PowerPC "
"ELF32 ."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1320
msgid ""
"On some platforms, the E<.Li --relax> option performs global optimizations "
"that become possible when the linker resolves addressing in the program, "
"such as relaxing address modes and synthesizing new instructions in the "
"output object file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1324
msgid ""
"On some platforms these link time global optimizations may make symbolic "
"debugging of the resulting executable impossible. This is known to be the "
"case for the Matsushita MN10200 and MN10300 family of processors."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1328
msgid ""
"On platforms where this is not supported, E<.Li --relax> is accepted, but "
"ignored."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1329
#, no-wrap
msgid "--retain-symbols-file Va filename"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1339
msgid ""
"Retain E<.Em only> the symbols listed in the file E<.Va filename>, "
"discarding all others.  E<.Va filename> is simply a flat file, with one "
"symbol name per line. This option is especially useful in environments (such "
"as VxWorks) where a large global symbol table is accumulated gradually, to "
"conserve run-time memory."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1344
msgid ""
"E<.Li --retain-symbols-file> does E<.Em not> discard undefined symbols, or "
"symbols needed for relocations."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1351
msgid ""
"You may only specify E<.Li --retain-symbols-file> once in the command "
"line. It overrides E<.Li -s> and E<.Li -S>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1352
#, no-wrap
msgid "-rpath Va dir"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1368
msgid ""
"Add a directory to the runtime library search path. This is used when "
"linking an ELF executable with shared objects. All E<.Op -rpath> arguments "
"are concatenated and passed to the runtime linker, which uses them to locate "
"shared objects at runtime. The E<.Op -rpath> option is also used when "
"locating shared objects which are needed by shared objects explicitly "
"included in the link; see the description of the E<.Op -rpath-link> "
"option. If E<.Op -rpath> is not used when linking an ELF executable, the "
"contents of the environment variable E<.Li LD_RUN_PATH> will be used if it "
"is defined."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1383
msgid ""
"The E<.Op -rpath> option may also be used on SunOS. By default, on SunOS, "
"the linker will form a runtime search patch out of all the E<.Op -L> options "
"it is given. If a E<.Op -rpath> option is used, the runtime search path will "
"be formed exclusively using the E<.Op -rpath> options, ignoring the E<.Op "
"-L> options. This can be useful when using gcc, which adds many E<.Op -L> "
"options which may be on NFS mounted file systems."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1391
#, no-wrap
msgid "-rpath-link Va DIR"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1396
msgid ""
"When using ELF or SunOS, one shared library may require another. This "
"happens when an E<.Li ld -shared> link includes a shared library as one of "
"the input files."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1406
msgid ""
"When the linker encounters such a dependency when doing a non-shared, "
"non-relocatable link, it will automatically try to locate the required "
"shared library and include it in the link, if it is not included "
"explicitly. In such a case, the E<.Op -rpath-link> option specifies the "
"first set of directories to search. The E<.Op -rpath-link> option may "
"specify a sequence of directory names either by specifying a list of names "
"separated by colons, or by appearing multiple times."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1411
msgid ""
"This option should be used with caution as it overrides the search path that "
"may have been hard compiled into a shared library. In such a case it is "
"possible to use unintentionally a different search path than the runtime "
"linker would do."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1413
msgid ""
"The linker uses the following search paths to locate required shared "
"libraries:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1418
msgid "Any directories specified by E<.Op -rpath-link> options."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1435
msgid ""
"Any directories specified by E<.Op -rpath> options. The difference between "
"E<.Op -rpath> and E<.Op -rpath-link> is that directories specified by E<.Op "
"-rpath> options are included in the executable and used at runtime, whereas "
"the E<.Op -rpath-link> option is only effective at link time. Searching "
"E<.Op -rpath> in this way is only supported by native linkers and cross "
"linkers which have been configured with the E<.Op --with-sysroot> option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1443
msgid ""
"On an ELF system, if the E<.Op -rpath> and E<.Li rpath-link> options were "
"not used, search the contents of the environment variable E<.Li "
"LD_RUN_PATH>.  It is for the native linker only."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1449
msgid ""
"On SunOS, if the E<.Op -rpath> option was not used, search any directories "
"specified using E<.Op -L> options."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1452
msgid ""
"For a native linker, the contents of the environment variable E<.Li "
"LD_LIBRARY_PATH>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1462
msgid ""
"For a native ELF linker, the directories in E<.Li DT_RUNPATH> or E<.Li "
"DT_RPATH> of a shared library are searched for shared libraries needed by "
"it. The E<.Li DT_RPATH> entries are ignored if E<.Li DT_RUNPATH> entries "
"exist."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1467
msgid "The default directories, normally E<.Pa /lib> and E<.Pa /usr/lib>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1471
msgid ""
"For a native linker on an ELF system, if the file E<.Pa /etc/ld.so.conf> "
"exists, the list of directories found in that file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1475
msgid ""
"If the required shared library is not found, the linker will issue a warning "
"and continue with the link."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1476
#, no-wrap
msgid "-shared"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1477
#, no-wrap
msgid "-Bshareable"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1483
msgid ""
"Create a shared library. This is currently only supported on ELF, XCOFF and "
"SunOS platforms. On SunOS, the linker will automatically create a shared "
"library if the E<.Op -e> option is not used and there are undefined symbols "
"in the link."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1484
#, no-wrap
msgid "--sort-common"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1491
msgid ""
"This option tells E<.Xr ld> to sort the common symbols by size when it "
"places them in the appropriate output sections. First come all the one byte "
"symbols, then all the two byte, then all the four byte, and then everything "
"else. This is to prevent gaps between symbols due to alignment constraints."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1492
#, no-wrap
msgid "--sort-section name"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1496
msgid ""
"This option will apply E<.Li SORT_BY_NAME> to all wildcard section patterns "
"in the linker script."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1497
#, no-wrap
msgid "--sort-section alignment"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1501
msgid ""
"This option will apply E<.Li SORT_BY_ALIGNMENT> to all wildcard section "
"patterns in the linker script."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1502
#, no-wrap
msgid "--split-by-file [ Va size]"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1510
msgid ""
"Similar to E<.Op --split-by-reloc> but creates a new output section for each "
"input file when E<.Va size> is reached.  E<.Va size> defaults to a size of 1 "
"if not given."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1511
#, no-wrap
msgid "--split-by-reloc [ Va count]"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1525
msgid ""
"Tries to creates extra sections in the output file so that no single output "
"section in the file contains more than E<.Va count> relocations. This is "
"useful when generating huge relocatable files for downloading into certain "
"real time kernels with the COFF object file format; since COFF cannot "
"represent more than 65535 relocations in a single section. Note that this "
"will fail to work with object file formats which do not support arbitrary "
"sections. The linker will not split up individual input sections for "
"redistribution, so if a single input section contains more than E<.Va count> "
"relocations one output section will contain that many relocations.  E<.Va "
"count> defaults to a value of 32768."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1526
#, no-wrap
msgid "--stats"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1529
msgid ""
"Compute and display statistics about the operation of the linker, such as "
"execution time and memory usage."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1530
#, no-wrap
msgid "--sysroot= Va directory"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1536
msgid ""
"Use E<.Va directory> as the location of the sysroot, overriding the "
"configure-time default. This option is only supported by linkers that were "
"configured using E<.Op --with-sysroot>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1537
#, no-wrap
msgid "--traditional-format"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1544
msgid ""
"For some targets, the output of E<.Xr ld> is different in some ways from the "
"output of some existing linker. This switch requests E<.Xr ld> to use the "
"traditional format instead."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1558
msgid ""
"For example, on SunOS, E<.Xr ld> combines duplicate entries in the symbol "
"string table. This can reduce the size of an output file with full debugging "
"information by over 30 percent.  Unfortunately, the SunOS E<.Li dbx> program "
"can not read the resulting program ( E<.Li gdb> has no trouble). The E<.Li "
"--traditional-format> switch tells E<.Xr ld> to not combine duplicate "
"entries."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1559
#, no-wrap
msgid "--section-start Va sectionname= Va org"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1574
msgid ""
"Locate a section in the output file at the absolute address given by E<.Va "
"org>.  You may use this option as many times as necessary to locate multiple "
"sections in the command line.  E<.Va org> must be a single hexadecimal "
"integer; for compatibility with other linkers, you may omit the leading "
"E<.Li 0x> usually associated with hexadecimal values.  E<.Em Note:> there "
"should be no white space between E<.Va sectionname>, the equals sign "
"(\\(lq=\\(rq), and E<.Va org>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1575
#, no-wrap
msgid "-Tbss Va org"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1576
#, no-wrap
msgid "-Tdata Va org"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1577
#, no-wrap
msgid "-Ttext Va org"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1585
msgid ""
"Same as --section-start, with E<.Li .bss>, E<.Li .data> or E<.Li .text> as "
"the E<.Va sectionname>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1586
#, no-wrap
msgid "--unresolved-symbols= Va method"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1590
msgid ""
"Determine how to handle unresolved symbols. There are four possible values "
"for E<.Li method>:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1592
#, no-wrap
msgid "ignore-all"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1594
msgid "Do not report any unresolved symbols."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1595
#, no-wrap
msgid "report-all"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1597
msgid "Report all unresolved symbols. This is the default."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1598
#, no-wrap
msgid "ignore-in-object-files"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1601
msgid ""
"Report unresolved symbols that are contained in shared libraries, but ignore "
"them if they come from regular object files."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1602
#, no-wrap
msgid "ignore-in-shared-libs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1607
msgid ""
"Report unresolved symbols that come from regular object files, but ignore "
"them if they come from shared libraries. This can be useful when creating a "
"dynamic binary and it is known that all the shared libraries that it should "
"be referencing are included on the linker's command line."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1613
msgid ""
"The behaviour for shared libraries on their own can also be controlled by "
"the E<.Op --[no-]allow-shlib-undefined> option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1618
msgid ""
"Normally the linker will generate an error message for each reported "
"unresolved symbol but the option E<.Op --warn-unresolved-symbols> can change "
"this to a warning."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1619
#, no-wrap
msgid "--dll-verbose"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1620
#, no-wrap
msgid "--verbose"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1625
msgid ""
"Display the version number for E<.Xr ld> and list the linker emulations "
"supported. Display which input files can and cannot be opened. Display the "
"linker script being used by the linker."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1626
#, no-wrap
msgid "--version-script= Va version-scriptfile"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1632
msgid ""
"Specify the name of a version script to the linker. This is typically used "
"when creating shared libraries to specify additional information about the "
"version hierarchy for the library being created. This option is only "
"meaningful on ELF platforms which support shared libraries.See Section E<.Dq "
"VERSION>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1633
#, no-wrap
msgid "--warn-common"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1640
msgid ""
"Warn when a common symbol is combined with another common symbol or with a "
"symbol definition. Unix linkers allow this somewhat sloppy practise, but "
"linkers on some other operating systems do not. This option allows you to "
"find potential problems from combining global symbols. Unfortunately, some C "
"libraries use this practise, so you may get some warnings about symbols in "
"the libraries as well as in your programs."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1642
msgid "There are three kinds of global symbols, illustrated here by C examples:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1644
#, no-wrap
msgid "int i = 1;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1646
msgid "A definition, which goes in the initialized data section of the output file."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1647
#, no-wrap
msgid "extern int i;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1650
msgid ""
"An undefined reference, which does not allocate space. There must be either "
"a definition or a common symbol for the variable somewhere."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1651
#, no-wrap
msgid "int i;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1657
msgid ""
"A common symbol. If there are only (one or more) common symbols for a "
"variable, it goes in the uninitialized data area of the output file. The "
"linker merges multiple common symbols for the same variable into a single "
"symbol. If they are of different sizes, it picks the largest size. The "
"linker turns a common symbol into a declaration, if there is a definition of "
"the same variable."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1665
msgid ""
"The E<.Li --warn-common> option can produce five kinds of warnings. Each "
"warning consists of a pair of lines: the first describes the symbol just "
"encountered, and the second describes the previous symbol encountered with "
"the same name. One or both of the two symbols will be a common symbol."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1670
msgid ""
"Turning a common symbol into a reference, because there is already a "
"definition for the symbol."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1674
#, no-wrap
msgid ""
"file(section): warning: common of `symbol'\n"
"   overridden by definition\n"
"file(section): warning: defined here\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1680
msgid ""
"Turning a common symbol into a reference, because a later definition for the "
"symbol is encountered. This is the same as the previous case, except that "
"the symbols are encountered in a different order."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1684
#, no-wrap
msgid ""
"file(section): warning: definition of `symbol'\n"
"   overriding common\n"
"file(section): warning: common is here\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1688
msgid "Merging a common symbol with a previous same-sized common symbol."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1692
#, no-wrap
msgid ""
"file(section): warning: multiple common\n"
"   of `symbol'\n"
"file(section): warning: previous common is here\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1696
msgid "Merging a common symbol with a previous larger common symbol."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1700
#, no-wrap
msgid ""
"file(section): warning: common of `symbol'\n"
"   overridden by larger common\n"
"file(section): warning: larger common is here\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1706
msgid ""
"Merging a common symbol with a previous smaller common symbol. This is the "
"same as the previous case, except that the symbols are encountered in a "
"different order."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1710
#, no-wrap
msgid ""
"file(section): warning: common of `symbol'\n"
"   overriding smaller common\n"
"file(section): warning: smaller common is here\n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1713
#, no-wrap
msgid "--warn-constructors"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1717
msgid ""
"Warn if any global constructors are used. This is only useful for a few "
"object file formats. For formats like COFF or ELF, the linker can not detect "
"the use of global constructors."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1718
#, no-wrap
msgid "--warn-multiple-gp"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1729
msgid ""
"Warn if multiple global pointer values are required in the output file. This "
"is only meaningful for certain processors, such as the Alpha. Specifically, "
"some processors put large-valued constants in a special section. A special "
"register (the global pointer) points into the middle of this section, so "
"that constants can be loaded efficiently via a base-register relative "
"addressing mode. Since the offset in base-register relative mode is fixed "
"and relatively small (e.g., 16 bits), this limits the maximum size of the "
"constant pool.  Thus, in large programs, it is often necessary to use "
"multiple global pointer values in order to be able to address all possible "
"constants. This option causes a warning to be issued whenever this case "
"occurs."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1730
#, no-wrap
msgid "--warn-once"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1733
msgid ""
"Only warn once for each undefined symbol, rather than once per module which "
"refers to it."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1734
#, no-wrap
msgid "--warn-section-align"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1741
msgid ""
"Warn if the address of an output section is changed because of alignment.  "
"Typically, the alignment will be set by an input section. The address will "
"only be changed if it not explicitly specified; that is, if the E<.Li "
"SECTIONS> command does not specify a start address for the section (see "
"Section E<.Dq SECTIONS>)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1742
#, no-wrap
msgid "--warn-shared-textrel"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1744
msgid "Warn if the linker adds a DT_TEXTREL to a shared object."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1745
#, no-wrap
msgid "--warn-unresolved-symbols"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1750
msgid ""
"If the linker is going to report an unresolved symbol (see the option E<.Op "
"--unresolved-symbols>)  it will normally generate an error. This option "
"makes it generate a warning instead."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1751
#, no-wrap
msgid "--error-unresolved-symbols"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1754
msgid ""
"This restores the linker's default behaviour of generating errors when it is "
"reporting unresolved symbols."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1755
#, no-wrap
msgid "--whole-archive"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1763
msgid ""
"For each archive mentioned on the command line after the E<.Op "
"--whole-archive> option, include every object file in the archive in the "
"link, rather than searching the archive for the required object files. This "
"is normally used to turn an archive file into a shared library, forcing "
"every object to be included in the resulting shared library. This option may "
"be used more than once."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1771
msgid ""
"Two notes when using this option from gcc: First, gcc doesn't know about "
"this option, so you have to use E<.Op -Wl,-whole-archive>.  Second, don't "
"forget to use E<.Op -Wl,-no-whole-archive> after your list of archives, "
"because gcc will add its own list of archives to your link and you may not "
"want this flag to affect those as well."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1772
#, no-wrap
msgid "--wrap Va symbol"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1783
msgid ""
"Use a wrapper function for E<.Va symbol>.  Any undefined reference to E<.Va "
"symbol> will be resolved to E<.Li __wrap_ Va symbol>.  Any undefined "
"reference to E<.Li __real_ Va symbol> will be resolved to E<.Va symbol>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1789
msgid ""
"This can be used to provide a wrapper for a system function. The wrapper "
"function should be called E<.Li __wrap_ Va symbol>.  If it wishes to call "
"the system function, it should call E<.Li __real_ Va symbol>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1791
msgid "Here is a trivial example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1799
#, no-wrap
msgid ""
"void *\n"
"__wrap_malloc (size_t c)\n"
"{\n"
"  printf (\"malloc called with %zu\\en\", c);\n"
"  return __real_malloc (c);\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1814
msgid ""
"If you link other code with this file using E<.Op --wrap malloc>, then all "
"calls to E<.Li malloc> will call the function E<.Li __wrap_malloc> "
"instead. The call to E<.Li __real_malloc> in E<.Li __wrap_malloc> will call "
"the real E<.Li malloc> function."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1826
msgid ""
"You may wish to provide a E<.Li __real_malloc> function as well, so that "
"links without the E<.Op --wrap> option will succeed. If you do this, you "
"should not put the definition of E<.Li __real_malloc> in the same file as "
"E<.Li __wrap_malloc>; if you do, the assembler may resolve the call before "
"the linker has a chance to wrap it to E<.Li malloc>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1827
#, no-wrap
msgid "--eh-frame-hdr"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1833
msgid ""
"Request creation of E<.Li .eh_frame_hdr> section and ELF E<.Li "
"PT_GNU_EH_FRAME> segment header."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1834
#, no-wrap
msgid "--enable-new-dtags"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1835
#, no-wrap
msgid "--disable-new-dtags"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1843
msgid ""
"This linker can create the new dynamic tags in ELF. But the older ELF "
"systems may not understand them. If you specify E<.Op --enable-new-dtags>, "
"the dynamic tags will be created as needed. If you specify E<.Op "
"--disable-new-dtags>, no new dynamic tags will be created. By default, the "
"new dynamic tags are not created. Note that those options are only available "
"for ELF systems."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1844
#, no-wrap
msgid "--hash-size= Va number"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1851
msgid ""
"Set the default size of the linker's hash tables to a prime number close to "
"E<.Va number>.  Increasing this value can reduce the length of time it takes "
"the linker to perform its tasks, at the expense of increasing the linker's "
"memory requirements.  Similarly reducing this value can reduce the memory "
"requirements at the expense of speed."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1852
#, no-wrap
msgid "--hash-style= Va style"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1871
msgid ""
"Set the type of linker's hash table(s).  E<.Va style> can be either E<.Li "
"sysv> for classic ELF E<.Li .hash> section, E<.Li GNU> for new style GNU "
"E<.Li .GNU.hash> section or E<.Li both> for both the classic ELF E<.Li "
".hash> and new style GNU E<.Li .GNU.hash> hash tables. The default is E<.Li "
"sysv>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1872
#, no-wrap
msgid "--reduce-memory-overheads"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1877
msgid ""
"This option reduces memory requirements at ld runtime, at the expense of "
"linking speed. This was introduced to select the old O(n^2) algorithm for "
"link map file generation, rather than the new O(n) algorithm which uses "
"about 40% more memory for symbol storage."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1883
msgid ""
"Another effect of the switch is to set the default hash table size to 1021, "
"which again saves memory at the cost of lengthening the linker's run time.  "
"This is not done however if the E<.Op --hash-size> switch has been used."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1888
msgid ""
"The E<.Op --reduce-memory-overheads> switch may be also be used to enable "
"other tradeoffs in future versions of the linker."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1891
msgid "E<.Em Options Specific to i386 PE Targets>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1902
msgid ""
"The i386 PE linker supports the E<.Op -shared> option, which causes the "
"output to be a dynamically linked library (DLL) instead of a normal "
"executable. You should name the output E<.Li *.dll> when you use this "
"option. In addition, the linker fully supports the standard E<.Li *.def> "
"files, which may be specified on the linker command line like an object file "
"(in fact, it should precede archives it exports symbols from, to ensure that "
"they get linked in, just like a normal object file)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1907
msgid ""
"In addition to the options common to all targets, the i386 PE linker support "
"additional command line options that are specific to the i386 PE "
"target. Options that take values may be separated from their values by "
"either a space or an equals sign."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1909
#, no-wrap
msgid "--add-stdcall-alias"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1914
msgid ""
"If given, symbols with a stdcall suffix (@ E<.Va nn>)  will be exported "
"as-is and also with the suffix stripped. [This option is specific to the "
"i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1915
#, no-wrap
msgid "--base-file Va file"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1922
msgid ""
"Use E<.Va file> as the name of a file in which to save the base addresses of "
"all the relocations needed for generating DLLs with E<.Pa dlltool>.  [This "
"is an i386 PE specific option]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1923
#, no-wrap
msgid "--dll"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1931
msgid ""
"Create a DLL instead of a regular executable. You may also use E<.Op "
"-shared> or specify a E<.Li LIBRARY> in a given E<.Li .def> file. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1932
#, no-wrap
msgid "--enable-stdcall-fixup"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1933
#, no-wrap
msgid "--disable-stdcall-fixup"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1953
msgid ""
"If the link finds a symbol that it cannot resolve, it will attempt to do "
"\\(lqfuzzy linking\\(rq by looking for another defined symbol that differs "
"only in the format of the symbol name (cdecl vs stdcall) and will resolve "
"that symbol by linking to the match. For example, the undefined symbol E<.Li "
"_foo> might be linked to the function E<.Li _foo@12>, or the undefined "
"symbol E<.Li _bar@16> might be linked to the function E<.Li _bar>.  When the "
"linker does this, it prints a warning, since it normally should have failed "
"to link, but sometimes import libraries generated from third-party dlls may "
"need this feature to be usable. If you specify E<.Op "
"--enable-stdcall-fixup>, this feature is fully enabled and warnings are not "
"printed. If you specify E<.Op --disable-stdcall-fixup>, this feature is "
"disabled and such mismatches are considered to be errors.  [This option is "
"specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1954
#, no-wrap
msgid "--export-all-symbols"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:1997
msgid ""
"If given, all global symbols in the objects used to build a DLL will be "
"exported by the DLL. Note that this is the default if there otherwise "
"wouldn't be any exported symbols. When symbols are explicitly exported via "
"DEF files or implicitly exported via function attributes, the default is to "
"not export anything else unless this option is given. Note that the symbols "
"E<.Li DllMain@12>, E<.Li DllEntryPoint@0>, E<.Li DllMainCRTStartup@12>, and "
"E<.Li impure_ptr> will not be automatically exported. Also, symbols imported "
"from other DLLs will not be re-exported, nor will symbols specifying the "
"DLL's internal layout such as those beginning with E<.Li _head_> or ending "
"with E<.Li _iname>.  In addition, no symbols from E<.Li libgcc>, E<.Li "
"libstd++>, E<.Li libmingw32>, or E<.Li crtX.o> will be exported. Symbols "
"whose names begin with E<.Li __rtti_> or E<.Li __builtin_> will not be "
"exported, to help with C++ DLLs. Finally, there is an extensive list of "
"cygwin-private symbols that are not exported (obviously, this applies on "
"when building DLLs for cygwin targets). These cygwin-excludes are: E<.Li "
"_cygwin_dll_entry@12>, E<.Li _cygwin_crt0_common@8>, E<.Li "
"_cygwin_noncygwin_dll_entry@12>, E<.Li _fmode>, E<.Li _impure_ptr>, E<.Li "
"cygwin_attach_dll>, E<.Li cygwin_premain0>, E<.Li cygwin_premain1>, E<.Li "
"cygwin_premain2>, E<.Li cygwin_premain3>, and E<.Li environ>.  [This option "
"is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:1998
#, no-wrap
msgid "--exclude-symbols Va symbol, Va symbol,..."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2002
msgid ""
"Specifies a list of symbols which should not be automatically exported. The "
"symbol names may be delimited by commas or colons. [This option is specific "
"to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2003
#, no-wrap
msgid "--file-alignment"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2007
msgid ""
"Specify the file alignment. Sections in the file will always begin at file "
"offsets which are multiples of this number. This defaults to 512. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2008
#, no-wrap
msgid "--heap Va reserve"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2009
#, no-wrap
msgid "--heap Va reserve, Va commit"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2013
msgid ""
"Specify the amount of memory to reserve (and optionally commit) to be used "
"as heap for this program. The default is 1Mb reserved, 4K committed. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2014
#, no-wrap
msgid "--image-base Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2023
msgid ""
"Use E<.Va value> as the base address of your program or dll. This is the "
"lowest memory location that will be used when your program or dll is "
"loaded. To reduce the need to relocate and improve performance of your dlls, "
"each should have a unique base address and not overlap any other dlls. The "
"default is 0x400000 for executables, and 0x10000000 for dlls. [This option "
"is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2024
#, no-wrap
msgid "--kill-at"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2029
msgid ""
"If given, the stdcall suffixes (@ E<.Va nn>)  will be stripped from symbols "
"before they are exported. [This option is specific to the i386 PE targeted "
"port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2030
#, no-wrap
msgid "--large-address-aware"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2038
msgid ""
"If given, the appropriate bit in the \\(lqCharacteristics\\(rq field of the "
"COFF header is set to indicate that this executable supports virtual "
"addresses greater than 2 gigabytes. This should be used in conjunction with "
"the /3GB or /USERVA= E<.Va value> megabytes switch in the \\(lq[operating "
"systems]\\(rq section of the BOOT.INI. Otherwise, this bit has no "
"effect. [This option is specific to PE targeted ports of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2039
#, no-wrap
msgid "--major-image-version Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2042
msgid ""
"Sets the major number of the \\(lqimage version\\(rq. Defaults to 1. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2043
#, no-wrap
msgid "--major-os-version Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2046
msgid ""
"Sets the major number of the \\(lqos version\\(rq. Defaults to 4. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2047
#, no-wrap
msgid "--major-subsystem-version Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2050
msgid ""
"Sets the major number of the \\(lqsubsystem version\\(rq. Defaults to "
"4. [This option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2051
#, no-wrap
msgid "--minor-image-version Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2054
msgid ""
"Sets the minor number of the \\(lqimage version\\(rq. Defaults to 0. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2055
#, no-wrap
msgid "--minor-os-version Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2058
msgid ""
"Sets the minor number of the \\(lqos version\\(rq. Defaults to 0. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2059
#, no-wrap
msgid "--minor-subsystem-version Va value"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2062
msgid ""
"Sets the minor number of the \\(lqsubsystem version\\(rq. Defaults to "
"0. [This option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2063
#, no-wrap
msgid "--output-def Va file"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2073
msgid ""
"The linker will create the file E<.Va file> which will contain a DEF file "
"corresponding to the DLL the linker is generating.  This DEF file (which "
"should be called E<.Li *.def>)  may be used to create an import library with "
"E<.Li dlltool> or may be used as a reference to automatically or implicitly "
"exported symbols.  [This option is specific to the i386 PE targeted port of "
"the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2074
#, no-wrap
msgid "--out-implib Va file"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2087
msgid ""
"The linker will create the file E<.Va file> which will contain an import lib "
"corresponding to the DLL the linker is generating.  This import lib (which "
"should be called E<.Li *.dll.a> or E<.Li *.a> may be used to link clients "
"against the generated DLL; this behaviour makes it possible to skip a "
"separate E<.Li dlltool> import library creation step. [This option is "
"specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2088
#, no-wrap
msgid "--enable-auto-image-base"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2096
msgid ""
"Automatically choose the image base for DLLs, unless one is specified using "
"the E<.Li --image-base> argument. By using a hash generated from the dllname "
"to create unique image bases for each DLL, in-memory collisions and "
"relocations which can delay program execution are avoided. [This option is "
"specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2097
#, no-wrap
msgid "--disable-auto-image-base"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2103
msgid ""
"Do not automatically generate a unique image base. If there is no "
"user-specified image base ( E<.Li --image-base>)  then use the platform "
"default. [This option is specific to the i386 PE targeted port of the "
"linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2104
#, no-wrap
msgid "--dll-search-prefix Va string"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2114
msgid ""
"When linking dynamically to a dll without an import library, search for "
"E<.Li E<lt>stringE<gt>E<lt>basenameE<gt>.dll> in preference to E<.Li "
"libE<lt>basenameE<gt>.dll>.  This behaviour allows easy distinction between "
"DLLs built for the various \"subplatforms\": native, cygwin, uwin, pw, "
"etc. For instance, cygwin DLLs typically use E<.Li "
"--dll-search-prefix=cyg>.  [This option is specific to the i386 PE targeted "
"port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2115
#, no-wrap
msgid "--enable-auto-import"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2124
msgid ""
"Do sophisticated linking of E<.Li _symbol> to E<.Li __imp__symbol> for DATA "
"imports from DLLs, and create the necessary thunking symbols when building "
"the import libraries with those DATA exports. Note: Use of the 'auto-import' "
"extension will cause the text section of the image file to be made "
"writable.  This does not conform to the PE-COFF format specification "
"published by Microsoft."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2127
msgid ""
"Using 'auto-import' generally will 'just work' -- but sometimes you may see "
"this message:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2132 /usr/src/contrib/binutils/ld/ld.7:6525
msgid ""
"variable 'E<lt>varE<gt>' can't be auto-imported. Please read the "
"documentation for ld's E<.Li --enable-auto-import> for details."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2141
msgid ""
"This message occurs when some (sub)expression accesses an address ultimately "
"given by the sum of two constants (Win32 import tables only allow "
"one). Instances where this may occur include accesses to member fields of "
"struct variables imported from a DLL, as well as using a constant index into "
"an array variable imported from a DLL. Any multiword variable (arrays, "
"structs, long long, etc)  may trigger this error condition. However, "
"regardless of the exact data type of the offending exported variable, ld "
"will always detect it, issue the warning, and exit."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2144
msgid ""
"There are several ways to address this difficulty, regardless of the data "
"type of the exported variable:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2148
msgid ""
"One way is to use --enable-runtime-pseudo-reloc switch. This leaves the task "
"of adjusting references in your client code for runtime environment, so this "
"method works only when runtime environment supports this feature."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2153
msgid ""
"A second solution is to force one of the 'constants' to be a variable -- "
"that is, unknown and un-optimizable at compile time. For arrays, there are "
"two possibilities: a) make the indexee (the array's address) a variable, or "
"b)  make the 'constant' index a variable. Thus:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2158
#, no-wrap
msgid ""
"extern type extern_array[];\n"
"extern_array[1] --E<gt> \n"
"   { volatile type *t=extern_array; t[1] }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2161 /usr/src/contrib/binutils/ld/ld.7:2178 /usr/src/contrib/binutils/ld/ld.7:5328
msgid "or"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2166
#, no-wrap
msgid ""
"extern type extern_array[];\n"
"extern_array[1] --E<gt> \n"
"   { volatile int t=1; extern_array[t] }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2170
msgid ""
"For structs (and most other multiword data types) the only option is to make "
"the struct itself (or the long long, or the ...) variable:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2175
#, no-wrap
msgid ""
"extern struct s extern_struct;\n"
"extern_struct.field --E<gt> \n"
"   { volatile struct s *t=&extern_struct; t-E<gt>field }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2183
#, no-wrap
msgid ""
"extern long long extern_ll;\n"
"extern_ll --E<gt>\n"
"  { volatile long long * local_ll=&extern_ll; *local_ll }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2193
msgid ""
"A third method of dealing with this difficulty is to abandon 'auto-import' "
"for the offending symbol and mark it with E<.Li __declspec(dllimport)>.  "
"However, in practise that requires using compile-time #defines to indicate "
"whether you are building a DLL, building client code that will link to the "
"DLL, or merely building/linking to a static library. In making the choice "
"between the various methods of resolving the 'direct address with constant "
"offset' problem, you should consider typical real-world usage:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2195
msgid "Original:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2203
#, no-wrap
msgid ""
"--foo.h\n"
"extern int arr[];\n"
"--foo.c\n"
"#include \"foo.h\"\n"
"void main(int argc, char **argv){\n"
"  printf(\"%d\\en\",arr[1]);\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2206
msgid "Solution 1:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2216
#, no-wrap
msgid ""
"--foo.h\n"
"extern int arr[];\n"
"--foo.c\n"
"#include \"foo.h\"\n"
"void main(int argc, char **argv){\n"
"  /* This workaround is for win32 and cygwin; do not \"optimize\" */\n"
"  volatile int *parr = arr;\n"
"  printf(\"%d\\en\",parr[1]);\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2219
msgid "Solution 2:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2234
#, no-wrap
msgid ""
"--foo.h\n"
"/* Note: auto-export is assumed (no __declspec(dllexport)) */\n"
"#if (defined(_WIN32) || defined(__CYGWIN__)) && \\e\n"
"  !(defined(FOO_BUILD_DLL) || defined(FOO_STATIC))\n"
"#define FOO_IMPORT __declspec(dllimport)\n"
"#else\n"
"#define FOO_IMPORT\n"
"#endif\n"
"extern FOO_IMPORT int arr[];\n"
"--foo.c\n"
"#include \"foo.h\"\n"
"void main(int argc, char **argv){\n"
"  printf(\"%d\\en\",arr[1]);\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2240
msgid ""
"A fourth way to avoid this problem is to re-code your library to use a "
"functional interface rather than a data interface for the offending "
"variables (e.g. set_foo()  and get_foo() accessor functions). [This option "
"is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2241
#, no-wrap
msgid "--disable-auto-import"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2248
msgid ""
"Do not attempt to do sophisticated linking of E<.Li _symbol> to E<.Li "
"__imp__symbol> for DATA imports from DLLs. [This option is specific to the "
"i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2249
#, no-wrap
msgid "--enable-runtime-pseudo-reloc"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2255
msgid ""
"If your code contains expressions described in --enable-auto-import section, "
"that is, DATA imports from DLL with non-zero offset, this switch will create "
"a vector of 'runtime pseudo relocations' which can be used by runtime "
"environment to adjust references to such data in your client code. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2256
#, no-wrap
msgid "--disable-runtime-pseudo-reloc"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2260
msgid ""
"Do not create pseudo relocations for non-zero offset DATA imports from "
"DLLs.  This is the default. [This option is specific to the i386 PE targeted "
"port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2261
#, no-wrap
msgid "--enable-extra-pe-debug"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2264
msgid ""
"Show additional debug info related to auto-import symbol thunking. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2265
#, no-wrap
msgid "--section-alignment"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2269
msgid ""
"Sets the section alignment. Sections in memory will always begin at "
"addresses which are a multiple of this number. Defaults to 0x1000. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2270
#, no-wrap
msgid "--stack Va reserve"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2271
#, no-wrap
msgid "--stack Va reserve, Va commit"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2275
msgid ""
"Specify the amount of memory to reserve (and optionally commit) to be used "
"as stack for this program. The default is 2Mb reserved, 4K committed. [This "
"option is specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2276
#, no-wrap
msgid "--subsystem Va which"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2277
#, no-wrap
msgid "--subsystem Va which: Va major"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2278
#, no-wrap
msgid "--subsystem Va which: Va major. Va minor"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2293
msgid ""
"Specifies the subsystem under which your program will execute. The legal "
"values for E<.Va which> are E<.Li native>, E<.Li windows>, E<.Li console>, "
"E<.Li posix>, and E<.Li xbox>.  You may optionally set the subsystem version "
"also. Numeric values are also accepted for E<.Va which>.  [This option is "
"specific to the i386 PE targeted port of the linker]"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2296
msgid "E<.Em Options specific to Motorola 68HC11 and 68HC12 targets>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2299
msgid ""
"The 68HC11 and 68HC12 linkers support specific options to control the memory "
"bank switching mapping and trampoline code generation."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2301
#, no-wrap
msgid "--no-trampoline"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2306
msgid ""
"This option disables the generation of trampoline. By default a trampoline "
"is generated for each far function which is called using a E<.Li jsr> "
"instruction (this happens when a pointer to a far function is taken)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2307
#, no-wrap
msgid "--bank-window Va name"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2313
msgid ""
"This option indicates to the linker the name of the memory region in the "
"E<.Li MEMORY> specification that describes the memory bank window. The "
"definition of such region is then used by the linker to compute paging and "
"addresses within the memory window."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:2315
#, no-wrap
msgid "Environment Variables"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2323
msgid ""
"You can change the behaviour of E<.Xr ld> with the environment variables "
"E<.Li GNUTARGET>, E<.Li LDEMULATION> and E<.Li COLLECT_NO_DEMANGLE>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2345
msgid ""
"E<.Li GNUTARGET> determines the input-file object format if you don't use "
"E<.Li -b> (or its synonym E<.Li --format>).  Its value should be one of the "
"BFD names for an input format (see Section E<.Dq BFD>).  If there is no "
"E<.Li GNUTARGET> in the environment, E<.Xr ld> uses the natural format of "
"the target. If E<.Li GNUTARGET> is set to E<.Li default> then BFD attempts "
"to discover the input format by examining binary input files; this method "
"often succeeds, but there are potential ambiguities, since there is no "
"method of ensuring that the magic number used to specify object-file formats "
"is unique. However, the configuration procedure for BFD on each system "
"places the conventional format for that system first in the search-list, so "
"ambiguities are resolved in favor of convention."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2360
msgid ""
"E<.Li LDEMULATION> determines the default emulation if you don't use the "
"E<.Li -m> option. The emulation can affect various aspects of linker "
"behaviour, particularly the default linker script. You can list the "
"available emulations with the E<.Li --verbose> or E<.Li -V> options. If the "
"E<.Li -m> option is not used, and the E<.Li LDEMULATION> environment "
"variable is not defined, the default emulation depends upon how the linker "
"was configured."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2371
msgid ""
"Normally, the linker will default to demangling symbols. However, if E<.Li "
"COLLECT_NO_DEMANGLE> is set in the environment, then it will default to not "
"demangling symbols.  This environment variable is used in a similar fashion "
"by the E<.Li gcc> linker wrapper program. The default may be overridden by "
"the E<.Li --demangle> and E<.Li --no-demangle> options."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:2372
#, no-wrap
msgid "Linker Scripts"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2376
msgid ""
"Every link is controlled by a E<.Em linker script>.  This script is written "
"in the linker command language."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2382
msgid ""
"The main purpose of the linker script is to describe how the sections in the "
"input files should be mapped into the output file, and to control the memory "
"layout of the output file. Most linker scripts do nothing more than this.  "
"However, when necessary, the linker script can also direct the linker to "
"perform many other operations, using the commands described below."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2393
msgid ""
"The linker always uses a linker script. If you do not supply one yourself, "
"the linker will use a default script that is compiled into the linker "
"executable.  You can use the E<.Li --verbose> command line option to display "
"the default linker script. Certain command line options, such as E<.Li -r> "
"or E<.Li -N>, will affect the default linker script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2398
msgid ""
"You may supply your own linker script by using the E<.Li -T> command line "
"option. When you do this, your linker script will replace the default linker "
"script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2402
msgid ""
"You may also use linker scripts implicitly by naming them as input files to "
"the linker, as though they were files to be linked.See Section E<.Dq "
"Implicit Linker Scripts>."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:2403
#, no-wrap
msgid "Basic Linker Script Concepts"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2406
msgid ""
"We need to define some basic concepts and vocabulary in order to describe "
"the linker script language."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2421
msgid ""
"The linker combines input files into a single output file. The output file "
"and each input file are in a special data format known as an E<.Em object "
"file format>.  Each file is called an E<.Em object file>.  The output file "
"is often called an E<.Em executable>, but for our purposes we will also call "
"it an object file. Each object file has, among other things, a list of E<.Em "
"sections>.  We sometimes refer to a section in an input file as an E<.Em "
"input section>; similarly, a section in the output file is an E<.Em output "
"section>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2434
msgid ""
"Each section in an object file has a name and a size. Most sections also "
"have an associated block of data, known as the E<.Em section contents>.  A "
"section may be marked as E<.Em loadable>, which mean that the contents "
"should be loaded into memory when the output file is run. A section with no "
"contents may be E<.Em allocatable>, which means that an area in memory "
"should be set aside, but nothing in particular should be loaded there (in "
"some cases this memory must be zeroed out). A section which is neither "
"loadable nor allocatable typically contains some sort of debugging "
"information."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2447
msgid ""
"Every loadable or allocatable output section has two addresses. The first is "
"the E<.Em VMA>, or virtual memory address. This is the address the section "
"will have when the output file is run. The second is the E<.Em LMA>, or load "
"memory address. This is the address at which the section will be loaded.  In "
"most cases the two addresses will be the same. An example of when they might "
"be different is when a data section is loaded into ROM, and then copied into "
"RAM when the program starts up (this technique is often used to initialize "
"global variables in a ROM based system). In this case the ROM address would "
"be the LMA, and the RAM address would be the VMA."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2453
msgid ""
"You can see the sections in an object file by using the E<.Li objdump> "
"program with the E<.Li -h> option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2463
msgid ""
"Every object file also has a list of E<.Em symbols>, known as the E<.Em "
"symbol table>.  A symbol may be defined or undefined. Each symbol has a "
"name, and each defined symbol has an address, among other information. If "
"you compile a C or C++ program into an object file, you will get a defined "
"symbol for every defined function and global or static variable. Every "
"undefined function or global variable which is referenced in the input file "
"will become an undefined symbol."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2471
msgid ""
"You can see the symbols in an object file by using the E<.Li nm> program, or "
"by using the E<.Li objdump> program with the E<.Li -t> option."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:2472
#, no-wrap
msgid "Linker Script Format"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2474
msgid "Linker scripts are text files."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2478
msgid ""
"You write a linker script as a series of commands. Each command is either a "
"keyword, possibly followed by arguments, or an assignment to a symbol. You "
"may separate commands using semicolons. Whitespace is generally ignored."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2483
msgid ""
"Strings such as file or format names can normally be entered directly. If "
"the file name contains a character such as a comma which would otherwise "
"serve to separate file names, you may put the file name in double "
"quotes. There is no way to use a double quote character in a file name."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2489
msgid ""
"You may include comments in linker scripts just as in C, delimited by E<.Li "
"/*> and E<.Li */>.  As in C, comments are syntactically equivalent to "
"whitespace."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:2490
#, no-wrap
msgid "Simple Linker Script Example"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2492
msgid "Many linker scripts are fairly simple."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2498
msgid ""
"The simplest possible linker script has just one command: E<.Li SECTIONS>.  "
"You use the E<.Li SECTIONS> command to describe the memory layout of the "
"output file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2510
msgid ""
"The E<.Li SECTIONS> command is a powerful command. Here we will describe a "
"simple use of it. Let's assume your program consists only of code, "
"initialized data, and uninitialized data. These will be in the E<.Li .text>, "
"E<.Li .data>, and E<.Li .bss> sections, respectively. Let's assume further "
"that these are the only sections which appear in your input files."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2514
msgid ""
"For this example, let's say that the code should be loaded at address "
"0x10000, and that the data should start at address 0x8000000. Here is a "
"linker script which will do that:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2523
#, no-wrap
msgid ""
"SECTIONS\n"
"{\n"
"  . = 0x10000;\n"
"  .text : { *(.text) }\n"
"  . = 0x8000000;\n"
"  .data : { *(.data) }\n"
"  .bss : { *(.bss) }\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2531
msgid ""
"You write the E<.Li SECTIONS> command as the keyword E<.Li SECTIONS>, "
"followed by a series of symbol assignments and output section descriptions "
"enclosed in curly braces."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2543
msgid ""
"The first line inside the E<.Li SECTIONS> command of the above example sets "
"the value of the special symbol E<.Li>., which is the location counter. If "
"you do not specify the address of an output section in some other way (other "
"ways are described later), the address is set from the current value of the "
"location counter. The location counter is then incremented by the size of "
"the output section. At the start of the E<.Li SECTIONS> command, the "
"location counter has the value E<.Li 0>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2555
msgid ""
"The second line defines an output section, E<.Li .text>.  The colon is "
"required syntax which may be ignored for now. Within the curly braces after "
"the output section name, you list the names of the input sections which "
"should be placed into this output section. The E<.Li *> is a wildcard which "
"matches any file name. The expression E<.Li *(.text)> means all E<.Li .text> "
"input sections in all input files."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2564
msgid ""
"Since the location counter is E<.Li 0x10000> when the output section E<.Li "
".text> is defined, the linker will set the address of the E<.Li .text> "
"section in the output file to be E<.Li 0x10000>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2584
msgid ""
"The remaining lines define the E<.Li .data> and E<.Li .bss> sections in the "
"output file. The linker will place the E<.Li .data> output section at "
"address E<.Li 0x8000000>.  After the linker places the E<.Li .data> output "
"section, the value of the location counter will be E<.Li 0x8000000> plus the "
"size of the E<.Li .data> output section. The effect is that the linker will "
"place the E<.Li .bss> output section immediately after the E<.Li .data> "
"output section in memory."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2597
msgid ""
"The linker will ensure that each output section has the required alignment, "
"by increasing the location counter if necessary. In this example, the "
"specified addresses for the E<.Li .text> and E<.Li .data> sections will "
"probably satisfy any alignment constraints, but the linker may have to "
"create a small gap between the E<.Li .data> and E<.Li .bss> sections."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2599
msgid "That's it! That's a simple and complete linker script."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:2600
#, no-wrap
msgid "Simple Linker Script Commands"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2602
msgid "In this section we describe the simple linker script commands."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2604
msgid "E<.Em Setting the Entry Point>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2610
msgid ""
"The first instruction to execute in a program is called the E<.Em entry "
"point>.  You can use the E<.Li ENTRY> linker script command to set the entry "
"point. The argument is a symbol name:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2612
#, no-wrap
msgid "ENTRY(symbol)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2617
msgid ""
"There are several ways to set the entry point. The linker will set the entry "
"point by trying each of the following methods in order, and stopping when "
"one of them succeeds:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2623
msgid "the E<.Li -e> E<.Va entry> command-line option;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2627
msgid "the E<.Li ENTRY( Va symbol)> command in a linker script;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2631
msgid "the value of the symbol E<.Li start>, if defined;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2635
msgid "the address of the first byte of the E<.Li .text> section, if present;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2638
msgid "The address E<.Li 0>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2641
msgid "E<.Em Commands Dealing with Files>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2643
msgid "Several linker script commands deal with files."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2645
#, no-wrap
msgid "INCLUDE Va filename"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2654
msgid ""
"Include the linker script E<.Va filename> at this point. The file will be "
"searched for in the current directory, and in any directory specified with "
"the E<.Op -L> option. You can nest calls to E<.Li INCLUDE> up to 10 levels "
"deep."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2655
#, no-wrap
msgid "INPUT( Va file, Va file, ...)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2656
#, no-wrap
msgid "INPUT( Va file Va file ...)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2661
msgid ""
"The E<.Li INPUT> command directs the linker to include the named files in "
"the link, as though they were named on the command line."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2668
msgid ""
"For example, if you always want to include E<.Pa subr.o> any time you do a "
"link, but you can't be bothered to put it on every link command line, then "
"you can put E<.Li INPUT (subr.o)> in your linker script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2673
msgid ""
"In fact, if you like, you can list all of your input files in the linker "
"script, and then invoke the linker with nothing but a E<.Li -T> option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2687
msgid ""
"In case a E<.Em sysroot prefix> is configured, and the filename starts with "
"the E<.Li /> character, and the script being processed was located inside "
"the E<.Em sysroot prefix>, the filename will be looked for in the E<.Em "
"sysroot prefix>.  Otherwise, the linker will try to open the file in the "
"current directory.  If it is not found, the linker will search through the "
"archive library search path. See the description of E<.Li -L> in "
"Options,,Command Line Options."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2695
msgid ""
"If you use E<.Li INPUT (-l Va file)>, E<.Xr ld> will transform the name to "
"E<.Li lib Va file.a>, as with the command line argument E<.Li -l>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2701
msgid ""
"When you use the E<.Li INPUT> command in an implicit linker script, the "
"files will be included in the link at the point at which the linker script "
"file is included. This can affect archive searching."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2702
#, no-wrap
msgid "GROUP( Va file, Va file, ...)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2703
#, no-wrap
msgid "GROUP( Va file Va file ...)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2713
msgid ""
"The E<.Li GROUP> command is like E<.Li INPUT>, except that the named files "
"should all be archives, and they are searched repeatedly until no new "
"undefined references are created. See the description of E<.Li -(> in "
"Options,,Command Line Options."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2714
#, no-wrap
msgid "AS_NEEDED( Va file, Va file, ...)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2715
#, no-wrap
msgid "AS_NEEDED( Va file Va file ...)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2733
msgid ""
"This construct can appear only inside of the E<.Li INPUT> or E<.Li GROUP> "
"commands, among other filenames. The files listed will be handled as if they "
"appear directly in the E<.Li INPUT> or E<.Li GROUP> commands, with the "
"exception of ELF shared libraries, that will be added only when they are "
"actually needed. This construct essentially enables E<.Op --as-needed> "
"option for all the files listed inside of it and restores previous E<.Op "
"--as-needed> resp.  E<.Op --no-as-needed> setting afterwards."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2734
#, no-wrap
msgid "OUTPUT( Va filename)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2744
msgid ""
"The E<.Li OUTPUT> command names the output file. Using E<.Li OUTPUT( Va "
"filename)> in the linker script is exactly like using E<.Li -o Va filename> "
"on the command line (see Section E<.Dq Options>).  If both are used, the "
"command line option takes precedence."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2750
msgid ""
"You can use the E<.Li OUTPUT> command to define a default name for the "
"output file other than the usual default of E<.Pa a.out>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2751
#, no-wrap
msgid "SEARCH_DIR( Va path)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2766
msgid ""
"The E<.Li SEARCH_DIR> command adds E<.Va path> to the list of paths where "
"E<.Xr ld> looks for archive libraries. Using E<.Li SEARCH_DIR( Va path)> is "
"exactly like using E<.Li -L Va path> on the command line (see Section E<.Dq "
"Options>).  If both are used, then the linker will search both paths. Paths "
"specified using the command line option are searched first."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2767
#, no-wrap
msgid "STARTUP( Va filename)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2777
msgid ""
"The E<.Li STARTUP> command is just like the E<.Li INPUT> command, except "
"that E<.Va filename> will become the first input file to be linked, as "
"though it were specified first on the command line. This may be useful when "
"using a system in which the entry point is always the start of the first "
"file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2780
msgid "E<.Em Commands Dealing with Object File Formats>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2782
msgid "A couple of linker script commands deal with object file formats."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2784
#, no-wrap
msgid "OUTPUT_FORMAT( Va bfdname)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2785
#, no-wrap
msgid "OUTPUT_FORMAT( Va default, Va big, Va little)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2797
msgid ""
"The E<.Li OUTPUT_FORMAT> command names the BFD format to use for the output "
"file (see Section E<.Dq BFD>).  Using E<.Li OUTPUT_FORMAT( Va bfdname)> is "
"exactly like using E<.Li --oformat Va bfdname> on the command line (see "
"Section E<.Dq Options>).  If both are used, the command line option takes "
"precedence."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2806
msgid ""
"You can use E<.Li OUTPUT_FORMAT> with three arguments to use different "
"formats based on the E<.Li -EB> and E<.Li -EL> command line options. This "
"permits the linker script to set the output format based on the desired "
"endianness."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2821
msgid ""
"If neither E<.Li -EB> nor E<.Li -EL> are used, then the output format will "
"be the first argument, E<.Va default>.  If E<.Li -EB> is used, the output "
"format will be the second argument, E<.Va big>.  If E<.Li -EL> is used, the "
"output format will be the third argument, E<.Va little>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2823
msgid ""
"For example, the default linker script for the MIPS ELF target uses this "
"command:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2825
#, no-wrap
msgid "OUTPUT_FORMAT(elf32-bigmips, elf32-bigmips, elf32-littlemips)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2833
msgid ""
"This says that the default format for the output file is E<.Li "
"elf32-bigmips>, but if the user uses the E<.Li -EL> command line option, the "
"output file will be created in the E<.Li elf32-littlemips> format."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2834
#, no-wrap
msgid "TARGET( Va bfdname)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2853
msgid ""
"The E<.Li TARGET> command names the BFD format to use when reading input "
"files. It affects subsequent E<.Li INPUT> and E<.Li GROUP> commands. This "
"command is like using E<.Li -b Va bfdname> on the command line (see Section "
"E<.Dq Options>).  If the E<.Li TARGET> command is used but E<.Li "
"OUTPUT_FORMAT> is not, then the last E<.Li TARGET> command is also used to "
"set the format for the output file.See Section E<.Dq BFD>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2856
msgid "E<.Em Other Linker Script Commands>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2858
msgid "There are a few other linker scripts commands."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2860
#, no-wrap
msgid "ASSERT( Va exp, Va message)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2865
msgid ""
"Ensure that E<.Va exp> is non-zero. If it is zero, then exit the linker with "
"an error code, and print E<.Va message>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2866
#, no-wrap
msgid "EXTERN( Va symbol Va symbol ...)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2880
msgid ""
"Force E<.Va symbol> to be entered in the output file as an undefined "
"symbol. Doing this may, for example, trigger linking of additional modules "
"from standard libraries. You may list several E<.Va symbol> s for each E<.Li "
"EXTERN>, and you may use E<.Li EXTERN> multiple times. This command has the "
"same effect as the E<.Li -u> command-line option."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2881
#, no-wrap
msgid "FORCE_COMMON_ALLOCATION"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2889
msgid ""
"This command has the same effect as the E<.Li -d> command-line option: to "
"make E<.Xr ld> assign space to common symbols even if a relocatable output "
"file is specified ( E<.Li -r>)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2890
#, no-wrap
msgid "INHIBIT_COMMON_ALLOCATION"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2897
msgid ""
"This command has the same effect as the E<.Li --no-define-common> "
"command-line option: to make E<.Li ld> omit the assignment of addresses to "
"common symbols even for a non-relocatable output file."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2898
#, no-wrap
msgid "NOCROSSREFS( Va section Va section ...)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2902
msgid ""
"This command may be used to tell E<.Xr ld> to issue an error about any "
"references among certain output sections."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2908
msgid ""
"In certain types of programs, particularly on embedded systems when using "
"overlays, when one section is loaded into memory, another section will not "
"be. Any direct references between the two sections would be errors. For "
"example, it would be an error if code in one section called a function "
"defined in the other section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2917
msgid ""
"The E<.Li NOCROSSREFS> command takes a list of output section names. If "
"E<.Xr ld> detects any cross references between the sections, it reports an "
"error and returns a non-zero exit status. Note that the E<.Li NOCROSSREFS> "
"command uses output section names, not input section names."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2918
#, no-wrap
msgid "OUTPUT_ARCH( Va bfdarch)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2927
msgid ""
"Specify a particular output machine architecture. The argument is one of the "
"names used by the BFD library (see Section E<.Dq BFD>).  You can see the "
"architecture of an object file by using the E<.Li objdump> program with the "
"E<.Li -f> option."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:2929
#, no-wrap
msgid "Assigning Values to Symbols"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2932
msgid ""
"You may assign a value to a symbol in a linker script. This will define the "
"symbol and place it into the symbol table with a global scope."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2934
msgid "E<.Em Simple Assignments>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2936
msgid "You may assign to a symbol using any of the C assignment operators:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2938
#, no-wrap
msgid "Va symbol = Va expression ;"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2939
#, no-wrap
msgid "Va symbol += Va expression ;"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2940
#, no-wrap
msgid "Va symbol -= Va expression ;"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2941
#, no-wrap
msgid "Va symbol *= Va expression ;"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2942
#, no-wrap
msgid "Va symbol /= Va expression ;"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2943
#, no-wrap
msgid "Va symbol E<lt>E<lt>= Va expression ;"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2944
#, no-wrap
msgid "Va symbol E<gt>E<gt>= Va expression ;"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2945
#, no-wrap
msgid "Va symbol &= Va expression ;"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:2946
#, no-wrap
msgid "Va symbol |= Va expression ;"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2956
msgid ""
"The first case will define E<.Va symbol> to the value of E<.Va expression>.  "
"In the other cases, E<.Va symbol> must already be defined, and the value "
"will be adjusted accordingly."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2963
msgid ""
"The special symbol name E<.Li>.  indicates the location counter. You may "
"only use this within a E<.Li SECTIONS> command.See Section E<.Dq Location "
"Counter>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2967
msgid "The semicolon after E<.Va expression> is required."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2969
msgid "Expressions are defined below; see Expressions."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2976
msgid ""
"You may write symbol assignments as commands in their own right, or as "
"statements within a E<.Li SECTIONS> command, or as part of an output section "
"description in a E<.Li SECTIONS> command."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2979
msgid ""
"The section of the symbol will be set from the section of the expression; "
"for more information, see Expression Section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2982
msgid ""
"Here is an example showing the three different places that symbol "
"assignments may be used:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:2995
#, no-wrap
msgid ""
"floating_point = 0;\n"
"SECTIONS\n"
"{\n"
"  .text :\n"
"    {\n"
"      *(.text)\n"
"      _etext = .;\n"
"    }\n"
"  _bdata = (. + 3) & ~ 3;\n"
"  .data : { *(.data) }\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3007
msgid ""
"In this example, the symbol E<.Li floating_point> will be defined as "
"zero. The symbol E<.Li _etext> will be defined as the address following the "
"last E<.Li .text> input section. The symbol E<.Li _bdata> will be defined as "
"the address following the E<.Li .text> output section aligned upward to a 4 "
"byte boundary."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3009
msgid "E<.Em PROVIDE>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3022
msgid ""
"In some cases, it is desirable for a linker script to define a symbol only "
"if it is referenced and is not defined by any object included in the link.  "
"For example, traditional linkers defined the symbol E<.Li etext>.  However, "
"ANSI C requires that the user be able to use E<.Li etext> as a function name "
"without encountering an error. The E<.Li PROVIDE> keyword may be used to "
"define a symbol, such as E<.Li etext>, only if it is referenced but not "
"defined. The syntax is E<.Li PROVIDE( Va symbol = Va expression)>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3027
msgid "Here is an example of using E<.Li PROVIDE> to define E<.Li etext>:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3037
#, no-wrap
msgid ""
"SECTIONS\n"
"{\n"
"  .text :\n"
"    {\n"
"      *(.text)\n"
"      _etext = .;\n"
"      PROVIDE(etext = .);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3048
msgid ""
"In this example, if the program defines E<.Li _etext> (with a leading "
"underscore), the linker will give a multiple definition error.  If, on the "
"other hand, the program defines E<.Li etext> (with no leading underscore), "
"the linker will silently use the definition in the program. If the program "
"references E<.Li etext> but does not define it, the linker will use the "
"definition in the linker script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3050
msgid "E<.Em PROVIDE_HIDDEN>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3054
msgid ""
"Similar to E<.Li PROVIDE>.  For ELF targeted ports, the symbol will be "
"hidden and won't be exported."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3056
msgid "E<.Em Source Code Reference>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3060
msgid ""
"Accessing a linker script defined variable from source code is not "
"intuitive.  In particular a linker script symbol is not equivalent to a "
"variable declaration in a high level language, it is instead a symbol that "
"does not have a value."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3070
msgid ""
"Before going further, it is important to note that compilers often transform "
"names in the source code into different names when they are stored in the "
"symbol table. For example, Fortran compilers commonly prepend or append an "
"underscore, and C++ performs extensive E<.Li name mangling>.  Therefore "
"there might be a discrepancy between the name of a variable as it is used in "
"source code and the name of the same variable as it is defined in a linker "
"script. For example in C a linker script variable might be referred to as:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3073
#, no-wrap
msgid "  extern int foo;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3076
msgid "But in the linker script it might be defined as:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3079
#, no-wrap
msgid "  _foo = 1000;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3083
msgid ""
"In the remaining examples however it is assumed that no name transformation "
"has taken place."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3093
msgid ""
"When a symbol is declared in a high level language such as C, two things "
"happen.  The first is that the compiler reserves enough space in the "
"program's memory to hold the E<.Em value> of the symbol. The second is that "
"the compiler creates an entry in the program's symbol table which holds the "
"symbol's E<.Em address>.  ie the symbol table contains the address of the "
"block of memory holding the symbol's value. So for example the following C "
"declaration, at file scope:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3096
#, no-wrap
msgid "  int foo = 1000;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3103
msgid ""
"creates a entry called E<.Li foo> in the symbol table. This entry holds the "
"address of an E<.Li int> sized block of memory where the number 1000 is "
"initially stored."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3107
msgid ""
"When a program references a symbol the compiler generates code that first "
"accesses the symbol table to find the address of the symbol's memory block "
"and then code to read the value from that memory block. So:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3110
#, no-wrap
msgid "  foo = 1;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3116
msgid ""
"looks up the symbol E<.Li foo> in the symbol table, gets the address "
"associated with this symbol and then writes the value 1 into that "
"address. Whereas:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3119
#, no-wrap
msgid "  int * a = & foo;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3126
msgid ""
"looks up the symbol E<.Li foo> in the symbol table, gets it address and then "
"copies this address into the block of memory associated with the variable "
"E<.Li a>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3130
msgid ""
"Linker scripts symbol declarations, by contrast, create an entry in the "
"symbol table but do not assign any memory to them. Thus they are an address "
"without a value. So for example the linker script definition:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3133
#, no-wrap
msgid "  foo = 1000;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3144
msgid ""
"creates an entry in the symbol table called E<.Li foo> which holds the "
"address of memory location 1000, but nothing special is stored at address "
"1000. This means that you cannot access the E<.Em value> of a linker script "
"defined symbol - it has no value - all you can do is access the E<.Em "
"address> of a linker script defined symbol."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3150
msgid ""
"Hence when you are using a linker script defined symbol in source code you "
"should always take the address of the symbol, and never attempt to use its "
"value. For example suppose you want to copy the contents of a section of "
"memory called .ROM into a section called .FLASH and the linker script "
"contains these declarations:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3156
#, no-wrap
msgid ""
"  start_of_ROM   = .ROM;\n"
"  end_of_ROM     = .ROM + sizeof (.ROM) - 1;\n"
"  start_of_FLASH = .FLASH;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3160
msgid "Then the C source code to perform the copy would be:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3164
#, no-wrap
msgid "  extern char start_of_ROM, end_of_ROM, start_of_FLASH;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3166
#, no-wrap
msgid ""
"  memcpy (& start_of_FLASH, & start_of_ROM, & end_of_ROM - & "
"start_of_ROM);\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3172
msgid "Note the use of the E<.Li &> operators. These are correct."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:3173
#, no-wrap
msgid "SECTIONS Command"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3178
msgid ""
"The E<.Li SECTIONS> command tells the linker how to map input sections into "
"output sections, and how to place the output sections in memory."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3182
msgid "The format of the E<.Li SECTIONS> command is:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3189
#, no-wrap
msgid ""
"SECTIONS\n"
"{\n"
"  sections-command\n"
"  sections-command\n"
"  ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3194
msgid "Each E<.Va sections-command> may of be one of the following:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3201
msgid "an E<.Li ENTRY> command (see Section E<.Dq Entry Point>)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3204 /usr/src/contrib/binutils/ld/ld.7:3258
msgid "a symbol assignment (see Section E<.Dq Assignments>)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3206
msgid "an output section description"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3208
msgid "an overlay description"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3217
msgid ""
"The E<.Li ENTRY> command and symbol assignments are permitted inside the "
"E<.Li SECTIONS> command for convenience in using the location counter in "
"those commands. This can also make the linker script easier to understand "
"because you can use those commands at meaningful points in the layout of the "
"output file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3219
msgid "Output section descriptions and overlay descriptions are described below."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3227
msgid ""
"If you do not use a E<.Li SECTIONS> command in your linker script, the "
"linker will place each input section into an identically named output "
"section in the order that the sections are first encountered in the input "
"files. If all input sections are present in the first file, for example, the "
"order of sections in the output file will match the order in the first input "
"file. The first section will be at address zero."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3229
msgid "E<.Em Output Section Description>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3231
msgid "The full description of an output section looks like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3240 /usr/src/contrib/binutils/ld/ld.7:3949
#, no-wrap
msgid ""
"section [address] [(type)] :\n"
"  [AT(lma)] [ALIGN(section_align)] [SUBALIGN(subsection_align)]\n"
"  {\n"
"    output-section-command\n"
"    output-section-command\n"
"    ...\n"
"  } [E<gt>region] [ATE<gt>lma_region] [:phdr :phdr ...] [=fillexp]\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3244
msgid "Most output sections do not use most of the optional section attributes."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3249
msgid ""
"The whitespace around E<.Va section> is required, so that the section name "
"is unambiguous. The colon and the curly braces are also required. The line "
"breaks and other white space are optional."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3253
msgid "Each E<.Va output-section-command> may be one of the following:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3261
msgid "an input section description (see Section E<.Dq Input Section>)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3264
msgid "data values to include directly (see Section E<.Dq Output Section Data>)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3267
msgid ""
"a special output section keyword (see Section E<.Dq Output Section "
"Keywords>)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3270
msgid "E<.Em Output Section Name>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3288
msgid ""
"The name of the output section is E<.Va section>.  E<.Va section> must meet "
"the constraints of your output format. In formats which only support a "
"limited number of sections, such as E<.Li a.out>, the name must be one of "
"the names supported by the format ( E<.Li a.out>, for example, allows only "
"E<.Li .text>, E<.Li .data> or E<.Li .bss>).  If the output format supports "
"any number of sections, but with numbers and not names (as is the case for "
"Oasys), the name should be supplied as a quoted numeric string. A section "
"name may consist of any sequence of characters, but a name which contains "
"any unusual characters such as commas must be quoted."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3292
msgid ""
"The output section name E<.Li /DISCARD/> is special; Output Section "
"Discarding."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3294
msgid "E<.Em Output Section Address>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3303
msgid ""
"The E<.Va address> is an expression for the VMA (the virtual memory address) "
"of the output section.  If you do not provide E<.Va address>, the linker "
"will set it based on E<.Va region> if present, or otherwise based on the "
"current value of the location counter."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3315
msgid ""
"If you provide E<.Va address>, the address of the output section will be set "
"to precisely that. If you provide neither E<.Va address> nor E<.Va region>, "
"then the address of the output section will be set to the current value of "
"the location counter aligned to the alignment requirements of the output "
"section.  The alignment requirement of the output section is the strictest "
"alignment of any input section contained within the output section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3317
msgid "For example,"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3319
#, no-wrap
msgid "\\&.text . : { *(.text) }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3321
msgid "and"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3323
#, no-wrap
msgid "\\&.text : { *(.text) }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3331
msgid ""
"are subtly different. The first will set the address of the E<.Li .text> "
"output section to the current value of the location counter. The second will "
"set it to the current value of the location counter aligned to the strictest "
"alignment of a E<.Li .text> input section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3337
msgid ""
"The E<.Va address> may be an arbitrary expression; Expressions. For example, "
"if you want to align the section on a 0x10 byte boundary, so that the lowest "
"four bits of the section address are zero, you could do something like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3339
#, no-wrap
msgid "\\&.text ALIGN(0x10) : { *(.text) }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3343
msgid ""
"This works because E<.Li ALIGN> returns the current location counter aligned "
"upward to the specified value."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3347
msgid ""
"Specifying E<.Va address> for a section will change the value of the "
"location counter."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3349
msgid "E<.Em Input Section Description>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3351
msgid "The most common output section command is an input section description."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3356
msgid ""
"The input section description is the most basic linker script operation. You "
"use output sections to tell the linker how to lay out your program in "
"memory.  You use input section descriptions to tell the linker how to map "
"the input files into your memory layout."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3358
msgid "E<.No Input Section Basics>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3361
msgid ""
"An input section description consists of a file name optionally followed by "
"a list of section names in parentheses."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3365
msgid ""
"The file name and the section name may be wildcard patterns, which we "
"describe further below (see Section E<.Dq Input Section Wildcards>)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3371
msgid ""
"The most common input section description is to include all input sections "
"with a particular name in the output section. For example, to include all "
"input E<.Li .text> sections, you would write:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3373
#, no-wrap
msgid "*(.text)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3379
msgid ""
"Here the E<.Li *> is a wildcard which matches any file name. To exclude a "
"list of files from matching the file name wildcard, EXCLUDE_FILE may be used "
"to match all files except the ones specified in the EXCLUDE_FILE list. For "
"example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3381
#, no-wrap
msgid "(*(EXCLUDE_FILE (*crtend.o *otherfile.o) .ctors))\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3387
msgid ""
"will cause all .ctors sections from all files except E<.Pa crtend.o> and "
"E<.Pa otherfile.o> to be included."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3389
msgid "There are two ways to include more than one section:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3392
#, no-wrap
msgid ""
"*(.text .rdata)\n"
"*(.text) *(.rdata)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3404
msgid ""
"The difference between these is the order in which the E<.Li .text> and "
"E<.Li .rdata> input sections will appear in the output section. In the first "
"example, they will be intermingled, appearing in the same order as they are "
"found in the linker input. In the second example, all E<.Li .text> input "
"sections will appear first, followed by all E<.Li .rdata> input sections."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3408
msgid ""
"You can specify a file name to include sections from a particular file. You "
"would do this if one or more of your files contain special data that needs "
"to be at a particular location in memory. For example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3410
#, no-wrap
msgid "data.o(.data)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3415
msgid ""
"If you use a file name without a list of sections, then all sections in the "
"input file will be included in the output section. This is not commonly "
"done, but it may by useful on occasion. For example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3417
#, no-wrap
msgid "data.o\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3429
msgid ""
"When you use a file name which does not contain any wild card characters, "
"the linker will first see if you also specified the file name on the linker "
"command line or in an E<.Li INPUT> command. If you did not, the linker will "
"attempt to open the file as an input file, as though it appeared on the "
"command line. Note that this differs from an E<.Li INPUT> command, because "
"the linker will not search for the file in the archive search path."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3431
msgid "E<.No Input Section Wildcard Patterns>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3434
msgid ""
"In an input section description, either the file name or the section name or "
"both may be wildcard patterns."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3438
msgid ""
"The file name of E<.Li *> seen in many examples is a simple wildcard pattern "
"for the file name."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3440
msgid "The wildcard patterns are like those used by the Unix shell."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3442
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3444
msgid "matches any number of characters"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3444
#, no-wrap
msgid "?"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3446
msgid "matches any single character"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3446
#, no-wrap
msgid "[ Va chars]"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3454
msgid ""
"matches a single instance of any of the E<.Va chars>; the E<.Li -> character "
"may be used to specify a range of characters, as in E<.Li [a-z]> to match "
"any lower case letter"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3454
#, no-wrap
msgid "\\e"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3456
msgid "quotes the following character"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3470
msgid ""
"When a file name is matched with a wildcard, the wildcard characters will "
"not match a E<.Li /> character (used to separate directory names on Unix). A "
"pattern consisting of a single E<.Li *> character is an exception; it will "
"always match any file name, whether it contains a E<.Li /> or not. In a "
"section name, the wildcard characters will match a E<.Li /> character."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3475
msgid ""
"File name wildcard patterns only match files which are explicitly specified "
"on the command line or in an E<.Li INPUT> command. The linker does not "
"search directories to expand wildcards."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3482
msgid ""
"If a file name matches more than one wildcard pattern, or if a file name "
"appears explicitly and is also matched by a wildcard pattern, the linker "
"will use the first match in the linker script. For example, this sequence of "
"input section descriptions is probably in error, because the E<.Pa data.o> "
"rule will not be used:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3485
#, no-wrap
msgid ""
"\\&.data : { *(.data) }\n"
"\\&.data1 : { data.o(.data) }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3497
msgid ""
"Normally, the linker will place files and sections matched by wildcards in "
"the order in which they are seen during the link. You can change this by "
"using the E<.Li SORT_BY_NAME> keyword, which appears before a wildcard "
"pattern in parentheses (e.g., E<.Li SORT_BY_NAME(.text*)>).  When the E<.Li "
"SORT_BY_NAME> keyword is used, the linker will sort the files or sections "
"into ascending order by name before placing them in the output file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3505
msgid ""
"E<.Li SORT_BY_ALIGNMENT> is very similar to E<.Li SORT_BY_NAME>.  The "
"difference is E<.Li SORT_BY_ALIGNMENT> will sort sections into ascending "
"order by alignment before placing them in the output file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3509
msgid "E<.Li SORT> is an alias for E<.Li SORT_BY_NAME>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3512
msgid ""
"When there are nested section sorting commands in linker script, there can "
"be at most 1 level of nesting for section sorting commands."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3520
msgid ""
"E<.Li SORT_BY_NAME> ( E<.Li SORT_BY_ALIGNMENT> (wildcard section "
"pattern)). It will sort the input sections by name first, then by alignment "
"if 2 sections have the same name."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3526
msgid ""
"E<.Li SORT_BY_ALIGNMENT> ( E<.Li SORT_BY_NAME> (wildcard section "
"pattern)). It will sort the input sections by alignment first, then by name "
"if 2 sections have the same alignment."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3533
msgid ""
"E<.Li SORT_BY_NAME> ( E<.Li SORT_BY_NAME> (wildcard section pattern)) is "
"treated the same as E<.Li SORT_BY_NAME> (wildcard section pattern)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3540
msgid ""
"E<.Li SORT_BY_ALIGNMENT> ( E<.Li SORT_BY_ALIGNMENT> (wildcard section "
"pattern)) is treated the same as E<.Li SORT_BY_ALIGNMENT> (wildcard section "
"pattern)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3542
msgid "All other nested section sorting commands are invalid."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3547
msgid ""
"When both command line section sorting option and linker script section "
"sorting command are used, section sorting command always takes precedence "
"over the command line option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3551
msgid ""
"If the section sorting command in linker script isn't nested, the command "
"line option will make the section sorting command to be treated as nested "
"sorting command."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3562
msgid ""
"E<.Li SORT_BY_NAME> (wildcard section pattern ) with E<.Op --sort-sections "
"alignment> is equivalent to E<.Li SORT_BY_NAME> ( E<.Li SORT_BY_ALIGNMENT> "
"(wildcard section pattern))."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3571
msgid ""
"E<.Li SORT_BY_ALIGNMENT> (wildcard section pattern) with E<.Op "
"--sort-section name> is equivalent to E<.Li SORT_BY_ALIGNMENT> ( E<.Li "
"SORT_BY_NAME> (wildcard section pattern))."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3575
msgid ""
"If the section sorting command in linker script is nested, the command line "
"option will be ignored."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3580
msgid ""
"If you ever get confused about where input sections are going, use the E<.Li "
"-M> linker option to generate a map file. The map file shows precisely how "
"input sections are mapped to output sections."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3598
msgid ""
"This example shows how wildcard patterns might be used to partition files.  "
"This linker script directs the linker to place all E<.Li .text> sections in "
"E<.Li .text> and all E<.Li .bss> sections in E<.Li .bss>.  The linker will "
"place the E<.Li .data> section from all files beginning with an upper case "
"character in E<.Li .DATA>; for all other files, the linker will place the "
"E<.Li .data> section in E<.Li .data>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3606
#, no-wrap
msgid ""
"SECTIONS {\n"
"  .text : { *(.text) }\n"
"  .DATA : { [A-Z]*(.data) }\n"
"  .data : { *(.data) }\n"
"  .bss : { *(.bss) }\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3610
msgid "E<.No Input Section for Common Symbols>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3615
msgid ""
"A special notation is needed for common symbols, because in many object file "
"formats common symbols do not have a particular input section. The linker "
"treats common symbols as though they are in an input section named E<.Li "
"COMMON>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3621
msgid ""
"You may use file names with the E<.Li COMMON> section just as with any other "
"input sections. You can use this to place common symbols from a particular "
"input file in one section while common symbols from other input files are "
"placed in another section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3625
msgid ""
"In most cases, common symbols in input files will be placed in the E<.Li "
".bss> section in the output file. For example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3627
#, no-wrap
msgid "\\&.bss { *(.bss) *(COMMON) }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3639
msgid ""
"Some object file formats have more than one type of common symbol. For "
"example, the MIPS ELF object file format distinguishes standard common "
"symbols and small common symbols. In this case, the linker will use a "
"different special section name for other types of common symbols. In the "
"case of MIPS ELF, the linker uses E<.Li COMMON> for standard common symbols "
"and E<.Li .scommon> for small common symbols. This permits you to map the "
"different types of common symbols into memory at different locations."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3645
msgid ""
"You will sometimes see E<.Li [COMMON]> in old linker scripts. This notation "
"is now considered obsolete. It is equivalent to E<.Li *(COMMON)>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3647
msgid "E<.No Input Section and Garbage Collection>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3657
msgid ""
"When link-time garbage collection is in use ( E<.Li --gc-sections>), it is "
"often useful to mark sections that should not be eliminated. This is "
"accomplished by surrounding an input section's wildcard entry with E<.Li "
"KEEP()>, as in E<.Li KEEP(*(.init))> or E<.Li "
"KEEP(SORT_BY_NAME(*)(.ctors))>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3659
msgid "E<.No Input Section Example>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3687
msgid ""
"The following example is a complete linker script. It tells the linker to "
"read all of the sections from file E<.Pa all.o> and place them at the start "
"of output section E<.Li outputa> which starts at location E<.Li 0x10000>.  "
"All of section E<.Li .input1> from file E<.Pa foo.o> follows immediately, in "
"the same output section. All of section E<.Li .input2> from E<.Pa foo.o> "
"goes into output section E<.Li outputb>, followed by section E<.Li .input1> "
"from E<.Pa foo1.o>.  All of the remaining E<.Li .input1> and E<.Li .input2> "
"sections from any files are written to output section E<.Li outputc>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3696
#, no-wrap
msgid ""
"SECTIONS {\n"
"  outputa 0x10000 :\n"
"    {\n"
"    all.o\n"
"    foo.o (.input1)\n"
"    }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3703
#, no-wrap
msgid ""
"  outputb :\n"
"    {\n"
"    foo.o (.input2)\n"
"    foo1.o (.input1)\n"
"    }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3711
#, no-wrap
msgid ""
"  outputc :\n"
"    {\n"
"    *(.input1)\n"
"    *(.input2)\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3715
msgid "E<.Em Output Section Data>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3728
msgid ""
"You can include explicit bytes of data in an output section by using E<.Li "
"BYTE>, E<.Li SHORT>, E<.Li LONG>, E<.Li QUAD>, or E<.Li SQUAD> as an output "
"section command. Each keyword is followed by an expression in parentheses "
"providing the value to store (see Section E<.Dq Expressions>).  The value of "
"the expression is stored at the current value of the location counter."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3737
msgid ""
"The E<.Li BYTE>, E<.Li SHORT>, E<.Li LONG>, and E<.Li QUAD> commands store "
"one, two, four, and eight bytes (respectively). After storing the bytes, the "
"location counter is incremented by the number of bytes stored."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3741
msgid ""
"For example, this will store the byte 1 followed by the four byte value of "
"the symbol E<.Li addr>:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3744
#, no-wrap
msgid ""
"BYTE(1)\n"
"LONG(addr)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3756
msgid ""
"When using a 64 bit host or target, E<.Li QUAD> and E<.Li SQUAD> are the "
"same; they both store an 8 byte, or 64 bit, value. When both host and target "
"are 32 bits, an expression is computed as 32 bits. In this case E<.Li QUAD> "
"stores a 32 bit value zero extended to 64 bits, and E<.Li SQUAD> stores a 32 "
"bit value sign extended to 64 bits."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3762
msgid ""
"If the object file format of the output file has an explicit endianness, "
"which is the normal case, the value will be stored in that endianness. When "
"the object file format does not have an explicit endianness, as is true of, "
"for example, S-records, the value will be stored in the endianness of the "
"first input object file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3765
msgid ""
"Note---these commands only work inside a section description and not between "
"them, so the following will produce an error from the linker:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3767
#, no-wrap
msgid "SECTIONS { .text : { *(.text) } LONG(1) .data : { *(.data) } } \n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3769
msgid "whereas this will work:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3771
#, no-wrap
msgid "SECTIONS { .text : { *(.text) ; LONG(1) } .data : { *(.data) } } \n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3786
msgid ""
"You may use the E<.Li FILL> command to set the fill pattern for the current "
"section. It is followed by an expression in parentheses. Any otherwise "
"unspecified regions of memory within the section (for example, gaps left due "
"to the required alignment of input sections) are filled with the value of "
"the expression, repeated as necessary.  A E<.Li FILL> statement covers "
"memory locations after the point at which it occurs in the section "
"definition; by including more than one E<.Li FILL> statement, you can have "
"different fill patterns in different parts of an output section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3789
msgid ""
"This example shows how to fill unspecified regions of memory with the value "
"E<.Li 0x90>:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3791
#, no-wrap
msgid "FILL(0x90909090)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3805
msgid ""
"The E<.Li FILL> command is similar to the E<.Li = Va fillexp> output section "
"attribute, but it only affects the part of the section following the E<.Li "
"FILL> command, rather than the entire section. If both are used, the E<.Li "
"FILL> command takes precedence.See Section E<.Dq Output Section Fill>, for "
"details on the fill expression."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3807
msgid "E<.Em Output Section Keywords>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3809
msgid "There are a couple of keywords which can appear as output section commands."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3811
#, no-wrap
msgid "CREATE_OBJECT_SYMBOLS"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3817
msgid ""
"The command tells the linker to create a symbol for each input file. The "
"name of each symbol will be the name of the corresponding input file. The "
"section of each symbol will be the output section in which the E<.Li "
"CREATE_OBJECT_SYMBOLS> command appears."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3820
msgid ""
"This is conventional for the a.out object file format. It is not normally "
"used for any other object file format."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3821
#, no-wrap
msgid "CONSTRUCTORS"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3834
msgid ""
"When linking using the a.out object file format, the linker uses an unusual "
"set construct to support C++ global constructors and destructors. When "
"linking object file formats which do not support arbitrary sections, such as "
"ECOFF and XCOFF, the linker will automatically recognize C++ global "
"constructors and destructors by name. For these object file formats, the "
"E<.Li CONSTRUCTORS> command tells the linker to place constructor "
"information in the output section where the E<.Li CONSTRUCTORS> command "
"appears. The E<.Li CONSTRUCTORS> command is ignored for other object file "
"formats."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3856
msgid ""
"The symbol E<.Li __CTOR_LIST__> marks the start of the global constructors, "
"and the symbol E<.Li __CTOR_END__> marks the end. Similarly, E<.Li "
"__DTOR_LIST__> and E<.Li __DTOR_END__> mark the start and end of the global "
"destructors. The first word in the list is the number of entries, followed "
"by the address of each constructor or destructor, followed by a zero "
"word. The compiler must arrange to actually run the code.  For these object "
"file formats GNU C++ normally calls constructors from a subroutine E<.Li "
"__main>; a call to E<.Li __main> is automatically inserted into the startup "
"code for E<.Li main>.  GNU C++ normally runs destructors either by using "
"E<.Li atexit>, or directly from the function E<.Li exit>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3868
msgid ""
"For object file formats such as E<.Li COFF> or E<.Li ELF> which support "
"arbitrary section names, GNU C++ will normally arrange to put the addresses "
"of global constructors and destructors into the E<.Li .ctors> and E<.Li "
".dtors> sections. Placing the following sequence into your linker script "
"will build the sort of table which the GNU C++ runtime code expects to see."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3880
#, no-wrap
msgid ""
"      __CTOR_LIST__ = .;\n"
"      LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2)\n"
"      *(.ctors)\n"
"      LONG(0)\n"
"      __CTOR_END__ = .;\n"
"      __DTOR_LIST__ = .;\n"
"      LONG((__DTOR_END__ - __DTOR_LIST__) / 4 - 2)\n"
"      *(.dtors)\n"
"      LONG(0)\n"
"      __DTOR_END__ = .;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3901
msgid ""
"If you are using the GNU C++ support for initialization priority, which "
"provides some control over the order in which global constructors are run, "
"you must sort the constructors at link time to ensure that they are executed "
"in the correct order. When using the E<.Li CONSTRUCTORS> command, use E<.Li "
"SORT_BY_NAME(CONSTRUCTORS)> instead. When using the E<.Li .ctors> and E<.Li "
".dtors> sections, use E<.Li *(SORT_BY_NAME(.ctors))> and E<.Li "
"*(SORT_BY_NAME(.dtors))> instead of just E<.Li *(.ctors)> and E<.Li "
"*(.dtors)>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3905
msgid ""
"Normally the compiler and linker will handle these issues automatically, and "
"you will not need to concern yourself with them. However, you may need to "
"consider this if you are using C++ and writing your own linker scripts."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3908
msgid "E<.Em Output Section Discarding>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3912
msgid ""
"The linker will not create output sections with no contents. This is for "
"convenience when referring to input sections that may or may not be present "
"in any of the input files. For example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3914
#, no-wrap
msgid "\\&.foo : { *(.foo) }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3922
msgid ""
"will only create a E<.Li .foo> section in the output file if there is a "
"E<.Li .foo> section in at least one input file, and if the input sections "
"are not all empty. Other link script directives that allocate space in an "
"output section will also create the output section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3928
msgid ""
"The linker will ignore address assignments (see Section E<.Dq Output Section "
"Address>)  on discarded output sections, except when the linker script "
"defines symbols in the output section. In that case the linker will obey the "
"address assignments, possibly advancing dot even though the section is "
"discarded."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3935
msgid ""
"The special output section name E<.Li /DISCARD/> may be used to discard "
"input sections. Any input sections which are assigned to an output section "
"named E<.Li /DISCARD/> are not included in the output file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3937
msgid "E<.Em Output Section Attributes>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3940
msgid ""
"We showed above that the full description of an output section looked like "
"this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3957
msgid ""
"We've already described E<.Va section>, E<.Va address>, and E<.Va "
"output-section-command>.  In this section we will describe the remaining "
"section attributes."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3959
msgid "E<.No Output Section Type>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3962
msgid ""
"Each output section may have a type. The type is a keyword in parentheses.  "
"The following types are defined:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3964
#, no-wrap
msgid "NOLOAD"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3967
msgid ""
"The section should be marked as not loadable, so that it will not be loaded "
"into memory when the program is run."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3967
#, no-wrap
msgid "DSECT"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3968
#, no-wrap
msgid "COPY"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3969
#, no-wrap
msgid "INFO"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:3970
#, no-wrap
msgid "OVERLAY"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3974
msgid ""
"These type names are supported for backward compatibility, and are rarely "
"used. They all have the same effect: the section should be marked as not "
"allocatable, so that no memory is allocated for the section when the program "
"is run."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3985
msgid ""
"The linker normally sets the attributes of an output section based on the "
"input sections which map into it. You can override this by using the section "
"type. For example, in the script sample below, the E<.Li ROM> section is "
"addressed at memory location E<.Li 0> and does not need to be loaded when "
"the program is run. The contents of the E<.Li ROM> section will appear in "
"the linker output file as usual."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3991
#, no-wrap
msgid ""
"SECTIONS {\n"
"  ROM 0 (NOLOAD) : { ... }\n"
"  ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:3995
msgid "E<.No Output Section LMA>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4000
msgid ""
"Every section has a virtual address (VMA) and a load address (LMA); see "
"Basic Script Concepts. The address expression which may appear in an output "
"section description sets the VMA (see Section E<.Dq Output Section "
"Address>)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4006
msgid ""
"The expression E<.Va lma> that follows the E<.Li AT> keyword specifies the "
"load address of the section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4015
msgid ""
"Alternatively, with E<.Li ATE<gt> Va lma_region> expression, you may specify "
"a memory region for the section's load address.See Section E<.Dq MEMORY>.  "
"Note that if the section has not had a VMA assigned to it then the linker "
"will use the E<.Va lma_region> as the VMA region as well."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4026
msgid ""
"If neither E<.Li AT> nor E<.Li ATE<gt>> is specified for an allocatable "
"section, the linker will set the LMA such that the difference between VMA "
"and LMA for the section is the same as the preceding output section in the "
"same region. If there is no preceding output section or the section is not "
"allocatable, the linker will set the LMA equal to the VMA.See Section E<.Dq "
"Output Section Region>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4047
msgid ""
"This feature is designed to make it easy to build a ROM image. For example, "
"the following linker script creates three output sections: one called E<.Li "
".text>, which starts at E<.Li 0x1000>, one called E<.Li .mdata>, which is "
"loaded at the end of the E<.Li .text> section even though its VMA is E<.Li "
"0x2000>, and one called E<.Li .bss> to hold uninitialized data at address "
"E<.Li 0x3000>.  The symbol E<.Li _data> is defined with the value E<.Li "
"0x2000>, which shows that the location counter holds the VMA value, not the "
"LMA value."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4059
#, no-wrap
msgid ""
"SECTIONS\n"
"  {\n"
"  .text 0x1000 : { *(.text) _etext = . ; }\n"
"  .mdata 0x2000 :\n"
"    AT ( ADDR (.text) + SIZEOF (.text) )\n"
"    { _data = . ; *(.data); _edata = . ;  }\n"
"  .bss 0x3000 :\n"
"    { _bstart = . ;  *(.bss) *(COMMON) ; _bend = . ;}\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4066
msgid ""
"The run-time initialization code for use with a program generated with this "
"linker script would include something like the following, to copy the "
"initialized data from the ROM image to its runtime address. Notice how this "
"code takes advantage of the symbols defined by the linker script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4072
#, no-wrap
msgid ""
"extern char _etext, _data, _edata, _bstart, _bend;\n"
"char *src = &_etext;\n"
"char *dst = &_data;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4077
#, no-wrap
msgid ""
"/* ROM has data at end of text; copy it. */\n"
"while (dst E<lt> &_edata) {\n"
"  *dst++ = *src++;\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4081
#, no-wrap
msgid ""
"/* Zero bss */\n"
"for (dst = &_bstart; dstE<lt> &_bend; dst++)\n"
"  *dst = 0;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4085
msgid "E<.No Forced Output Alignment>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4087
msgid "You can increase an output section's alignment by using ALIGN."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4089
msgid "E<.No Forced Input Alignment>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4093
msgid ""
"You can force input section alignment within an output section by using "
"SUBALIGN.  The value specified overrides any alignment given by input "
"sections, whether larger or smaller."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4095
msgid "E<.No Output Section Region>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4099
msgid ""
"You can assign a section to a previously defined region of memory by using "
"E<.Li E<gt> Va region>.  See Section.Dq MEMORY ."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4101 /usr/src/contrib/binutils/ld/ld.7:4121 /usr/src/contrib/binutils/ld/ld.7:4157
msgid "Here is a simple example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4105
#, no-wrap
msgid ""
"MEMORY { rom : ORIGIN = 0x1000, LENGTH = 0x1000 }\n"
"SECTIONS { ROM : { *(.text) } E<gt>rom }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4109
msgid "E<.No Output Section Phdr>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4119
msgid ""
"You can assign a section to a previously defined program segment by using "
"E<.Li : Va phdr>.  See Section.Dq PHDRS .  If a section is assigned to one "
"or more segments, then all subsequent allocated sections will be assigned to "
"those segments as well, unless they use an explicitly E<.Li : Va phdr> "
"modifier. You can use E<.Li :NONE> to tell the linker to not put the section "
"in any segment at all."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4125
#, no-wrap
msgid ""
"PHDRS { text PT_LOAD ; }\n"
"SECTIONS { .text : { *(.text) } :text }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4129
msgid "E<.No Output Section Fill>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4150
msgid ""
"You can set the fill pattern for an entire section by using E<.Li = Va "
"fillexp>.  E<.Va fillexp> is an expression (see Section E<.Dq "
"Expressions>).  Any otherwise unspecified regions of memory within the "
"output section (for example, gaps left due to the required alignment of "
"input sections) will be filled with the value, repeated as necessary. If the "
"fill expression is a simple hex number, ie. a string of hex digit starting "
"with E<.Li 0x> and without a trailing E<.Li k> or E<.Li M>, then an "
"arbitrarily long sequence of hex digits can be used to specify the fill "
"pattern; Leading zeros become part of the pattern too. For all other cases, "
"including extra parentheses or a unary E<.Li +>, the fill pattern is the "
"four least significant bytes of the value of the expression.  In all cases, "
"the number is big-endian."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4155
msgid ""
"You can also change the fill value with a E<.Li FILL> command in the output "
"section commands; (see Section E<.Dq Output Section Data>)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4160
#, no-wrap
msgid "SECTIONS { .text : { *(.text) } =0x90909090 }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4164
msgid "E<.Em Overlay Description>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4171
msgid ""
"An overlay description provides an easy way to describe sections which are "
"to be loaded as part of a single memory image but are to be run at the same "
"memory address. At run time, some sort of overlay manager will copy the "
"overlaid sections in and out of the runtime memory address as required, "
"perhaps by simply manipulating addressing bits. This approach can be useful, "
"for example, when a certain region of memory is faster than another."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4181
msgid ""
"Overlays are described using the E<.Li OVERLAY> command. The E<.Li OVERLAY> "
"command is used within a E<.Li SECTIONS> command, like an output section "
"description. The full syntax of the E<.Li OVERLAY> command is as follows:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4199
#, no-wrap
msgid ""
"OVERLAY [start] : [NOCROSSREFS] [AT ( ldaddr )]\n"
"  {\n"
"    secname1\n"
"      {\n"
"        output-section-command\n"
"        output-section-command\n"
"        ...\n"
"      } [:phdr...] [=fill]\n"
"    secname2\n"
"      {\n"
"        output-section-command\n"
"        output-section-command\n"
"        ...\n"
"      } [:phdr...] [=fill]\n"
"    ...\n"
"  } [E<gt>region] [:phdr...] [=fill]\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4217
msgid ""
"Everything is optional except E<.Li OVERLAY> (a keyword), and each section "
"must have a name ( E<.Va secname1> and E<.Va secname2> above). The section "
"definitions within the E<.Li OVERLAY> construct are identical to those "
"within the general E<.Li SECTIONS> contruct (see Section E<.Dq SECTIONS>), "
"except that no addresses and no memory regions may be defined for sections "
"within an E<.Li OVERLAY>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4225
msgid ""
"The sections are all defined with the same starting address. The load "
"addresses of the sections are arranged such that they are consecutive in "
"memory starting at the load address used for the E<.Li OVERLAY> as a whole "
"(as with normal section definitions, the load address is optional, and "
"defaults to the start address; the start address is also optional, and "
"defaults to the current value of the location counter)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4232
msgid ""
"If the E<.Li NOCROSSREFS> keyword is used, and there any references among "
"the sections, the linker will report an error. Since the sections all run at "
"the same address, it normally does not make sense for one section to refer "
"directly to another.See Section E<.Dq Miscellaneous Commands>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4243
msgid ""
"For each section within the E<.Li OVERLAY>, the linker automatically "
"provides two symbols. The symbol E<.Li __load_start_ Va secname> is defined "
"as the starting load address of the section. The symbol E<.Li __load_stop_ "
"Va secname> is defined as the final load address of the section. Any "
"characters within E<.Va secname> which are not legal within C identifiers "
"are removed. C (or assembler) code may use these symbols to move the "
"overlaid sections around as necessary."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4246
msgid ""
"At the end of the overlay, the value of the location counter is set to the "
"start address of the overlay plus the size of the largest section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4250
msgid ""
"Here is an example. Remember that this would appear inside a E<.Li SECTIONS> "
"construct."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4257
#, no-wrap
msgid ""
"  OVERLAY 0x1000 : AT (0x4000)\n"
"   {\n"
"     .text0 { o1/*.o(.text) }\n"
"     .text1 { o2/*.o(.text) }\n"
"   }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4274
msgid ""
"This will define both E<.Li .text0> and E<.Li .text1> to start at address "
"0x1000.  E<.Li .text0> will be loaded at address 0x4000, and E<.Li .text1> "
"will be loaded immediately after E<.Li .text0>.  The following symbols will "
"be defined if referenced: E<.Li __load_start_text0>, E<.Li "
"__load_stop_text0>, E<.Li __load_start_text1>, E<.Li __load_stop_text1>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4278
msgid ""
"C code to copy overlay E<.Li .text1> into the overlay area might look like "
"the following."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4284
#, no-wrap
msgid ""
"  extern char __load_start_text1, __load_stop_text1;\n"
"  memcpy ((char *) 0x1000, &__load_start_text1,\n"
"          &__load_stop_text1 - &__load_start_text1);\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4292
msgid ""
"Note that the E<.Li OVERLAY> command is just syntactic sugar, since "
"everything it does can be done using the more basic commands. The above "
"example could have been written identically as follows."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4302
#, no-wrap
msgid ""
"  .text0 0x1000 : AT (0x4000) { o1/*.o(.text) }\n"
"  PROVIDE (__load_start_text0 = LOADADDR (.text0));\n"
"  PROVIDE (__load_stop_text0 = LOADADDR (.text0) + SIZEOF (.text0));\n"
"  .text1 0x1000 : AT (0x4000 + SIZEOF (.text0)) { o2/*.o(.text) }\n"
"  PROVIDE (__load_start_text1 = LOADADDR (.text1));\n"
"  PROVIDE (__load_stop_text1 = LOADADDR (.text1) + SIZEOF (.text1));\n"
"  . = 0x1000 + MAX (SIZEOF (.text0), SIZEOF (.text1));\n"
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:4305
#, no-wrap
msgid "MEMORY Command"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4310
msgid ""
"The linker's default configuration permits allocation of all available "
"memory.  You can override this by using the E<.Li MEMORY> command."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4319
msgid ""
"The E<.Li MEMORY> command describes the location and size of blocks of "
"memory in the target.  You can use it to describe which memory regions may "
"be used by the linker, and which memory regions it must avoid. You can then "
"assign sections to particular memory regions. The linker will set section "
"addresses based on the memory regions, and will warn about regions that "
"become too full. The linker will not shuffle sections around to fit into the "
"available regions."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4324
msgid ""
"A linker script may contain at most one use of the E<.Li MEMORY> "
"command. However, you can define as many blocks of memory within it as you "
"wish. The syntax is:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4331
#, no-wrap
msgid ""
"MEMORY\n"
"  {\n"
"    name [(attr)] : ORIGIN = origin, LENGTH = len\n"
"    ...\n"
"  }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4340
msgid ""
"The E<.Va name> is a name used in the linker script to refer to the "
"region. The region name has no meaning outside of the linker script. Region "
"names are stored in a separate name space, and will not conflict with symbol "
"names, file names, or section names. Each memory region must have a distinct "
"name."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4349
msgid ""
"The E<.Va attr> string is an optional list of attributes that specify "
"whether to use a particular memory region for an input section which is not "
"explicitly mapped in the linker script. As described in SECTIONS, if you do "
"not specify an output section for some input section, the linker will create "
"an output section with the same name as the input section. If you define "
"region attributes, the linker will use them to select the memory region for "
"the output section that it creates."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4353
msgid "The E<.Va attr> string must consist only of the following characters:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4354
#, no-wrap
msgid "R"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4356
msgid "Read-only section"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4356
#, no-wrap
msgid "W"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4358
msgid "Read/write section"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4358
#, no-wrap
msgid "X"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4360
msgid "Executable section"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4360
#, no-wrap
msgid "A"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4362
msgid "Allocatable section"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4362
#, no-wrap
msgid "I"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4364
msgid "Initialized section"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4364
#, no-wrap
msgid "L"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4367
msgid "Same as E<.Li I>"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4367
#, no-wrap
msgid "!"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4369
msgid "Invert the sense of any of the preceding attributes"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4377
msgid ""
"If a unmapped section matches any of the listed attributes other than E<.Li "
"!>, it will be placed in the memory region. The E<.Li !> attribute reverses "
"this test, so that an unmapped section will be placed in the memory region "
"only if it does not match any of the listed attributes."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4390
msgid ""
"The E<.Va origin> is an numerical expression for the start address of the "
"memory region. The expression must evaluate to a constant and it cannot "
"involve any symbols.  The keyword E<.Li ORIGIN> may be abbreviated to E<.Li "
"org> or E<.Li o> (but not, for example, E<.Li ORG>)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4402
msgid ""
"The E<.Va len> is an expression for the size in bytes of the memory "
"region. As with the E<.Va origin> expression, the expression must be "
"numerical only and must evaluate to a constant.  The keyword E<.Li LENGTH> "
"may be abbreviated to E<.Li len> or E<.Li l>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4415
msgid ""
"In the following example, we specify that there are two memory regions "
"available for allocation: one starting at E<.Li 0> for 256 kilobytes, and "
"the other starting at E<.Li 0x40000000> for four megabytes. The linker will "
"place into the E<.Li rom> memory region every section which is not "
"explicitly mapped into a memory region, and is either read-only or "
"executable. The linker will place other sections which are not explicitly "
"mapped into a memory region into the E<.Li ram> memory region."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4423
#, no-wrap
msgid ""
"MEMORY\n"
"  {\n"
"    rom (rx)  : ORIGIN = 0, LENGTH = 256K\n"
"    ram (!rx) : org = 0x40000000, l = 4M\n"
"  }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4439
msgid ""
"Once you define a memory region, you can direct the linker to place specific "
"output sections into that memory region by using the E<.Li E<gt> Va region> "
"output section attribute. For example, if you have a memory region named "
"E<.Li mem>, you would use E<.Li E<gt>mem> in the output section "
"definition.See Section E<.Dq Output Section Region>.  If no address was "
"specified for the output section, the linker will set the address to the "
"next available address within the memory region. If the combined output "
"sections directed to a memory region are too large for the region, the "
"linker will issue an error message."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4446
msgid ""
"It is possible to access the origin and length of a memory in an expression "
"via the E<.Li ORIGIN( Va memory)> and E<.Li LENGTH( Va memory)> functions:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4450
#, no-wrap
msgid "  _fstack = ORIGIN(ram) + LENGTH(ram) - 4;  \n"
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:4453
#, no-wrap
msgid "PHDRS Command"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4464
msgid ""
"The ELF object file format uses E<.Em program headers>, also knows as E<.Em "
"segments>.  The program headers describe how the program should be loaded "
"into memory.  You can print them out by using the E<.Li objdump> program "
"with the E<.Li -p> option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4470
msgid ""
"When you run an ELF program on a native ELF system, the system loader reads "
"the program headers in order to figure out how to load the program. This "
"will only work if the program headers are set correctly. This manual does "
"not describe the details of how the system loader interprets program "
"headers; for more information, see the ELF ABI."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4479
msgid ""
"The linker will create reasonable program headers by default. However, in "
"some cases, you may need to specify the program headers more precisely. You "
"may use the E<.Li PHDRS> command for this purpose. When the linker sees the "
"E<.Li PHDRS> command in the linker script, it will not create any program "
"headers other than the ones specified."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4485
msgid ""
"The linker only pays attention to the E<.Li PHDRS> command when generating "
"an ELF output file. In other cases, the linker will simply ignore E<.Li "
"PHDRS>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4495
msgid ""
"This is the syntax of the E<.Li PHDRS> command. The words E<.Li PHDRS>, "
"E<.Li FILEHDR>, E<.Li AT>, and E<.Li FLAGS> are keywords."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4503
#, no-wrap
msgid ""
"PHDRS\n"
"{\n"
"  name type [ FILEHDR ] [ PHDRS ] [ AT ( address ) ]\n"
"        [ FLAGS ( flags ) ] ;\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4514
msgid ""
"The E<.Va name> is used only for reference in the E<.Li SECTIONS> command of "
"the linker script. It is not put into the output file. Program header names "
"are stored in a separate name space, and will not conflict with symbol "
"names, file names, or section names. Each program header must have a "
"distinct name."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4522
msgid ""
"Certain program header types describe segments of memory which the system "
"loader will load from the file. In the linker script, you specify the "
"contents of these segments by placing allocatable output sections in the "
"segments.  You use the E<.Li : Va phdr> output section attribute to place a "
"section in a particular segment.See Section E<.Dq Output Section Phdr>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4527
msgid ""
"It is normal to put certain sections in more than one segment. This merely "
"implies that one segment of memory contains another. You may repeat E<.Li : "
"Va phdr>, using it once for each segment which should contain the section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4538
msgid ""
"If you place a section in one or more segments using E<.Li : Va phdr>, then "
"the linker will place all subsequent allocatable sections which do not "
"specify E<.Li : Va phdr> in the same segments. This is for convenience, "
"since generally a whole set of contiguous sections will be placed in a "
"single segment. You can use E<.Li :NONE> to override the default segment and "
"tell the linker to not put the section in any segment at all."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4549
msgid ""
"You may use the E<.Li FILEHDR> and E<.Li PHDRS> keywords appear after the "
"program header type to further describe the contents of the segment. The "
"E<.Li FILEHDR> keyword means that the segment should include the ELF file "
"header. The E<.Li PHDRS> keyword means that the segment should include the "
"ELF program headers themselves."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4553
msgid ""
"The E<.Va type> may be one of the following. The numbers indicate the value "
"of the keyword."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4555
#, no-wrap
msgid "Li PT_NULL (0)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4557
msgid "Indicates an unused program header."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4558
#, no-wrap
msgid "Li PT_LOAD (1)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4561
msgid ""
"Indicates that this program header describes a segment to be loaded from the "
"file."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4562
#, no-wrap
msgid "Li PT_DYNAMIC (2)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4564
msgid "Indicates a segment where dynamic linking information can be found."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4565
#, no-wrap
msgid "Li PT_INTERP (3)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4567
msgid "Indicates a segment where the name of the program interpreter may be found."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4568
#, no-wrap
msgid "Li PT_NOTE (4)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4570
msgid "Indicates a segment holding note information."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4571
#, no-wrap
msgid "Li PT_SHLIB (5)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4573
msgid "A reserved program header type, defined but not specified by the ELF ABI."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4574
#, no-wrap
msgid "Li PT_PHDR (6)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4576
msgid "Indicates a segment where the program headers may be found."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:4577
#, no-wrap
msgid "Va expression"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4580
msgid ""
"An expression giving the numeric type of the program header. This may be "
"used for types not defined above."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4592
msgid ""
"You can specify that a segment should be loaded at a particular address in "
"memory by using an E<.Li AT> expression. This is identical to the E<.Li AT> "
"command used as an output section attribute (see Section E<.Dq Output "
"Section LMA>).  The E<.Li AT> command for a program header overrides the "
"output section attribute."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4601
msgid ""
"The linker will normally set the segment flags based on the sections which "
"comprise the segment. You may use the E<.Li FLAGS> keyword to explicitly "
"specify the segment flags. The value of E<.Va flags> must be an integer. It "
"is used to set the E<.Li p_flags> field of the program header."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4605
msgid ""
"Here is an example of E<.Li PHDRS>.  This shows a typical set of program "
"headers used on a native ELF system."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4616
#, no-wrap
msgid ""
"PHDRS\n"
"{\n"
"  headers PT_PHDR PHDRS ;\n"
"  interp PT_INTERP ;\n"
"  text PT_LOAD FILEHDR PHDRS ;\n"
"  data PT_LOAD ;\n"
"  dynamic PT_DYNAMIC ;\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4629
#, no-wrap
msgid ""
"SECTIONS\n"
"{\n"
"  . = SIZEOF_HEADERS;\n"
"  .interp : { *(.interp) } :text :interp\n"
"  .text : { *(.text) } :text\n"
"  .rodata : { *(.rodata) } /* defaults to :text */\n"
"  ...\n"
"  . = . + 0x1000; /* move to a new page in memory */\n"
"  .data : { *(.data) } :data\n"
"  .dynamic : { *(.dynamic) } :data :dynamic\n"
"  ...\n"
"}\n"
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:4632
#, no-wrap
msgid "VERSION Command"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4637
msgid ""
"The linker supports symbol versions when using ELF. Symbol versions are only "
"useful when using shared libraries. The dynamic linker can use symbol "
"versions to select a specific version of a function when it runs a program "
"that may have been linked against an earlier version of the shared library."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4643
msgid ""
"You can include a version script directly in the main linker script, or you "
"can supply the version script as an implicit linker script. You can also use "
"the E<.Li --version-script> linker option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4647
msgid "The syntax of the E<.Li VERSION> command is simply"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4649
#, no-wrap
msgid "VERSION { version-script-commands }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4657
msgid ""
"The format of the version script commands is identical to that used by Sun's "
"linker in Solaris 2.5. The version script defines a tree of version nodes.  "
"You specify the node names and interdependencies in the version script. You "
"can specify which symbols are bound to which version nodes, and you can "
"reduce a specified set of symbols to local scope so that they are not "
"globally visible outside of the shared library."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4659
msgid ""
"The easiest way to demonstrate the version script language is with a few "
"examples."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4669
#, no-wrap
msgid ""
"VERS_1.1 {\n"
"\t global:\n"
"\t\t foo1;\n"
"\t local:\n"
"\t\t old*;\n"
"\t\t original*;\n"
"\t\t new*;\n"
"};\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4673
#, no-wrap
msgid ""
"VERS_1.2 {\n"
"\t\t foo2;\n"
"} VERS_1.1;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4681
#, no-wrap
msgid ""
"VERS_2.0 {\n"
"\t\t bar1; bar2;\n"
"\t extern \"C++\" {       \n"
"\t\t ns::*;\n"
"\t\t \"int f(int, double)\";\n"
"         }         \n"
"} VERS_1.2;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4701
msgid ""
"This example version script defines three version nodes. The first version "
"node defined is E<.Li VERS_1.1>; it has no other dependencies. The script "
"binds the symbol E<.Li foo1> to E<.Li VERS_1.1>.  It reduces a number of "
"symbols to local scope so that they are not visible outside of the shared "
"library; this is done using wildcard patterns, so that any symbol whose name "
"begins with E<.Li old>, E<.Li original>, or E<.Li new> is matched. The "
"wildcard patterns available are the same as those used in the shell when "
"matching filenames (also known as \\(lqglobbing\\(rq). However, if you "
"specify the symbol name inside double quotes, then the name is treated as "
"literal, rather than as a glob pattern."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4710
msgid ""
"Next, the version script defines node E<.Li VERS_1.2>.  This node depends "
"upon E<.Li VERS_1.1>.  The script binds the symbol E<.Li foo2> to the "
"version node E<.Li VERS_1.2>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4721
msgid ""
"Finally, the version script defines node E<.Li VERS_2.0>.  This node depends "
"upon E<.Li VERS_1.2>.  The scripts binds the symbols E<.Li bar1> and E<.Li "
"bar2> are bound to the version node E<.Li VERS_2.0>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4728
msgid ""
"When the linker finds a symbol defined in a library which is not "
"specifically bound to a version node, it will effectively bind it to an "
"unspecified base version of the library. You can bind all otherwise "
"unspecified symbols to a given version node by using E<.Li global: *;> "
"somewhere in the version script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4737
msgid ""
"The names of the version nodes have no specific meaning other than what they "
"might suggest to the person reading them. The E<.Li 2.0> version could just "
"as well have appeared in between E<.Li 1.1> and E<.Li 1.2>.  However, this "
"would be a confusing way to write a version script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4741
msgid ""
"Node name can be omitted, provided it is the only version node in the "
"version script. Such version script doesn't assign any versions to symbols, "
"only selects which symbols will be globally visible out and which won't."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4744
#, no-wrap
msgid "{ global: foo; bar; local: *; };\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4755
msgid ""
"When you link an application against a shared library that has versioned "
"symbols, the application itself knows which version of each symbol it "
"requires, and it also knows which version nodes it needs from each shared "
"library it is linked against. Thus at runtime, the dynamic loader can make a "
"quick check to make sure that the libraries you have linked against do in "
"fact supply all of the version nodes that the application will need to "
"resolve all of the dynamic symbols. In this way it is possible for the "
"dynamic linker to know with certainty that all external symbols that it "
"needs will be resolvable without having to search for each symbol reference."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4764
msgid ""
"The symbol versioning is in effect a much more sophisticated way of doing "
"minor version checking that SunOS does. The fundamental problem that is "
"being addressed here is that typically references to external functions are "
"bound on an as-needed basis, and are not all bound when the application "
"starts up.  If a shared library is out of date, a required interface may be "
"missing; when the application tries to use that interface, it may suddenly "
"and unexpectedly fail. With symbol versioning, the user will get a warning "
"when they start their program if the libraries being used with the "
"application are too old."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4770
msgid ""
"There are several GNU extensions to Sun's versioning approach. The first of "
"these is the ability to bind a symbol to a version node in the source file "
"where the symbol is defined instead of in the versioning script. This was "
"done mainly to reduce the burden on the library maintainer. You can do this "
"by putting something like:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4772
#, no-wrap
msgid "__asm__(\".symver original_foo,foo@VERS_1.1\");\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4786
msgid ""
"in the C source file. This renames the function E<.Li original_foo> to be an "
"alias for E<.Li foo> bound to the version node E<.Li VERS_1.1>.  The E<.Li "
"local:> directive can be used to prevent the symbol E<.Li original_foo> from "
"being exported. A E<.Li .symver> directive takes precedence over a version "
"script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4792
msgid ""
"The second GNU extension is to allow multiple versions of the same function "
"to appear in a given shared library. In this way you can make an "
"incompatible change to an interface without increasing the major version "
"number of the shared library, while still allowing applications linked "
"against the old interface to continue to function."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4796
msgid ""
"To do this, you must use multiple E<.Li .symver> directives in the source "
"file. Here is an example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4802
#, no-wrap
msgid ""
"__asm__(\".symver original_foo,foo@\");\n"
"__asm__(\".symver old_foo,foo@VERS_1.1\");\n"
"__asm__(\".symver old_foo1,foo@VERS_1.2\");\n"
"__asm__(\".symver new_foo,foo@@VERS_2.0\");\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4815
msgid ""
"In this example, E<.Li foo@> represents the symbol E<.Li foo> bound to the "
"unspecified base version of the symbol. The source file that contains this "
"example would define 4 C functions: E<.Li original_foo>, E<.Li old_foo>, "
"E<.Li old_foo1>, and E<.Li new_foo>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4825
msgid ""
"When you have multiple definitions of a given symbol, there needs to be some "
"way to specify a default version to which external references to this symbol "
"will be bound. You can do this with the E<.Li foo@@VERS_2.0> type of E<.Li "
".symver> directive. You can only declare one version of a symbol as the "
"default in this manner; otherwise you would effectively have multiple "
"definitions of the same symbol."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4832
msgid ""
"If you wish to bind a reference to a specific version of the symbol within "
"the shared library, you can use the aliases of convenience (i.e., E<.Li "
"old_foo>), or you can use the E<.Li .symver> directive to specifically bind "
"to an external version of the function in question."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4834
msgid "You can also specify the language in the version script:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4837
#, no-wrap
msgid "VERSION extern \"lang\" { version-script-commands }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4851
msgid ""
"The supported E<.Li lang> s are E<.Li C>, E<.Li C++>, and E<.Li Java>.  The "
"linker will iterate over the list of symbols at the link time and demangle "
"them according to E<.Li lang> before matching them to the patterns specified "
"in E<.Li version-script-commands>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4860
msgid ""
"Demangled names may contains spaces and other special characters. As "
"described above, you can use a glob pattern to match demangled names, or you "
"can use a double-quoted string to match the string exactly. In the latter "
"case, be aware that minor differences (such as differing whitespace) between "
"the version script and the demangler output will cause a mismatch. As the "
"exact string generated by the demangler might change in the future, even if "
"the mangled name does not, you should check that all of your version "
"directives are behaving as you expect when you upgrade."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:4861
#, no-wrap
msgid "Expressions in Linker Scripts"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4866
msgid ""
"The syntax for expressions in the linker script language is identical to "
"that of C expressions. All expressions are evaluated as integers. All "
"expressions are evaluated in the same size, which is 32 bits if both the "
"host and target are 32 bits, and is otherwise 64 bits."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4868
msgid "You can use and set symbol values in expressions."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4870
msgid ""
"The linker defines several special purpose builtin functions for use in "
"expressions."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4872
msgid "E<.Em Constants>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4874
msgid "All constants are integers."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4882
msgid ""
"As in C, the linker considers an integer beginning with E<.Li 0> to be "
"octal, and an integer beginning with E<.Li 0x> or E<.Li 0X> to be "
"hexadecimal. The linker considers other integers to be decimal."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4892
msgid ""
"In addition, you can use the suffixes E<.Li K> and E<.Li M> to scale a "
"constant by E<.Li 1024> or E<.Li 1024*1024> respectively. For example, the "
"following all refer to the same quantity:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4896
#, no-wrap
msgid ""
"_fourk_1 = 4K;\n"
"_fourk_2 = 4096;\n"
"_fourk_3 = 0x1000;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4899
msgid "E<.Em Symbol Names>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4905
msgid ""
"Unless quoted, symbol names start with a letter, underscore, or period and "
"may include letters, digits, underscores, periods, and hyphens. Unquoted "
"symbol names must not conflict with any keywords. You can specify a symbol "
"which contains odd characters or has the same name as a keyword by "
"surrounding the symbol name in double quotes:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4908
#, no-wrap
msgid ""
"\"SECTION\" = 9;\n"
"\"with a space\" = \"also with a space\" + 10;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4916
msgid ""
"Since symbols can contain many non-alphabetic characters, it is safest to "
"delimit symbols with spaces. For example, E<.Li A-B> is one symbol, whereas "
"E<.Li A - B> is an expression involving subtraction."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4918
msgid "E<.Em Orphan Sections>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4926
msgid ""
"Orphan sections are sections present in the input files which are not "
"explicitly placed into the output file by the linker script. The linker will "
"still copy these sections into the output file, but it has to guess as to "
"where they should be placed. The linker uses a simple heuristic to do "
"this. It attempts to place orphan sections after non-orphan sections of the "
"same attribute, such as code vs data, loadable vs non-loadable, etc. If "
"there is not enough room to do this then it places at the end of the file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4929
msgid ""
"For ELF targets, the attribute of the section includes section type as well "
"as section flag."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4931
msgid "E<.Em The Location Counter>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4943
msgid ""
"The special linker variable E<.Em dot> E<.Li>.  always contains the current "
"output location counter. Since the E<.Li>.  always refers to a location in "
"an output section, it may only appear in an expression within a E<.Li "
"SECTIONS> command. The E<.Li>.  symbol may appear anywhere that an ordinary "
"symbol is allowed in an expression."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4950
msgid ""
"Assigning a value to E<.Li>.  will cause the location counter to be "
"moved. This may be used to create holes in the output section. The location "
"counter may not be moved backwards inside an output section, and may not be "
"moved backwards outside of an output section if so doing creates areas with "
"overlapping LMAs."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4963
#, no-wrap
msgid ""
"SECTIONS\n"
"{\n"
"  output :\n"
"    {\n"
"      file1(.text)\n"
"      . = . + 1000;\n"
"      file2(.text)\n"
"      . += 1000;\n"
"      file3(.text)\n"
"    } = 0x12345678;\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4982
msgid ""
"In the previous example, the E<.Li .text> section from E<.Pa file1> is "
"located at the beginning of the output section E<.Li output>.  It is "
"followed by a 1000 byte gap. Then the E<.Li .text> section from E<.Pa file2> "
"appears, also with a 1000 byte gap following before the E<.Li .text> section "
"from E<.Pa file3>.  The notation E<.Li = 0x12345678> specifies what data to "
"write in the gaps (see Section E<.Dq Output Section Fill>)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:4995
msgid ""
"Note: E<.Li>.  actually refers to the byte offset from the start of the "
"current containing object. Normally this is the E<.Li SECTIONS> statement, "
"whose start address is 0, hence E<.Li>.  can be used as an absolute "
"address. If E<.Li>.  is used inside a section description however, it refers "
"to the byte offset from the start of that section, not an absolute "
"address. Thus in a script like this:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5010
#, no-wrap
msgid ""
"SECTIONS\n"
"{\n"
"    . = 0x100\n"
"    .text: {\n"
"      *(.text)\n"
"      . = 0x200\n"
"    }\n"
"    . = 0x500\n"
"    .data: {\n"
"      *(.data)\n"
"      . += 0x600\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5028
msgid ""
"The E<.Li .text> section will be assigned a starting address of 0x100 and a "
"size of exactly 0x200 bytes, even if there is not enough data in the E<.Li "
".text> input sections to fill this area. (If there is too much data, an "
"error will be produced because this would be an attempt to move E<.Li>.  "
"backwards). The E<.Li .data> section will start at 0x500 and it will have an "
"extra 0x600 bytes worth of space after the end of the values from the E<.Li "
".data> input sections and before the end of the E<.Li .data> output section "
"itself."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5032
msgid ""
"Setting symbols to the value of the location counter outside of an output "
"section statement can result in unexpected values if the linker needs to "
"place orphan sections. For example, given the following:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5039 /usr/src/contrib/binutils/ld/ld.7:5070 /usr/src/contrib/binutils/ld/ld.7:5092
#, no-wrap
msgid ""
"SECTIONS\n"
"{\n"
"    start_of_text = . ;\n"
"    .text: { *(.text) }\n"
"    end_of_text = . ;\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5044
#, no-wrap
msgid ""
"    start_of_data = . ;\n"
"    .data: { *(.data) }\n"
"    end_of_data = . ;\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5063
msgid ""
"If the linker needs to place some input section, e.g.  E<.Li .rodata>, not "
"mentioned in the script, it might choose to place that section between E<.Li "
".text> and E<.Li .data>.  You might think the linker should place E<.Li "
".rodata> on the blank line in the above script, but blank lines are of no "
"particular significance to the linker. As well, the linker doesn't associate "
"the above symbol names with their sections. Instead, it assumes that all "
"assignments or other statements belong to the previous output section, "
"except for the special case of an assignment to E<.Li>..  I.e., the linker "
"will place the orphan E<.Li .rodata> section as if the script was written as "
"follows:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5076
#, no-wrap
msgid ""
"    start_of_data = . ;\n"
"    .rodata: { *(.rodata) }\n"
"    .data: { *(.data) }\n"
"    end_of_data = . ;\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5085
msgid ""
"This may or may not be the script author's intention for the value of E<.Li "
"start_of_data>.  One way to influence the orphan section placement is to "
"assign the location counter to itself, as the linker assumes that an "
"assignment to E<.Li>.  is setting the start address of a following output "
"section and thus should be grouped with that section. So you could write:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5098
#, no-wrap
msgid ""
"    . = . ;\n"
"    start_of_data = . ;\n"
"    .data: { *(.data) }\n"
"    end_of_data = . ;\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5106
msgid ""
"Now, the orphan E<.Li .rodata> section will be placed between E<.Li "
"end_of_text> and E<.Li start_of_data>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5108
msgid "E<.Em Operators>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5111
msgid ""
"The linker recognizes the standard C set of arithmetic operators, with the "
"standard bindings and precedence levels:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5126
#, no-wrap
msgid ""
"precedence      associativity   Operators                Notes\n"
"(highest)\n"
"1               left            !  -  ~                  (1)\n"
"2               left            *  /  %\n"
"3               left            +  -\n"
"4               left            E<gt>E<gt>  E<lt>E<lt>\n"
"5               left            ==  !=  E<gt>  E<lt>  E<lt>=  E<gt>=\n"
"6               left            &\n"
"7               left            |\n"
"8               left            &&\n"
"9               left            ||\n"
"10              right           ? :\n"
"11              right           &=  +=  -=  *=  /=       (2)\n"
"(lowest)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5129
msgid "Notes: (1) Prefix operators (2)See Section E<.Dq Assignments>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5131
msgid "E<.Em Evaluation>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5134
msgid ""
"The linker evaluates expressions lazily. It only computes the value of an "
"expression when absolutely necessary."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5139
msgid ""
"The linker needs some information, such as the value of the start address of "
"the first section, and the origins and lengths of memory regions, in order "
"to do any linking at all. These values are computed as soon as possible when "
"the linker reads in the linker script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5144
msgid ""
"However, other values (such as symbol values) are not known or needed until "
"after storage allocation. Such values are evaluated later, when other "
"information (such as the sizes of output sections) is available for use in "
"the symbol assignment expression."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5147
msgid ""
"The sizes of sections cannot be known until after allocation, so assignments "
"dependent upon these are not performed until after allocation."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5151
msgid ""
"Some expressions, such as those depending upon the location counter E<.Li>., "
"must be evaluated during section allocation."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5154
msgid ""
"If the result of an expression is required, but the value is not available, "
"then an error results. For example, a script like the following"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5161
#, no-wrap
msgid ""
"SECTIONS\n"
"  {\n"
"    .text 9+this_isnt_constant :\n"
"      { *(.text) }\n"
"  }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5165
msgid ""
"will cause the error message E<.Li non constant expression for initial "
"address>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5167
msgid "E<.Em The Section of an Expression>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5171
msgid ""
"When the linker evaluates an expression, the result is either absolute or "
"relative to some section. A relative expression is expressed as a fixed "
"offset from the base of a section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5176
msgid ""
"The position of the expression within the linker script determines whether "
"it is absolute or relative. An expression which appears within an output "
"section definition is relative to the base of the output section. An "
"expression which appears elsewhere will be absolute."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5182
msgid ""
"A symbol set to a relative expression will be relocatable if you request "
"relocatable output using the E<.Li -r> option. That means that a further "
"link operation may change the value of the symbol. The symbol's section will "
"be the section of the relative expression."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5186
msgid ""
"A symbol set to an absolute expression will retain the same value through "
"any further link operation. The symbol will be absolute, and will not have "
"any particular associated section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5193
msgid ""
"You can use the builtin function E<.Li ABSOLUTE> to force an expression to "
"be absolute when it would otherwise be relative.  For example, to create an "
"absolute symbol set to the address of the end of the output section E<.Li "
".data>:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5198
#, no-wrap
msgid ""
"SECTIONS\n"
"  {\n"
"    .data : { *(.data) _edata = ABSOLUTE(.); }\n"
"  }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5206
msgid ""
"If E<.Li ABSOLUTE> were not used, E<.Li _edata> would be relative to the "
"E<.Li .data> section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5208
msgid "E<.Em Builtin Functions>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5211
msgid ""
"The linker script language includes a number of builtin functions for use in "
"linker script expressions."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5213
#, no-wrap
msgid "ABSOLUTE( Va exp)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5220
msgid ""
"Return the absolute (non-relocatable, as opposed to non-negative) value of "
"the expression E<.Va exp>.  Primarily useful to assign an absolute value to "
"a symbol within a section definition, where symbol values are normally "
"section relative.See Section E<.Dq Expression Section>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5221
#, no-wrap
msgid "ADDR( Va section)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5230
msgid ""
"Return the absolute address (the VMA) of the named E<.Va section>.  Your "
"script must previously have defined the location of that section. In the "
"following example, E<.Li symbol_1> and E<.Li symbol_2> are assigned "
"identical values:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5244
#, no-wrap
msgid ""
"SECTIONS { ...\n"
"  .output1 :\n"
"    {\n"
"    start_of_output_1 = ABSOLUTE(.);\n"
"    ...\n"
"    }\n"
"  .output :\n"
"    {\n"
"    symbol_1 = ADDR(.output1);\n"
"    symbol_2 = start_of_output_1;\n"
"    }\n"
"\\&... }\n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5247
#, no-wrap
msgid "ALIGN( Va align)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5248
#, no-wrap
msgid "ALIGN( Va exp, Va align)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5262
msgid ""
"Return the location counter ( E<.Li>.)  or arbitrary expression aligned to "
"the next E<.Va align> boundary. The single operand E<.Li ALIGN> doesn't "
"change the value of the location counter---it just does arithmetic on "
"it. The two operand E<.Li ALIGN> allows an arbitrary expression to be "
"aligned upwards ( E<.Li ALIGN( Va align)> is equivalent to E<.Li ALIGN(., Va "
"align)>)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5271
msgid ""
"Here is an example which aligns the output E<.Li .data> section to the next "
"E<.Li 0x2000> byte boundary after the preceding section and sets a variable "
"within the section to the next E<.Li 0x8000> boundary after the input "
"sections:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5279
#, no-wrap
msgid ""
"SECTIONS { ...\n"
"  .data ALIGN(0x2000): {\n"
"    *(.data)\n"
"    variable = ALIGN(0x8000);\n"
"  }\n"
"\\&... }\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5291
msgid ""
"The first use of E<.Li ALIGN> in this example specifies the location of a "
"section because it is used as the optional E<.Va address> attribute of a "
"section definition (see Section E<.Dq Output Section Address>).  The second "
"use of E<.Li ALIGN> is used to defines the value of a symbol."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5296
msgid "The builtin function E<.Li NEXT> is closely related to E<.Li ALIGN>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5297
#, no-wrap
msgid "ALIGNOF( Va section)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5305
msgid ""
"Return the alignment in bytes of the named E<.Va section>, if that section "
"has been allocated. If the section has not been allocated when this is "
"evaluated, the linker will report an error. In the following example, the "
"alignment of the E<.Li .output> section is stored as the first value in that "
"section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5313
#, no-wrap
msgid ""
"SECTIONS{ ...\n"
"  .output {\n"
"    LONG (ALIGNOF (.output))\n"
"    ...\n"
"    }\n"
"\\&... }\n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5316
#, no-wrap
msgid "BLOCK( Va exp)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5321
msgid ""
"This is a synonym for E<.Li ALIGN>, for compatibility with older linker "
"scripts. It is most often seen when setting the address of an output "
"section."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5322
#, no-wrap
msgid "DATA_SEGMENT_ALIGN( Va maxpagesize, Va commonpagesize)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5324
msgid "This is equivalent to either"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5326
#, no-wrap
msgid "(ALIGN(maxpagesize) + (. & (maxpagesize - 1)))\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5330
#, no-wrap
msgid "(ALIGN(maxpagesize) + (. & (maxpagesize - commonpagesize)))\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5341
msgid ""
"depending on whether the latter uses fewer E<.Va commonpagesize> sized pages "
"for the data segment (area between the result of this expression and E<.Li "
"DATA_SEGMENT_END>)  than the former or not. If the latter form is used, it "
"means E<.Va commonpagesize> bytes of runtime memory will be saved at the "
"expense of up to E<.Va commonpagesize> wasted bytes in the on-disk file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5352
msgid ""
"This expression can only be used directly in E<.Li SECTIONS> commands, not "
"in any output section descriptions and only once in the linker script.  "
"E<.Va commonpagesize> should be less or equal to E<.Va maxpagesize> and "
"should be the system page size the object wants to be optimized for (while "
"still working on system page sizes up to E<.Va maxpagesize>)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5354
msgid "Example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5356
#, no-wrap
msgid "  . = DATA_SEGMENT_ALIGN(0x10000, 0x2000);\n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5358
#, no-wrap
msgid "DATA_SEGMENT_END( Va exp)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5362
msgid ""
"This defines the end of data segment for E<.Li DATA_SEGMENT_ALIGN> "
"evaluation purposes."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5365
#, no-wrap
msgid "  . = DATA_SEGMENT_END(.);\n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5367
#, no-wrap
msgid "DATA_SEGMENT_RELRO_END( Va offset, Va exp)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5387
msgid ""
"This defines the end of the E<.Li PT_GNU_RELRO> segment when E<.Li -z relro> "
"option is used. Second argument is returned. When E<.Li -z relro> option is "
"not present, E<.Li DATA_SEGMENT_RELRO_END> does nothing, otherwise E<.Li "
"DATA_SEGMENT_ALIGN> is padded so that E<.Va exp> + E<.Va offset> is aligned "
"to the most commonly used page boundary for particular target.  If present "
"in the linker script, it must always come in between E<.Li "
"DATA_SEGMENT_ALIGN> and E<.Li DATA_SEGMENT_END>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5390
#, no-wrap
msgid "  . = DATA_SEGMENT_RELRO_END(24, .);\n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5392
#, no-wrap
msgid "DEFINED( Va symbol)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5405
msgid ""
"Return 1 if E<.Va symbol> is in the linker global symbol table and is "
"defined before the statement using DEFINED in the script, otherwise return "
"0. You can use this function to provide default values for symbols. For "
"example, the following script fragment shows how to set a global symbol "
"E<.Li begin> to the first location in the E<.Li .text> section---but if a "
"symbol called E<.Li begin> already existed, its value is preserved:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5415
#, no-wrap
msgid ""
"SECTIONS { ...\n"
"  .text : {\n"
"    begin = DEFINED(begin) ? begin : . ;\n"
"    ...\n"
"  }\n"
"  ...\n"
"}\n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5418
#, no-wrap
msgid "LENGTH( Va memory)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5421
msgid "Return the length of the memory region named E<.Va memory>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5422
#, no-wrap
msgid "LOADADDR( Va section)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5431
msgid ""
"Return the absolute LMA of the named E<.Va section>.  This is normally the "
"same as E<.Li ADDR>, but it may be different if the E<.Li AT> attribute is "
"used in the output section definition (see Section E<.Dq Output Section "
"LMA>)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5432
#, no-wrap
msgid "MAX( Va exp1, Va exp2)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5437
msgid "Returns the maximum of E<.Va exp1> and E<.Va exp2>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5438
#, no-wrap
msgid "MIN( Va exp1, Va exp2)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5443
msgid "Returns the minimum of E<.Va exp1> and E<.Va exp2>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5444
#, no-wrap
msgid "NEXT( Va exp)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5453
msgid ""
"Return the next unallocated address that is a multiple of E<.Va exp>.  This "
"function is closely related to E<.Li ALIGN( Va exp)>; unless you use the "
"E<.Li MEMORY> command to define discontinuous memory for the output file, "
"the two functions are equivalent."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5454
#, no-wrap
msgid "ORIGIN( Va memory)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5457
msgid "Return the origin of the memory region named E<.Va memory>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5458
#, no-wrap
msgid "SEGMENT_START( Va segment, Va default)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5471
msgid ""
"Return the base address of the named E<.Va segment>.  If an explicit value "
"has been given for this segment (with a command-line E<.Li -T> option) that "
"value will be returned; otherwise the value will be E<.Va default>.  At "
"present, the E<.Li -T> command-line option can only be used to set the base "
"address for the \\(lqtext\\(rq, \\(lqdata\\(rq, and \\(lqbss\\(rq sections, "
"but you use E<.Li SEGMENT_START> with any segment name."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5472
#, no-wrap
msgid "SIZEOF( Va section)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5482
msgid ""
"Return the size in bytes of the named E<.Va section>, if that section has "
"been allocated. If the section has not been allocated when this is "
"evaluated, the linker will report an error. In the following example, E<.Li "
"symbol_1> and E<.Li symbol_2> are assigned identical values:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5493
#, no-wrap
msgid ""
"SECTIONS{ ...\n"
"  .output {\n"
"    .start = . ;\n"
"    ...\n"
"    .end = . ;\n"
"    }\n"
"  symbol_1 = .end - .start ;\n"
"  symbol_2 = SIZEOF(.output);\n"
"\\&... }\n"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5496
#, no-wrap
msgid "SIZEOF_HEADERS"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5497
#, no-wrap
msgid "sizeof_headers"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5502
msgid ""
"Return the size in bytes of the output file's headers. This is information "
"which appears at the start of the output file. You can use this number when "
"setting the start address of the first section, if you choose, to facilitate "
"paging."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5517
msgid ""
"When producing an ELF output file, if the linker script uses the E<.Li "
"SIZEOF_HEADERS> builtin function, the linker must compute the number of "
"program headers before it has determined all the section addresses and "
"sizes. If the linker later discovers that it needs additional program "
"headers, it will report an error E<.Li not enough room for program "
"headers>.  To avoid this error, you must avoid using the E<.Li "
"SIZEOF_HEADERS> function, or you must rework your linker script to avoid "
"forcing the linker to use additional program headers, or you must define the "
"program headers yourself using the E<.Li PHDRS> command (see Section E<.Dq "
"PHDRS>)."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5519
#, no-wrap
msgid "Implicit Linker Scripts"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5524
msgid ""
"If you specify a linker input file which the linker can not recognize as an "
"object file or an archive file, it will try to read the file as a linker "
"script.  If the file can not be parsed as a linker script, the linker will "
"report an error."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5526
msgid "An implicit linker script will not replace the default linker script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5534
msgid ""
"Typically an implicit linker script would contain only symbol assignments, "
"or the E<.Li INPUT>, E<.Li GROUP>, or E<.Li VERSION> commands."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5538
msgid ""
"Any input files read because of an implicit linker script will be read at "
"the position in the command line where the implicit linker script was read.  "
"This can affect archive searching."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:5539
#, no-wrap
msgid "Machine Dependent Features"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5545
msgid ""
"E<.Xr ld> has additional features on some platforms; the following sections "
"describe them. Machines where E<.Xr ld> has no additional functionality are "
"not listed."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5546
#, no-wrap
msgid "Xr ld and the H8/300"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5552
msgid ""
"For the H8/300, E<.Xr ld> can perform these global optimizations when you "
"specify the E<.Li --relax> command-line option."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5554 /usr/src/contrib/binutils/ld/ld.7:5687
#, no-wrap
msgid "relaxing address modes"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5566 /usr/src/contrib/binutils/ld/ld.7:5699
msgid ""
"E<.Xr ld> finds all E<.Li jsr> and E<.Li jmp> instructions whose targets are "
"within eight bits, and turns them into eight-bit program-counter relative "
"E<.Li bsr> and E<.Li bra> instructions, respectively."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5567
#, no-wrap
msgid "synthesizing instructions"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5580
msgid ""
"E<.Xr ld> finds all E<.Li mov.b> instructions which use the sixteen-bit "
"absolute address form, but refer to the top page of memory, and changes them "
"to use the eight-bit address form.  (That is: the linker turns E<.Li mov.b "
"Li @ Va aa:16> into E<.Li mov.b Li @ Va aa:8> whenever the address E<.Va aa> "
"is in the top page of memory)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5581
#, no-wrap
msgid "bit manipulation instructions"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5594
msgid ""
"E<.Xr ld> finds all bit manipulation instructions like E<.Li band, bclr, "
"biand, bild, bior, bist, bixor, bld, bnot, bor, bset, bst, btst, bxor> which "
"use 32 bit and 16 bit absolute address form, but refer to the top page of "
"memory, and changes them to use the 8 bit address form. (That is: the linker "
"turns E<.Li bset #xx:3, Li @ Va aa:32> into E<.Li bset #xx:3, Li @ Va aa:8> "
"whenever the address E<.Va aa> is in the top page of memory)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5595
#, no-wrap
msgid "system control instructions"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5608
msgid ""
"E<.Xr ld> finds all E<.Li ldc.w, stc.w> instructions which use the 32 bit "
"absolute address form, but refer to the top page of memory, and changes them "
"to use 16 bit address form. (That is: the linker turns E<.Li ldc.w Li @ Va "
"aa:32,ccr> into E<.Li ldc.w Li @ Va aa:16,ccr> whenever the address E<.Va "
"aa> is in the top page of memory)."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5610
#, no-wrap
msgid "Xr ld and the Intel 960 Family"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5619
msgid ""
"You can use the E<.Li -A Va architecture> command line option to specify one "
"of the two-letter names identifying members of the 960 family; the option "
"specifies the desired output target, and warns of any incompatible "
"instructions in the input files. It also modifies the linker's search "
"strategy for archive libraries, to support the use of libraries specific to "
"each particular architecture, by including in the search loop names suffixed "
"with the string identifying the architecture."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5630
msgid ""
"For example, if your E<.Xr ld> command line included E<.Li -ACA> as well as "
"E<.Li -ltry> , the linker would look (in its built-in search paths, and in "
"any paths you specify with E<.Li -L>)  for a library with the names"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5637
#, no-wrap
msgid ""
"try\n"
"libtry.a\n"
"tryca\n"
"libtryca.a\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5644
msgid ""
"The first two possibilities would be considered in any event; the last two "
"are due to the use of E<.Li -ACA> \\&."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5652
msgid ""
"You can meaningfully use E<.Li -A> more than once on a command line, since "
"the 960 architecture family allows combination of target architectures; each "
"use will add another pair of name variants to search for when E<.Li -l> "
"specifies a library."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5676
msgid ""
"E<.Xr ld> supports the E<.Li --relax> option for the i960 family. If you "
"specify E<.Li --relax>, E<.Xr ld> finds all E<.Li balx> and E<.Li calx> "
"instructions whose targets are within 24 bits, and turns them into 24-bit "
"program-counter relative E<.Li bal> and E<.Li cal> instructions, "
"respectively.  E<.Xr ld> also turns E<.Li cal> instructions into E<.Li bal> "
"instructions when it determines that the target subroutine is a leaf routine "
"(that is, the target subroutine does not itself call any subroutines)."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5677
#, no-wrap
msgid "Xr ld and the Motorola 68HC11 and 68HC12 families"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5679
msgid "E<.Em Linker Relaxation>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5685
msgid ""
"For the Motorola 68HC11, E<.Xr ld> can perform these global optimizations "
"when you specify the E<.Li --relax> command-line option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5703
msgid ""
"E<.Xr ld> also looks at all 16-bit extended addressing modes and transforms "
"them in a direct addressing mode when the address is in page 0 (between 0 "
"and 0x0ff)."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5704
#, no-wrap
msgid "relaxing gcc instruction group"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5715
msgid ""
"When E<.Xr gcc> is called with E<.Op -mrelax>, it can emit group of "
"instructions that the linker can optimize to use a 68HC11 direct addressing "
"mode. These instructions consists of E<.Li bclr> or E<.Li bset> "
"instructions."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5718
msgid "E<.Em Trampoline Generation>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5727
msgid ""
"For 68HC11 and 68HC12, E<.Xr ld> can generate trampoline code to call a far "
"function using a normal E<.Li jsr> instruction. The linker will also change "
"the relocation to some far function to use the trampoline address instead of "
"the function address. This is typically the case when a pointer to a "
"function is taken. The pointer will in fact point to the function "
"trampoline."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5735
msgid ""
"The E<.Li --pic-veneer> switch makes the linker use PIC sequences for "
"ARM/Thumb interworking veneers, even if the rest of the binary is not "
"PIC. This avoids problems on uClinux targets where E<.Li --emit-relocs> is "
"used to generate relocatable binaries."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5736
#, no-wrap
msgid "Xr ld and the ARM family"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5751
msgid ""
"For the ARM, E<.Xr ld> will generate code stubs to allow functions calls "
"between ARM and Thumb code.  These stubs only work with code that has been "
"compiled and assembled with the E<.Li -mthumb-interwork> command line "
"option. If it is necessary to link with old ARM object files or libraries, "
"which have not been compiled with the -mthumb-interwork option then the "
"E<.Li --support-old-code> command line switch should be given to the "
"linker. This will make it generate larger stub functions which will work "
"with non-interworking aware ARM code.  Note, however, the linker does not "
"support generating stubs for function calls to non-interworking aware Thumb "
"code."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5759
msgid ""
"The E<.Li --thumb-entry> switch is a duplicate of the generic E<.Li --entry> "
"switch, in that it sets the program's starting address. But it also sets the "
"bottom bit of the address, so that it can be branched to using a BX "
"instruction, and the program will start executing in Thumb mode straight "
"away."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5767
msgid ""
"The E<.Li --be8> switch instructs E<.Xr ld> to generate BE8 format "
"executables. This option is only valid when linking big-endian objects. The "
"resulting image will contain big-endian data and little-endian code."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5781
msgid ""
"The E<.Li R_ARM_TARGET1> relocation is typically used for entries in the "
"E<.Li .init_array> section. It is interpreted as either E<.Li R_ARM_REL32> "
"or E<.Li R_ARM_ABS32>, depending on the target. The E<.Li --target1-rel> and "
"E<.Li --target1-abs> switches override the default."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5789
msgid ""
"The E<.Li --target2=type> switch overrides the default definition of the "
"E<.Li R_ARM_TARGET2> relocation. Valid values for E<.Li type>, their "
"meanings, and target defaults are as follows:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5790
#, no-wrap
msgid "rel"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5793
msgid "E<.Li R_ARM_REL32> (arm*-*-elf, arm*-*-eabi)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5793
#, no-wrap
msgid "abs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5796
msgid "E<.Li R_ARM_ABS32> (arm*-*-symbianelf)"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5796
#, no-wrap
msgid "got-rel"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5799
msgid "E<.Li R_ARM_GOT_PREL> (arm*-*-linux, arm*-*-*bsd)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5807
msgid ""
"The E<.Li R_ARM_V4BX> relocation (defined by the ARM AAELF specification) "
"enables objects compiled for the ARMv4 architecture to be interworking-safe "
"when linked with other objects compiled for ARMv4t, but also allows pure "
"ARMv4 binaries to be built from the same ARMv4 objects."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5817
msgid ""
"In the latter case, the switch E<.Op --fix-v4bx> must be passed to the "
"linker, which causes v4t E<.Li BX rM> instructions to be rewritten as E<.Li "
"MOV PC,rM>, since v4 processors do not have a E<.Li BX> instruction."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5821
msgid ""
"In the former case, the switch should not be used, and E<.Li R_ARM_V4BX> "
"relocations are ignored."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5829
msgid ""
"The E<.Li --use-blx> switch enables the linker to use ARM/Thumb BLX "
"instructions (available on ARMv5t and above) in various "
"situations. Currently it is used to perform calls via the PLT from Thumb "
"code using BLX rather than using BX and a mode-switching stub before each "
"PLT entry. This should lead to such calls executing slightly faster."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5832
msgid ""
"This option is enabled implicitly for SymbianOS, so there is no need to "
"specify it if you are using that target."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5839
msgid ""
"The E<.Li --vfp11-denorm-fix> switch enables a link-time workaround for a "
"bug in certain VFP11 coprocessor hardware, which sometimes allows "
"instructions with denorm operands (which must be handled by support code) to "
"have those operands overwritten by subsequent instructions before the "
"support code can read the intended values."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5846
msgid ""
"The bug may be avoided in scalar mode if you allow at least one intervening "
"instruction between a VFP11 instruction which uses a register and another "
"instruction which writes to the same register, or at least two intervening "
"instructions if vector mode is in use. The bug only affects full-compliance "
"floating-point mode: you do not need this workaround if you are using "
"\"runfast\" mode. Please contact ARM for further details."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5855
msgid ""
"If you know you are using buggy VFP11 hardware, you can enable this "
"workaround by specifying the linker option E<.Li --vfp-denorm-fix=scalar> if "
"you are using the VFP11 scalar mode only, or E<.Li --vfp-denorm-fix=vector> "
"if you are using vector mode (the latter also works for scalar code). The "
"default is E<.Li --vfp-denorm-fix=none>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5863
msgid ""
"If the workaround is enabled, instructions are scanned for "
"potentially-troublesome sequences, and a veneer is created for each such "
"sequence which may trigger the erratum. The veneer consists of the first "
"instruction of the sequence and a branch back to the subsequent "
"instruction. The original instruction is then replaced with a branch to the "
"veneer. The extra cycles required to call and return from the veneer are "
"sufficient to avoid the erratum in both the scalar and vector cases."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5871
msgid ""
"The E<.Li --no-enum-size-warning> switch prevents the linker from warning "
"when linking object files that specify incompatible EABI enumeration size "
"attributes. For example, with this switch enabled, linking of an object file "
"using 32-bit enumeration values with another using enumeration values fitted "
"into the smallest possible space will not be diagnosed."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5872
#, no-wrap
msgid "Xr ld and HPPA 32-bit ELF Support"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5882
msgid ""
"When generating a shared library, E<.Xr ld> will by default generate import "
"stubs suitable for use with a single sub-space application. The E<.Li "
"--multi-subspace> switch causes E<.Xr ld> to generate export stubs, and "
"different (larger) import stubs suitable for use with multiple sub-spaces."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5908
msgid ""
"Long branch stubs and import/export stubs are placed by E<.Xr ld> in stub "
"sections located between groups of input sections.  E<.Li --stub-group-size> "
"specifies the maximum size of a group of input sections handled by one stub "
"section. Since branch offsets are signed, a stub section may serve two "
"groups of input sections, one group before the stub section, and one group "
"after it. However, when using conditional branches that require stubs, it "
"may be better (for branch prediction) that stub sections only serve one "
"group of input sections. A negative value for E<.Li N> chooses this scheme, "
"ensuring that branches to stubs always use a negative offset. Two special "
"values of E<.Li N> are recognized, E<.Li 1> and E<.Li -1>.  These both "
"instruct E<.Xr ld> to automatically size input section groups for the branch "
"types detected, with the same behaviour regarding stub placement as other "
"positive or negative values of E<.Li N> respectively."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5914 /usr/src/contrib/binutils/ld/ld.7:6095
msgid ""
"Note that E<.Li --stub-group-size> does not split input sections. A single "
"input section larger than the group size specified will of course create a "
"larger group (of one section). If input sections are too large, it may not "
"be possible for a branch to reach its stub."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5915
#, no-wrap
msgid "Li ld and MMIX"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5927
msgid ""
"For MMIX, there is a choice of generating E<.Li ELF> object files or E<.Li "
"mmo> object files when linking. The simulator E<.Li mmix> understands the "
"E<.Li mmo> format. The binutils E<.Li objcopy> utility can translate between "
"the two formats."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5943
msgid ""
"There is one special section, the E<.Li .MMIX.reg_contents> "
"section. Contents in this section is assumed to correspond to that of global "
"registers, and symbols referring to it are translated to special symbols, "
"equal to registers. In a final link, the start address of the E<.Li "
".MMIX.reg_contents> section corresponds to the first allocated global "
"register multiplied by 8.  Register E<.Li $255> is not included in this "
"section; it is always set to the program entry, which is at the symbol E<.Li "
"Main> for E<.Li mmo> files."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5952
msgid ""
"Symbols with the prefix E<.Li __.MMIX.start.>, for example E<.Li "
"__.MMIX.start..text> and E<.Li __.MMIX.start..data> are special; there must "
"be only one each, even if they are local. The default linker script uses "
"these to set the default start address of a section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5955
msgid ""
"Initial and trailing multiples of zero-valued 32-bit words in a section, are "
"left out from an mmo file."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5956
#, no-wrap
msgid "Li ld and MSP430"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5963
msgid ""
"For the MSP430 it is possible to select the MPU architecture. The flag E<.Li "
"-m [mpu type]> will select an appropriate linker script for selected MPU "
"type. (To get a list of known MPUs just pass E<.Li -m help> option to the "
"linker)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5965
msgid "The linker will recognize some extra sections which are MSP430 specific:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5967
#, no-wrap
msgid "Li .vectors"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5969
msgid "Defines a portion of ROM where interrupt vectors located."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5970
#, no-wrap
msgid "Li .bootloader"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5973
msgid ""
"Defines the bootloader portion of the ROM (if applicable). Any code in this "
"section will be uploaded to the MPU."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5974
#, no-wrap
msgid "Li .infomem"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5977
msgid ""
"Defines an information memory section (if applicable). Any code in this "
"section will be uploaded to the MPU."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5978
#, no-wrap
msgid "Li .infomemnobits"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5982
msgid ""
"This is the same as the E<.Li .infomem> section except that any code in this "
"section will not be uploaded to the MPU."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:5983
#, no-wrap
msgid "Li .noinit"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5987
msgid "Denotes a portion of RAM located above E<.Li .bss> section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:5989
msgid "The last two sections are used by gcc."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:5991
#, no-wrap
msgid "Xr ld and PowerPC 32-bit ELF Support"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6002
msgid ""
"Branches on PowerPC processors are limited to a signed 26-bit displacement, "
"which may result in E<.Xr ld> giving E<.Li relocation truncated to fit> "
"errors with very large programs.  E<.Li --relax> enables the generation of "
"trampolines that can access the entire 32-bit address space. These "
"trampolines are inserted at section boundaries, so may not themselves be "
"reachable if an input section exceeds 33M in size."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6004
#, no-wrap
msgid "--bss-plt"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6016
msgid ""
"Current PowerPC GCC accepts a E<.Li -msecure-plt> option that generates code "
"capable of using a newer PLT and GOT layout that has the security advantage "
"of no executable section ever needing to be writable and no writable section "
"ever being executable. PowerPC E<.Xr ld> will generate this layout, "
"including stubs to access the PLT, if all input files (including startup and "
"static libraries) were compiled with E<.Li -msecure-plt>.  E<.Li --bss-plt> "
"forces the old BSS PLT (and GOT layout) which can give slightly better "
"performance."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6017
#, no-wrap
msgid "--secure-plt"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6026
msgid ""
"E<.Xr ld> will use the new PLT and GOT layout if it is linking new E<.Li "
"-fpic> or E<.Li -fPIC> code, but does not do so automatically when linking "
"non-PIC code. This option requests the new PLT and GOT layout. A warning "
"will be given if some object file requires the old style BSS PLT."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6027
#, no-wrap
msgid "--sdata-got"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6048
msgid ""
"The new secure PLT and GOT are placed differently relative to other sections "
"compared to older BSS PLT and GOT placement. The location of E<.Li .plt> "
"must change because the new secure PLT is an initialized section while the "
"old PLT is uninitialized. The reason for the E<.Li .got> change is more "
"subtle: The new placement allows E<.Li .got> to be read-only in applications "
"linked with E<.Li -z relro -z now>.  However, this placement means that "
"E<.Li .sdata> cannot always be used in shared libraries, because the PowerPC "
"ABI accesses E<.Li .sdata> in shared libraries from the GOT pointer.  E<.Li "
"--sdata-got> forces the old GOT placement. PowerPC GCC doesn't use E<.Li "
".sdata> in shared libraries, so this option is really only useful for other "
"compilers that may do so."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6049 /usr/src/contrib/binutils/ld/ld.7:6096 /usr/src/contrib/binutils/ld/ld.7:6193
#, no-wrap
msgid "--emit-stub-syms"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6053 /usr/src/contrib/binutils/ld/ld.7:6100
msgid ""
"This option causes E<.Xr ld> to label linker stubs with a local symbol that "
"encodes the stub type and destination."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6054 /usr/src/contrib/binutils/ld/ld.7:6120
#, no-wrap
msgid "--no-tls-optimize"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6059
msgid ""
"PowerPC E<.Xr ld> normally performs some optimization of code sequences used "
"to access Thread-Local Storage. Use this option to disable the optimization."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:6061
#, no-wrap
msgid "Xr ld and PowerPC64 64-bit ELF Support"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6063
#, no-wrap
msgid "--stub-group-size"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6089
msgid ""
"Long branch stubs, PLT call stubs and TOC adjusting stubs are placed by "
"E<.Xr ld> in stub sections located between groups of input sections.  E<.Li "
"--stub-group-size> specifies the maximum size of a group of input sections "
"handled by one stub section. Since branch offsets are signed, a stub section "
"may serve two groups of input sections, one group before the stub section, "
"and one group after it. However, when using conditional branches that "
"require stubs, it may be better (for branch prediction) that stub sections "
"only serve one group of input sections. A negative value for E<.Li N> "
"chooses this scheme, ensuring that branches to stubs always use a negative "
"offset. Two special values of E<.Li N> are recognized, E<.Li 1> and E<.Li "
"-1>.  These both instruct E<.Xr ld> to automatically size input section "
"groups for the branch types detected, with the same behaviour regarding stub "
"placement as other positive or negative values of E<.Li N> respectively."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6101
#, no-wrap
msgid "--dotsyms, --no-dotsyms"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6119
msgid ""
"These two options control how E<.Xr ld> interprets version patterns in a "
"version script. Older PowerPC64 compilers emitted both a function descriptor "
"symbol with the same name as the function, and a code entry symbol with the "
"name prefixed by a dot ( E<.Li>.).  To properly version a function E<.Li "
"foo>, the version script thus needs to control both E<.Li foo> and E<.Li "
".foo>.  The option E<.Li --dotsyms>, on by default, automatically adds the "
"required dot-prefixed patterns. Use E<.Li --no-dotsyms> to disable this "
"feature."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6125
msgid ""
"PowerPC64 E<.Xr ld> normally performs some optimization of code sequences "
"used to access Thread-Local Storage. Use this option to disable the "
"optimization."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6126
#, no-wrap
msgid "--no-opd-optimize"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6139
msgid ""
"PowerPC64 E<.Xr ld> normally removes E<.Li .opd> section entries "
"corresponding to deleted link-once functions, or functions removed by the "
"action of E<.Li --gc-sections> or linker scrip E<.Li /DISCARD/>.  Use this "
"option to disable E<.Li .opd> optimization."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6140
#, no-wrap
msgid "--non-overlapping-opd"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6146
msgid ""
"Some PowerPC64 compilers have an option to generate compressed E<.Li .opd> "
"entries spaced 16 bytes apart, overlapping the third word, the static chain "
"pointer (unused in C) with the first word of the next entry. This option "
"expands such entries to the full 24 bytes."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6147
#, no-wrap
msgid "--no-toc-optimize"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6161
msgid ""
"PowerPC64 E<.Xr ld> normally removes unused E<.Li .toc> section "
"entries. Such entries are detected by examining relocations that reference "
"the TOC in code sections. A reloc in a deleted code section marks a TOC word "
"as unneeded, while a reloc in a kept code section marks a TOC word as "
"needed.  Since the TOC may reference itself, TOC relocs are also "
"examined. TOC words marked as both needed and unneeded will of course be "
"kept. TOC words without any referencing reloc are assumed to be part of a "
"multi-word entry, and are kept or discarded as per the nearest marked "
"preceding word. This works reliably for compiler generated code, but may be "
"incorrect if assembly code is used to insert TOC entries. Use this option to "
"disable the optimization."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6162
#, no-wrap
msgid "--no-multi-toc"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6177
msgid ""
"By default, PowerPC64 GCC generates code for a TOC model where TOC entries "
"are accessed with a 16-bit offset from r2. This limits the total TOC size to "
"64K. PowerPC64 E<.Xr ld> extends this limit by grouping code sections such "
"that each group uses less than 64K for its TOC entries, then inserts r2 "
"adjusting stubs between inter-group calls.  E<.Xr ld> does not split apart "
"input sections, so cannot help if a single input file has a E<.Li .toc> "
"section that exceeds 64K, most likely from linking multiple files with E<.Xr "
"ld -r>.  Use this option to turn off this feature."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:6179
#, no-wrap
msgid "Xr ld and SPU ELF Support"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6181
#, no-wrap
msgid "--plugin"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6183
msgid "This option marks an executable as a PIC plugin module."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6184
#, no-wrap
msgid "--no-overlays"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6192
msgid ""
"Normally, E<.Xr ld> recognizes calls to functions within overlay regions, "
"and redirects such calls to an overlay manager via a stub.  E<.Xr ld> also "
"provides a built-in overlay manager. This option turns off all this special "
"overlay handling."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6198
msgid ""
"This option causes E<.Xr ld> to label overlay stubs with a local symbol that "
"encodes the stub type and destination."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6199
#, no-wrap
msgid "--extra-overlay-stubs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6204
msgid ""
"This option causes E<.Xr ld> to add overlay call stubs on all function calls "
"out of overlay regions. Normally stubs are not added on calls to non-overlay "
"regions."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6205
#, no-wrap
msgid "--local-store=lo:hi"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6211
msgid ""
"E<.Xr ld> usually checks that a final executable for SPU fits in the address "
"range 0 to 256k. This option may be used to change the range. Disable the "
"check entirely with E<.Op --local-store=0:0>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6212
#, no-wrap
msgid "--stack-analysis"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6228
msgid ""
"SPU local store space is limited. Over-allocation of stack space "
"unnecessarily limits space available for code and data, while "
"under-allocation results in runtime failures. If given this option, E<.Xr "
"ld> will provide an estimate of maximum stack usage.  E<.Xr ld> does this by "
"examining symbols in code sections to determine the extents of functions, "
"and looking at function prologues for stack adjusting instructions.  A "
"call-graph is created by looking for relocations on branch instructions.  "
"The graph is then searched for the maximum stack usage path. Note that this "
"analysis does not find calls made via function pointers, and does not handle "
"recursion and other cycles in the call graph. Stack usage may be "
"under-estimated if your code makes such calls. Also, stack usage for dynamic "
"allocation, e.g.  alloca, will not be detected. If a link map is requested, "
"detailed information about each function's stack usage and calls will be "
"given."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6229
#, no-wrap
msgid "--emit-stack-syms"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6247
msgid ""
"This option, if given along with E<.Op --stack-analysis> will result in "
"E<.Xr ld> emitting stack sizing symbols for each function. These take the "
"form E<.Li __stack_E<lt>function_nameE<gt>> for global functions, and E<.Li "
"__stack_E<lt>numberE<gt>_E<lt>function_nameE<gt>> for static functions.  "
"E<.Li E<lt>numberE<gt>> is the section id in hex. The value of such symbols "
"is the stack requirement for the corresponding function. The symbol size "
"will be zero, type E<.Li STT_NOTYPE>, binding E<.Li STB_LOCAL>, and section "
"E<.Li SHN_ABS>."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:6249
#, no-wrap
msgid "Xr ld's Support for Various TI COFF Versions"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6258
msgid ""
"The E<.Li --format> switch allows selection of one of the various TI COFF "
"versions. The latest of this writing is 2; versions 0 and 1 are also "
"supported. The TI COFF versions also vary in header byte-order format; E<.Xr "
"ld> will read any version or byte order, but the output header format "
"depends on the default specified by the specific target."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:6259
#, no-wrap
msgid "Xr ld and WIN32 (cygwin/mingw)"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6264
msgid ""
"This section describes some of the win32 specific E<.Xr ld> issues. See "
"Options,,Command Line Options for detailed description of the command line "
"options mentioned here."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6266
#, no-wrap
msgid "import libraries"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6274
msgid ""
"The standard Windows linker creates and uses so-called import libraries, "
"which contains information for linking to dll's. They are regular static "
"archives and are handled as any other static archive. The cygwin and mingw "
"ports of E<.Xr ld> have specific support for creating such libraries "
"provided with the E<.Li --out-implib> command line option."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6275
#, no-wrap
msgid "exporting DLL symbols"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6279
msgid "The cygwin/mingw E<.Xr ld> has several ways to export symbols for dll's."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6281
#, no-wrap
msgid "using auto-export functionality"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6286
msgid ""
"By default E<.Xr ld> exports symbols with the auto-export functionality, "
"which is controlled by the following command line options:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6290
msgid "--export-all-symbols [This is the default]"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6292
msgid "--exclude-symbols"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6294
msgid "--exclude-libs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6302
msgid ""
"If, however, E<.Li --export-all-symbols> is not given explicitly on the "
"command line, then the default auto-export behavior will be E<.Em disabled> "
"if either of the following are true:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6306
msgid "A DEF file is used."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6308
msgid ""
"Any symbol in any object file was marked with the __declspec(dllexport) "
"attribute."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6310
#, no-wrap
msgid "using a DEF file"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6320
msgid ""
"Another way of exporting symbols is using a DEF file. A DEF file is an ASCII "
"file containing definitions of symbols which should be exported when a dll "
"is created. Usually it is named E<.Li E<lt>dll nameE<gt>.def> and is added "
"as any other object file to the linker's command line. The file's name must "
"end in E<.Li .def> or E<.Li .DEF>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6323
#, no-wrap
msgid "gcc -o E<lt>outputE<gt> E<lt>objectfilesE<gt> E<lt>dll nameE<gt>.def\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6328
msgid ""
"Using a DEF file turns off the normal auto-export behavior, unless the E<.Li "
"--export-all-symbols> option is also used."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6331
msgid "Here is an example of a DEF file for a shared library called E<.Li xyz.dll>:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6334
#, no-wrap
msgid "LIBRARY \"xyz.dll\" BASE=0x20000000\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6341
#, no-wrap
msgid ""
"EXPORTS\n"
"foo\n"
"bar\n"
"_bar = bar\n"
"another_foo = abc.dll.afoo\n"
"var1 DATA\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6356
msgid ""
"This example defines a DLL with a non-default base address and five symbols "
"in the export table. The third exported symbol E<.Li _bar> is an alias for "
"the second. The fourth symbol, E<.Li another_foo> is resolved by "
"\"forwarding\" to another module and treating it as an alias for E<.Li afoo> "
"exported from the DLL E<.Li abc.dll>.  The final symbol E<.Li var1> is "
"declared to be a data object."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6366
msgid ""
"The optional E<.Li LIBRARY E<lt>nameE<gt>> command indicates the E<.Em "
"internal> name of the output DLL. If E<.Li E<lt>nameE<gt>> does not include "
"a suffix, the default library suffix, E<.Li .DLL> is appended."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6377
msgid ""
"When the .DEF file is used to build an application, rather than a library, "
"the E<.Li NAME E<lt>nameE<gt>> command should be used instead of E<.Li "
"LIBRARY>.  If E<.Li E<lt>nameE<gt>> does not include a suffix, the default "
"executable suffix, E<.Li .EXE> is appended."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6385
msgid ""
"With either E<.Li LIBRARY E<lt>nameE<gt>> or E<.Li NAME E<lt>nameE<gt>> the "
"optional specification E<.Li BASE = E<lt>numberE<gt>> may be used to specify "
"a non-default base address for the image."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6392
msgid ""
"If neither E<.Li LIBRARY E<lt>nameE<gt>> nor E<.Li NAME E<lt>nameE<gt>> is "
"specified, or they specify an empty string, the internal name is the same as "
"the filename specified on the command line."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6394
msgid "The complete specification of an export symbol is:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6400
#, no-wrap
msgid ""
"EXPORTS\n"
"  ( (  ( E<lt>name1E<gt> [ = E<lt>name2E<gt> ] )\n"
"     | ( E<lt>name1E<gt> = E<lt>module-nameE<gt> "
". E<lt>external-nameE<gt>))\n"
"  [ @ E<lt>integerE<gt> ] [NONAME] [DATA] [CONSTANT] [PRIVATE] ) *\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6417
msgid ""
"Declares E<.Li E<lt>name1E<gt>> as an exported symbol from the DLL, or "
"declares E<.Li E<lt>name1E<gt>> as an exported alias for E<.Li "
"E<lt>name2E<gt>>; or declares E<.Li E<lt>name1E<gt>> as a \"forward\" alias "
"for the symbol E<.Li E<lt>external-nameE<gt>> in the DLL E<.Li "
"E<lt>module-nameE<gt>>.  Optionally, the symbol may be exported by the "
"specified ordinal E<.Li E<lt>integerE<gt>> alias."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6419
msgid "The optional keywords that follow the declaration indicate:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6427
msgid ""
"E<.Li NONAME>: Do not put the symbol name in the DLL's export table. It will "
"still be exported by its ordinal alias (either the value specified by the "
".def specification or, otherwise, the value assigned by the linker). The "
"symbol name, however, does remain visible in the import library (if any), "
"unless E<.Li PRIVATE> is also specified."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6438
msgid ""
"E<.Li DATA>: The symbol is a variable or object, rather than a function. The "
"import lib will export only an indirect reference to E<.Li foo> as the "
"symbol E<.Li _imp__foo> (ie, E<.Li foo> must be resolved as E<.Li "
"*_imp__foo>)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6452
msgid ""
"E<.Li CONSTANT>: Like E<.Li DATA>, but put the undecorated E<.Li foo> as "
"well as E<.Li _imp__foo> into the import library. Both refer to the "
"read-only import address table's pointer to the variable, not to the "
"variable itself. This can be dangerous.  If the user code fails to add the "
"E<.Li dllimport> attribute and also fails to explicitly add the extra "
"indirection that the use of the attribute enforces, the application will "
"behave unexpectedly."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6461
msgid ""
"E<.Li PRIVATE>: Put the symbol in the DLL's export table, but do not put it "
"into the static import library used to resolve imports at link time. The "
"symbol can still be imported using the E<.Li LoadLibrary/GetProcAddress> API "
"at runtime or by by using the GNU ld extension of linking directly to the "
"DLL without an import library. See ld/deffilep.y in the binutils sources for "
"the full specification of other DEF file statements"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6467
msgid ""
"While linking a shared dll, E<.Xr ld> is able to create a DEF file with the "
"E<.Li --output-def E<lt>fileE<gt>> command line option."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6468
#, no-wrap
msgid "Using decorations"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6471
msgid ""
"Another way of marking symbols for export is to modify the source code "
"itself, so that when building the DLL each symbol to be exported is declared "
"as:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6475
#, no-wrap
msgid ""
"__declspec(dllexport) int a_variable\n"
"__declspec(dllexport) void a_function(int with_args)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6482
msgid ""
"All such symbols will be exported from the DLL. If, however, any of the "
"object files in the DLL contain symbols decorated in this way, then the "
"normal auto-export behavior is disabled, unless the E<.Li "
"--export-all-symbols> option is also used."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6486
msgid ""
"Note that object files that wish to access these symbols must E<.Em not> "
"decorate them with dllexport. Instead, they should use dllimport, instead:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6490
#, no-wrap
msgid ""
"__declspec(dllimport) int a_variable\n"
"__declspec(dllimport) void a_function(int with_args)\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6501
msgid ""
"This complicates the structure of library header files, because when "
"included by the library itself the header must declare the variables and "
"functions as dllexport, but when included by client code the header must "
"declare them as dllimport. There are a number of idioms that are typically "
"used to do this; often client code can omit the __declspec() declaration "
"completely. See E<.Li --enable-auto-import> and E<.Li automatic data "
"imports> for more information."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6503
#, no-wrap
msgid "automatic data imports"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6517
msgid ""
"The standard Windows dll format supports data imports from dlls only by "
"adding special decorations (dllimport/dllexport), which let the compiler "
"produce specific assembler instructions to deal with this issue. This "
"increases the effort necessary to port existing Un*x code to these "
"platforms, especially for large c++ libraries and applications. The "
"auto-import feature, which was initially provided by Paul Sokolovsky, allows "
"one to omit the decorations to achieve a behavior that conforms to that on "
"POSIX/Un*x platforms. This feature is enabled with the E<.Li "
"--enable-auto-import> command-line option, although it is enabled by default "
"on cygwin/mingw. The E<.Li --enable-auto-import> option itself now serves "
"mainly to suppress any warnings that are ordinarily emitted when linked "
"objects trigger the feature's use."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6520
msgid ""
"auto-import of variables does not always work flawlessly without additional "
"assistance. Sometimes, you will see this message"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6532
msgid ""
"The E<.Li --enable-auto-import> documentation explains why this error "
"occurs, and several methods that can be used to overcome this "
"difficulty. One of these methods is the E<.Em runtime pseudo-relocs> "
"feature, described below."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6541
msgid ""
"For complex variables imported from DLLs (such as structs or classes), "
"object files typically contain a base address for the variable and an offset "
"( E<.Em addend>)  within the variable--to specify a particular field or "
"public member, for instance.  Unfortunately, the runtime loader used in "
"win32 environments is incapable of fixing these references at runtime "
"without the additional information supplied by dllimport/dllexport "
"decorations. The standard auto-import feature described above is unable to "
"resolve these references."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6550
msgid ""
"The E<.Li --enable-runtime-pseudo-relocs> switch allows these references to "
"be resolved without error, while leaving the task of adjusting the "
"references themselves (with their non-zero addends)  to specialized code "
"provided by the runtime environment. Recent versions of the cygwin and mingw "
"environments and compilers provide this runtime support; older versions do "
"not. However, the support is only necessary on the developer's platform; the "
"compiled result will run without error on an older system."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6553
msgid ""
"E<.Li --enable-runtime-pseudo-relocs> is not the default; it must be "
"explicitly enabled as needed."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6554
#, no-wrap
msgid "direct linking to a dll"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6568
msgid ""
"The cygwin/mingw ports of E<.Xr ld> support the direct linking, including "
"data symbols, to a dll without the usage of any import libraries. This is "
"much faster and uses much less memory than does the traditional import "
"library method, especially when linking large libraries or "
"applications. When E<.Xr ld> creates an import lib, each function or "
"variable exported from the dll is stored in its own bfd, even though a "
"single bfd could contain many exports.  The overhead involved in storing, "
"loading, and processing so many bfd's is quite large, and explains the "
"tremendous time, memory, and storage needed to link against particularly "
"large or complex libraries when using import libs."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6578
msgid ""
"Linking directly to a dll uses no extra command-line switches other than "
"E<.Li -L> and E<.Li -l>, because E<.Xr ld> already searches for a number of "
"names to match each library. All that is needed from the developer's "
"perspective is an understanding of this search, in order to force ld to "
"select the dll instead of an import library."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6582
msgid ""
"For instance, when ld is called with the argument E<.Li -lxxx> it will "
"attempt to find, in the first directory of its search path,"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6591
#, no-wrap
msgid ""
"libxxx.dll.a\n"
"xxx.dll.a\n"
"libxxx.a\n"
"xxx.lib\n"
"cygxxx.dll (*)\n"
"libxxx.dll\n"
"xxx.dll\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6594
msgid "before moving on to the next directory in the search path."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6609
msgid ""
"(*) Actually, this is not E<.Li cygxxx.dll> but in fact is E<.Li "
"E<lt>prefixE<gt>xxx.dll>, where E<.Li E<lt>prefixE<gt>> is set by the E<.Xr "
"ld> option E<.Li --dll-search-prefix=E<lt>prefixE<gt>>.  In the case of "
"cygwin, the standard gcc spec file includes E<.Li --dll-search-prefix=cyg>, "
"so in effect we actually search for E<.Li cygxxx.dll>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6616
msgid ""
"Other win32-based unix environments, such as mingw or pw32, may use other "
"E<.Li E<lt>prefixE<gt>> es, although at present only cygwin makes use of "
"this feature. It was originally intended to help avoid name conflicts among "
"dll's built for the various win32/un*x environments, so that (for example) "
"two versions of a zlib dll could coexist on the same machine."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6622
msgid ""
"The generic cygwin/mingw path layout uses a E<.Li bin> directory for "
"applications and dll's and a E<.Li lib> directory for the import libraries "
"(using cygwin nomenclature):"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6629
#, no-wrap
msgid ""
"bin/\n"
"\tcygxxx.dll\n"
"lib/\n"
"\tlibxxx.dll.a   (in case of dll's)\n"
"\tlibxxx.a       (in case of static archive) \n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6633
msgid ""
"Linking directly to a dll without using the import library can be done two "
"ways:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6637
msgid "1. Use the dll directly by adding the E<.Li bin> path to the link line"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6639
#, no-wrap
msgid "gcc -Wl,-verbose  -o a.exe -L../bin/ -lxxx\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6647
msgid ""
"However, as the dll's often have version numbers appended to their names ( "
"E<.Li cygncurses-5.dll>)  this will often fail, unless one specifies E<.Li "
"-L../bin -lncurses-5> to include the version. Import libs are generally not "
"versioned, and do not have this difficulty."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6652
msgid ""
"2. Create a symbolic link from the dll to a file in the E<.Li lib> directory "
"according to the above mentioned search pattern. This should be used to "
"avoid unwanted changes in the tools needed for making the app/dll."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6655
#, no-wrap
msgid "ln -s bin/cygxxx.dll lib/[cyg|lib|]xxx.dll[.a]\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6658
msgid "Then you can link without any make environment changes."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6661
#, no-wrap
msgid "gcc -Wl,-verbose  -o a.exe -L../lib/ -lxxx\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6665
msgid ""
"This technique also avoids the version number problems, because the "
"following is perfectly legal"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6671
#, no-wrap
msgid ""
"bin/\n"
"\tcygxxx-5.dll\n"
"lib/\n"
"\tlibxxx.dll.a -E<gt> ../bin/cygxxx-5.dll \n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6677
msgid ""
"Linking directly to a dll without using an import lib will work even when "
"auto-import features are exercised, and even when E<.Li "
"--enable-runtime-pseudo-relocs> is used."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6680
msgid ""
"Given the improvements in speed and memory usage, one might justifiably "
"wonder why import libraries are used at all. There are three reasons:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6684
msgid ""
"1. Until recently, the link-directly-to-dll functionality did E<.Em not> "
"work with auto-imported data."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6690
msgid ""
"2. Sometimes it is necessary to include pure static objects within the "
"import library (which otherwise contains only bfd's for indirection symbols "
"that point to the exports of a dll). Again, the import lib for the cygwin "
"kernel makes use of this ability, and it is not possible to do this without "
"an import lib."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6695
msgid ""
"3. Symbol aliases can only be resolved using an import lib. This is critical "
"when linking against OS-supplied dll's (eg, the win32 API) in which symbols "
"are usually exported as undecorated aliases of their stdcall-decorated "
"assembly names."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6702
msgid ""
"So, import libs are not going away. But the ability to replace true import "
"libs with a simple symbolic link to (or a copy of) a dll, in many cases, is "
"a useful addition to the suite of tools binutils makes available to the "
"win32 developer. Given the massive improvements in memory requirements "
"during linking, storage requirements, and linking speed, we expect that many "
"developers will soon begin to use this feature whenever possible."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6703
#, no-wrap
msgid "symbol aliasing"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6705
#, no-wrap
msgid "adding additional names"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6715
msgid ""
"Sometimes, it is useful to export symbols with additional names. A symbol "
"E<.Li foo> will be exported as E<.Li foo>, but it can also be exported as "
"E<.Li _foo> by using special directives in the DEF file when creating the "
"dll. This will affect also the optional created import library. Consider the "
"following DEF file:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6718 /usr/src/contrib/binutils/ld/ld.7:6754
#, no-wrap
msgid "LIBRARY \"xyz.dll\" BASE=0x61000000\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6722
#, no-wrap
msgid ""
"EXPORTS\n"
"foo \n"
"_foo = foo\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6730
msgid "The line E<.Li _foo = foo> maps the symbol E<.Li foo> to E<.Li _foo>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6733
msgid ""
"Another method for creating a symbol alias is to create it in the source "
"code using the \"weak\" attribute:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6737
#, no-wrap
msgid ""
"void foo () { /* Do something.  */; } \n"
"void _foo () __attribute__ ((weak, alias (\"foo\")));\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6740
msgid "See the gcc manual for more information about attributes and weak symbols."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6741
#, no-wrap
msgid "renaming symbols"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6751
msgid ""
"Sometimes it is useful to rename exports. For instance, the cygwin kernel "
"does this regularly. A symbol E<.Li _foo> can be exported as E<.Li foo> but "
"not as E<.Li _foo> by using special directives in the DEF file. (This will "
"also affect the import library, if it is created). In the following example:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6757
#, no-wrap
msgid ""
"EXPORTS\n"
"_foo = foo\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6765
msgid ""
"The line E<.Li _foo = foo> maps the exported symbol E<.Li foo> to E<.Li "
"_foo>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6784
msgid ""
"Note: using a DEF file disables the default auto-export behavior, unless the "
"E<.Li --export-all-symbols> command line option is used. If, however, you "
"are trying to rename symbols, then you should list E<.Em all> desired "
"exports in the DEF file, including the symbols that are not being renamed, "
"and do E<.Em not> use the E<.Li --export-all-symbols> option. If you list "
"only the renamed symbols in the DEF file, and use E<.Li "
"--export-all-symbols> to handle the other symbols, then the both the new "
"names E<.Em and> the original names for the renamed symbols will be "
"exported. In effect, you'd be aliasing those symbols, not renaming them, "
"which is probably not what you wanted."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6785
#, no-wrap
msgid "weak externals"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6790
msgid ""
"The Windows object format, PE, specifies a form of weak symbols called weak "
"externals. When a weak symbol is linked and the symbol is not defined, the "
"weak symbol becomes an alias for some other symbol. There are three variants "
"of weak externals:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6794
msgid ""
"Definition is searched for in objects and libraries, historically called "
"lazy externals."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6797
msgid ""
"Definition is searched for only in other objects, not in libraries.  This "
"form is not presently implemented."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6800
msgid "No search; the symbol is an alias. This form is not presently implemented."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6804
msgid ""
"As a GNU extension, weak symbols that do not specify an alternate symbol are "
"supported. If the symbol is undefined when linking, the symbol uses a "
"default value."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:6806
#, no-wrap
msgid "Li ld and Xtensa Processors"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6814
msgid ""
"The default E<.Xr ld> behavior for Xtensa processors is to interpret E<.Li "
"SECTIONS> commands so that lists of explicitly named sections in a "
"specification with a wildcard file will be interleaved when necessary to "
"keep literal pools within the range of PC-relative load offsets. For "
"example, with the command:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6822
#, no-wrap
msgid ""
"SECTIONS\n"
"{\n"
"  .text : {\n"
"    *(.literal .text)\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6840
msgid ""
"E<.Xr ld> may interleave some of the E<.Li .literal> and E<.Li .text> "
"sections from different object files to ensure that the literal pools are "
"within the range of PC-relative load offsets. A valid interleaving might "
"place the E<.Li .literal> sections from an initial group of files followed "
"by the E<.Li .text> sections of that group of files. Then, the E<.Li "
".literal> sections from the rest of the files and the E<.Li .text> sections "
"from the rest of the files would follow."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6859
msgid ""
"Relaxation is enabled by default for the Xtensa version of E<.Xr ld> and "
"provides two important link-time optimizations. The first optimization is to "
"combine identical literal values to reduce code size. A redundant literal "
"will be removed and all the E<.Li L32R> instructions that use it will be "
"changed to reference an identical literal, as long as the location of the "
"replacement literal is within the offset range of all the E<.Li L32R> "
"instructions. The second optimization is to remove unnecessary overhead from "
"assembler-generated \\(lqlongcall\\(rq sequences of E<.Li L32R> / E<.Li "
"CALLX Va n> when the target functions are within range of direct E<.Li CALL "
"Va n> instructions."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6882
msgid ""
"For each of these cases where an indirect call sequence can be optimized to "
"a direct call, the linker will change the E<.Li CALLX Va n> instruction to a "
"E<.Li CALL Va n> instruction, remove the E<.Li L32R> instruction, and remove "
"the literal referenced by the E<.Li L32R> instruction if it is not used for "
"anything else. Removing the E<.Li L32R> instruction always reduces code size "
"but can potentially hurt performance by changing the alignment of subsequent "
"branch targets. By default, the linker will always preserve alignments, "
"either by switching some instructions between 24-bit encodings and the "
"equivalent density instructions or by inserting a no-op in place of the "
"E<.Li L32R> instruction that was removed. If code size is more important "
"than performance, the E<.Op --size-opt> option can be used to prevent the "
"linker from widening density instructions or inserting no-ops, except in a "
"few cases where no-ops are required for correctness."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6885
msgid ""
"The following Xtensa-specific command-line options can be used to control "
"the linker:"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6887
#, no-wrap
msgid "--no-relax"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6895
msgid ""
"Since the Xtensa version of E<.Li ld> enables the E<.Op --relax> option by "
"default, the E<.Op --no-relax> option is provided to disable relaxation."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:6896
#, no-wrap
msgid "--size-opt"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6902
msgid ""
"When optimizing indirect calls to direct calls, optimize for code size more "
"than performance. With this option, the linker will not insert no-ops or "
"widen density instructions to preserve branch target alignment. There may "
"still be some cases where no-ops are required to preserve the correctness of "
"the code."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:6904
#, no-wrap
msgid "BFD"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6915
msgid ""
"The linker accesses object and archive files using the BFD libraries. These "
"libraries allow the linker to use the same routines to operate on object "
"files whatever the object file format. A different object file format can be "
"supported simply by creating a new BFD back end and adding it to the "
"library. To conserve runtime memory, however, the linker and associated "
"tools are usually configured to support only a subset of the object file "
"formats available. You can use E<.Li objdump -i> (see Section E<.Dq "
"objdump>)  to list all the formats available for your configuration."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6922
msgid ""
"As with most implementations, BFD is a compromise between several "
"conflicting requirements. The major factor influencing BFD design was "
"efficiency: any time used converting between formats is time which would not "
"have been spent had BFD not been involved. This is partly offset by "
"abstraction payback; since BFD simplifies applications and back ends, more "
"time and care may be spent optimizing algorithms for a greater speed."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6927
msgid ""
"One minor artifact of the BFD solution which you should bear in mind is the "
"potential for information loss. There are two places where useful "
"information can be lost using the BFD mechanism: during conversion and "
"during output.See Section E<.Dq BFD information loss>."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:6928
#, no-wrap
msgid "How It Works: An Outline of BFD"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6933
msgid ""
"When an object file is opened, BFD subroutines automatically determine the "
"format of the input object file. They then build a descriptor in memory with "
"pointers to routines that will be used to access elements of the object "
"file's data structures."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6945
msgid ""
"As different information from the object files is required, BFD reads from "
"different sections of the file and processes them. For example, a very "
"common operation for the linker is processing symbol tables. Each BFD back "
"end provides a routine for converting between the object file's "
"representation of symbols and an internal canonical format. When the linker "
"asks for the symbol table of an object file, it calls through a memory "
"pointer to the routine from the relevant BFD back end which reads and "
"converts the table into a canonical form. The linker then operates upon the "
"canonical form. When the link is finished and the linker writes the output "
"file's symbol table, another BFD back end routine is called to take the "
"newly created symbol table and convert it into the chosen output format."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6947
msgid "E<.Em Information Loss>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6963
msgid ""
"E<.Em Information can be lost during output.> The output formats supported "
"by BFD do not provide identical facilities, and information which can be "
"described in one form has nowhere to go in another format. One example of "
"this is alignment information in E<.Li b.out>.  There is nowhere in an E<.Li "
"a.out> format file to store alignment information on the contained data, so "
"when a file is linked from E<.Li b.out> and an E<.Li a.out> image is "
"produced, alignment information will not propagate to the output file. (The "
"linker will still use the alignment information internally, so the link is "
"performed correctly)."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6971
msgid ""
"Another example is COFF section names. COFF files may contain an unlimited "
"number of sections, each one with a textual section name. If the target of "
"the link is a format which does not have many sections (e.g., E<.Li a.out>)  "
"or has sections without names (e.g., the Oasys format), the link cannot be "
"done simply. You can circumvent this problem by describing the desired "
"input-to-output section mapping with the linker command language."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6978
msgid ""
"E<.Em Information can be lost during canonicalization.> The BFD internal "
"canonical form of the external formats is not exhaustive; there are "
"structures in input formats for which there is no direct representation "
"internally. This means that the BFD back ends cannot maintain all possible "
"data richness through the transformation between external to internal and "
"back to external formats."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6995
msgid ""
"This limitation is only a problem when an application reads one format and "
"writes another. Each BFD back end is responsible for maintaining as much "
"data as possible, and the internal BFD canonical form has structures which "
"are opaque to the BFD core, and exported only to the back ends. When a file "
"is read in one format, the canonical form is generated for BFD and the "
"application.  At the same time, the back end saves away any information "
"which may otherwise be lost. If the data is then written back in the same "
"format, the back end routine will be able to use the canonical form provided "
"by the BFD core as well as the information it prepared earlier. Since there "
"is a great deal of commonality between back ends, there is no information "
"lost when linking or copying big endian COFF to little endian COFF, or E<.Li "
"a.out> to E<.Li b.out>.  When a mixture of formats is linked, the "
"information is only lost from the files whose format differs from the "
"destination."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:6997
msgid "E<.Em The BFD canonical object-file format>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7003
msgid ""
"The greatest potential for loss of information occurs when there is the "
"least overlap between the information provided by the source format, that "
"stored by the canonical format, and that needed by the destination format. A "
"brief description of the canonical form may help you understand which kinds "
"of data you can count on preserving across conversions."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7005
#, no-wrap
msgid "files"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7014
msgid ""
"Information stored on a per-file basis includes target machine architecture, "
"particular implementation format type, a demand pageable bit, and a write "
"protected bit. Information like Unix magic numbers is not stored here---only "
"the magic numbers' meaning, so a E<.Li ZMAGIC> file would have both the "
"demand pageable bit and the write protected text bit set. The byte order of "
"the target is stored on a per-file basis, so that big- and little-endian "
"object files may be used with one another."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7015
#, no-wrap
msgid "sections"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7019
msgid ""
"Each section in the input file contains the name of the section, the "
"section's original address in the object file, size and alignment "
"information, various flags, and pointers into other BFD data structures."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7020
#, no-wrap
msgid "symbols"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7031
msgid ""
"Each symbol contains a pointer to the information for the object file which "
"originally defined it, its name, its value, and various flag bits. When a "
"BFD back end reads in a symbol table, it relocates all symbols to make them "
"relative to the base of the section where they were defined. Doing this "
"ensures that each symbol points to its containing section. Each symbol also "
"has a varying amount of hidden private data for the BFD back end. Since the "
"symbol points to the original file, the private data format for that symbol "
"is accessible.  E<.Li ld> can operate on a collection of symbols of wildly "
"different formats without problems."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7040
msgid ""
"Normal global and simple local symbols are maintained on output, so an "
"output file (no matter its format) will retain symbols pointing to functions "
"and to global, static, and common variables. Some symbol information is not "
"worth retaining; in E<.Li a.out>, type information is stored in the symbol "
"table as long symbol names. This information would be useless to most COFF "
"debuggers; the linker has command line switches to allow users to throw it "
"away."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7045
msgid ""
"There is one word of type information within the symbol, so if the format "
"supports symbol type information within symbols (for example, COFF, IEEE, "
"Oasys) and the type is simple enough to fit within one word (nearly "
"everything but aggregates), the information will be preserved."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7046
#, no-wrap
msgid "relocation level"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7057
msgid ""
"Each canonical BFD relocation record contains a pointer to the symbol to "
"relocate to, the offset of the data to relocate, the section the data is in, "
"and a pointer to a relocation type descriptor. Relocation is performed by "
"passing messages through the relocation type descriptor and the symbol "
"pointer. Therefore, relocations can be performed on output data using a "
"relocation method that is only available in one of the input formats. For "
"instance, Oasys provides a byte relocation format. A relocation record "
"requesting this relocation type would point indirectly to a routine to "
"perform this, so the relocation may be performed on a byte being written to "
"a 68k COFF file, even though 68k COFF has no such relocation type."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7058
#, no-wrap
msgid "line numbers"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7068
msgid ""
"Object formats can contain, for debugging purposes, some form of mapping "
"between symbols, source line numbers, and addresses in the output "
"file. These addresses have to be relocated along with the symbol "
"information. Each symbol with an associated list of line number records "
"points to the first record of the list.  The head of a line number list "
"consists of a pointer to the symbol, which allows finding out the address of "
"the function whose line number is being described. The rest of the list is "
"made up of pairs: offsets into the section and line numbers. Any format "
"which can simply derive this information can pass it successfully between "
"formats (COFF, IEEE and Oasys)."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:7070
#, no-wrap
msgid "Reporting Bugs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7074
msgid "Your bug reports play an essential role in making E<.Xr ld> reliable."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7081
msgid ""
"Reporting a bug may help you by bringing a solution to your problem, or it "
"may not. But in any case the principal function of a bug report is to help "
"the entire community by making the next version of E<.Xr ld> work "
"better. Bug reports are your contribution to the maintenance of E<.Xr ld>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7084
msgid ""
"In order for a bug report to serve its purpose, you must include the "
"information that enables us to fix the bug."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:7085
#, no-wrap
msgid "Have You Found a Bug?"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7087
msgid "If you are not sure whether you have found a bug, here are some guidelines:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7093
msgid ""
"If the linker gets a fatal signal, for any input whatever, that is a E<.Xr "
"ld> bug. Reliable linkers never crash."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7098
msgid "If E<.Xr ld> produces an error message for valid input, that is a bug."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7104
msgid ""
"If E<.Xr ld> does not produce an error message for invalid input, that may "
"be a bug. In the general case, the linker can not verify that object files "
"are correct."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7110
msgid ""
"If you are an experienced user of linkers, your suggestions for improvement "
"of E<.Xr ld> are welcome in any case."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:7112
#, no-wrap
msgid "How to Report Bugs"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7117
msgid ""
"A number of companies and individuals offer support for GNU products. If you "
"obtained E<.Xr ld> from a support organization, we recommend you contact "
"that organization first."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7122
msgid ""
"You can find contact information for many support companies and individuals "
"in the file E<.Pa etc/SERVICE> in the GNU Emacs distribution."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7126
msgid ""
"The fundamental principle of reporting bugs usefully is this: E<.Sy report "
"all the facts>.  If you are not sure whether to state a fact or leave it "
"out, state it!"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7136
msgid ""
"Often people omit facts because they think they know what causes the problem "
"and assume that some details do not matter. Thus, you might assume that the "
"name of a symbol you use in an example does not matter. Well, probably it "
"does not, but one cannot be sure. Perhaps the bug is a stray memory "
"reference which happens to fetch from the location where that name is stored "
"in memory; perhaps, if the name were different, the contents of that "
"location would fool the linker into doing the right thing despite the "
"bug. Play it safe and give a specific, complete example. That is the easiest "
"thing for you to do, and the most helpful."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7140
msgid ""
"Keep in mind that the purpose of a bug report is to enable us to fix the bug "
"if it is new to us. Therefore, always write your bug reports on the "
"assumption that the bug has not been reported previously."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7145
msgid ""
"Sometimes people give a few sketchy facts and ask, \\(lqDoes this ring a "
"bell?\\(rq This cannot help us fix a bug, so it is basically useless. We "
"respond by asking for enough details to enable us to investigate. You might "
"as well expedite matters by sending them to begin with."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7147
msgid "To enable us to fix the bug, you should include all these things:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7156
msgid ""
"The version of E<.Xr ld>.  E<.Xr ld> announces it if you start it with the "
"E<.Li --version> argument."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7160
msgid ""
"Without this, we will not know whether there is any point in looking for the "
"bug in the current version of E<.Xr ld>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7167
msgid ""
"Any patches you may have applied to the E<.Xr ld> source, including any "
"patches made to the E<.Li BFD> library."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7171
msgid ""
"The type of machine you are using, and the operating system name and version "
"number."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7178
msgid ""
"What compiler (and its version) was used to compile E<.Xr ld> ---e.g. \\(lq "
"E<.Li gcc-2.7> \\(rq\\&."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7183
msgid ""
"The command arguments you gave the linker to link your example and observe "
"the bug. To guarantee you will not omit something important, list them all.  "
"A copy of the Makefile (or the output from make) is sufficient."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7186
msgid ""
"If we were to try to guess the arguments, we would probably guess wrong and "
"then we might not encounter the bug."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7195
msgid ""
"A complete input file, or set of input files, that will reproduce the bug.  "
"It is generally most helpful to send the actual object files provided that "
"they are reasonably small. Say no more than 10K. For bigger files you can "
"either make them available by FTP or HTTP or else state that you are willing "
"to send the object file(s) to whomever requests them. (Note - your email "
"will be going to a mailing list, so we do not want to clog it up with large "
"attachments).  But small attachments are best."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7210
msgid ""
"If the source files were assembled using E<.Li gas> or compiled using E<.Li "
"gcc>, then it may be OK to send the source files rather than the object "
"files. In this case, be sure to say exactly what version of E<.Li gas> or "
"E<.Li gcc> was used to produce the object files. Also say how E<.Li gas> or "
"E<.Li gcc> were configured."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7214
msgid ""
"A description of what behavior you observe that you believe is incorrect.  "
"For example, \\(lqIt gets a fatal signal.\\(rq"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7220
msgid ""
"Of course, if the bug is that E<.Xr ld> gets a fatal signal, then we will "
"certainly notice it. But if the bug is incorrect output, we might not notice "
"unless it is glaringly wrong. You might as well not give us a chance to make "
"a mistake."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7229
msgid ""
"Even if the problem you experience is a fatal signal, you should still say "
"so explicitly. Suppose something strange is going on, such as, your copy of "
"E<.Xr ld> is out of sync, or you have encountered a bug in the C library on "
"your system.  (This has happened!) Your copy might crash and ours would "
"not. If you told us to expect a crash, then when ours fails to crash, we "
"would know that the bug was not happening for us. If you had not told us to "
"expect a crash, then we would not be able to draw any conclusion from our "
"observations."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7244
msgid ""
"If you wish to suggest changes to the E<.Xr ld> source, send us context "
"diffs, as generated by E<.Li diff> with the E<.Li -u>, E<.Li -c>, or E<.Li "
"-p> option. Always send diffs from the old file to the new file. If you even "
"discuss something in the E<.Xr ld> source, refer to it by context, not by "
"line number."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7247
msgid ""
"The line numbers in our development sources will not match those in your "
"sources.  Your line numbers would convey no useful information to us."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7250
msgid "Here are some things that are not necessary:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7254
msgid "A description of the envelope of the bug."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7258
msgid ""
"Often people who encounter a bug spend a lot of time investigating which "
"changes to the input file will make the bug go away and which changes will "
"not affect it."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7263
msgid ""
"This is often time consuming and not very useful, because the way we will "
"find the bug is by running a single example under the debugger with "
"breakpoints, not by pure deduction from a series of examples. We recommend "
"that you save your time for something else."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7269
msgid ""
"Of course, if you can find a simpler example to report E<.Em instead> of the "
"original one, that is a convenience for us. Errors in the output will be "
"easier to spot, running under the debugger will take less time, and so on."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7272
msgid ""
"However, simplification is not vital; if you do not want to do this, report "
"the bug anyway and send us the entire test case you used."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7275
msgid "A patch for the bug."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7280
msgid ""
"A patch for the bug does help us if it is a good one. But do not omit the "
"necessary information, such as the test case, on the assumption that a patch "
"is all we need. We might see problems with your patch and decide to fix the "
"problem another way, or we might not understand it at all."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7287
msgid ""
"Sometimes with a program as complicated as E<.Xr ld> it is very hard to "
"construct an example that will make the program follow a certain path "
"through the code. If you do not send us the example, we will not be able to "
"construct one, so we will not be able to verify that the bug is fixed."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7291
msgid ""
"And if we cannot understand what bug you are trying to fix, or why your "
"patch should be an improvement, we will not install it. A test case will "
"help us to understand."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7294
msgid "A guess about what the bug is or what it depends on."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7297
msgid ""
"Such guesses are usually wrong. Even we cannot guess right about such things "
"without first using the debugger to find the facts."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:7299
#, no-wrap
msgid "MRI Compatible Script Files"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7313
msgid ""
"To aid users making the transition to GNU E<.Xr ld> from the MRI linker, "
"E<.Xr ld> can use MRI compatible linker scripts as an alternative to the "
"more general-purpose linker scripting language described in Scripts. MRI "
"compatible linker scripts have a much simpler command set than the scripting "
"language otherwise used with E<.Xr ld>.  GNU E<.Xr ld> supports the most "
"commonly used MRI linker commands; these commands are described here."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7318
msgid ""
"In general, MRI scripts aren't of much use with the E<.Li a.out> object file "
"format, since it only has three sections and MRI scripts lack some features "
"to make use of them."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7322
msgid ""
"You can specify a file containing an MRI-compatible script using the E<.Li "
"-c> command-line option."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7329
msgid ""
"Each command in an MRI-compatible script occupies its own line; each command "
"line starts with the keyword that identifies the command (though blank lines "
"are also allowed for punctuation). If a line of an MRI-compatible script "
"begins with an unrecognized keyword, E<.Xr ld> issues a warning message, but "
"continues processing the script."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7333
msgid "Lines beginning with E<.Li *> are comments."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7340
msgid ""
"You can write these commands using all upper-case letters, or all lower "
"case; for example, E<.Li chip> is the same as E<.Li CHIP>.  The following "
"list shows only the upper-case form of each command."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7342
#, no-wrap
msgid "ABSOLUTE Va secname"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7343
#, no-wrap
msgid "ABSOLUTE Va secname, Va secname, ... Va secname"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7359
msgid ""
"Normally, E<.Xr ld> includes in the output file all sections from all the "
"input files. However, in an MRI-compatible script, you can use the E<.Li "
"ABSOLUTE> command to restrict the sections that will be present in your "
"output program.  If the E<.Li ABSOLUTE> command is used at all in a script, "
"then only the sections named explicitly in E<.Li ABSOLUTE> commands will "
"appear in the linker output. You can still use other input sections "
"(whatever you select on the command line, or using E<.Li LOAD>)  to resolve "
"addresses in the output file."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7360
#, no-wrap
msgid "ALIAS Va out-secname, Va in-secname"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7366
msgid ""
"Use this command to place the data from input section E<.Va in-secname> in a "
"section called E<.Va out-secname> in the linker output file."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7369
msgid "E<.Va in-secname> may be an integer."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7370
#, no-wrap
msgid "ALIGN Va secname = Va expression"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7378
msgid ""
"Align the section called E<.Va secname> to E<.Va expression>.  The E<.Va "
"expression> should be a power of two."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7379
#, no-wrap
msgid "BASE Va expression"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7383
msgid ""
"Use the value of E<.Va expression> as the lowest address (other than "
"absolute addresses) in the output file."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7384
#, no-wrap
msgid "CHIP Va expression"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7385
#, no-wrap
msgid "CHIP Va expression, Va expression"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7387
msgid "This command does nothing; it is accepted only for compatibility."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7388
#, no-wrap
msgid "END"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7390
msgid "This command does nothing whatever; it's only accepted for compatibility."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7391
#, no-wrap
msgid "FORMAT Va output-format"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7396
msgid ""
"Similar to the E<.Li OUTPUT_FORMAT> command in the more general linker "
"language, but restricted to one of these output formats:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7403
msgid "S-records, if E<.Va output-format> is E<.Li S>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7409
msgid "IEEE, if E<.Va output-format> is E<.Li IEEE>"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7417
msgid ""
"COFF (the E<.Li coff-m68k> variant in BFD), if E<.Va output-format> is E<.Li "
"COFF>"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7419
#, no-wrap
msgid "LIST Va anything..."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7424
msgid ""
"Print (to the standard output file) a link map, as produced by the E<.Xr ld> "
"command-line option E<.Li -M>."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7428
msgid ""
"The keyword E<.Li LIST> may be followed by anything on the same line, with "
"no change in its effect."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7429
#, no-wrap
msgid "LOAD Va filename"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7430
#, no-wrap
msgid "LOAD Va filename, Va filename, ... Va filename"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7438
msgid ""
"Include one or more object file E<.Va filename> in the link; this has the "
"same effect as specifying E<.Va filename> directly on the E<.Xr ld> command "
"line."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7439
#, no-wrap
msgid "NAME Va output-name"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7449
msgid ""
"E<.Va output-name> is the name for the program produced by E<.Xr ld>; the "
"MRI-compatible command E<.Li NAME> is equivalent to the command-line option "
"E<.Li -o> or the general script language command E<.Li OUTPUT>."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7450
#, no-wrap
msgid "ORDER Va secname, Va secname, ... Va secname"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7451
#, no-wrap
msgid "ORDER Va secname Va secname Va secname"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7461
msgid ""
"Normally, E<.Xr ld> orders the sections in its output file in the order in "
"which they first appear in the input files. In an MRI-compatible script, you "
"can override this ordering with the E<.Li ORDER> command. The sections you "
"list with E<.Li ORDER> will appear first in your output file, in the order "
"specified."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7462
#, no-wrap
msgid "PUBLIC Va name= Va expression"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7463
#, no-wrap
msgid "PUBLIC Va name, Va expression"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7464
#, no-wrap
msgid "PUBLIC Va name Va expression"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7470
msgid ""
"Supply a value ( E<.Va expression>)  for external symbol E<.Va name> used in "
"the linker input files."
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7471
#, no-wrap
msgid "SECT Va secname, Va expression"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7472
#, no-wrap
msgid "SECT Va secname= Va expression"
msgstr ""

#. type: It
#: /usr/src/contrib/binutils/ld/ld.7:7473
#, no-wrap
msgid "SECT Va secname Va expression"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7487
msgid ""
"You can use any of these three forms of the E<.Li SECT> command to specify "
"the start address ( E<.Va expression>)  for section E<.Va secname>.  If you "
"have more than one E<.Li SECT> statement for the same E<.Va secname>, only "
"the E<.Em first> sets the start address."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:7489
#, no-wrap
msgid "GNU Free Documentation License"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7493
#, no-wrap
msgid ""
"Copyright (C) 2000, 2003 Free Software Foundation, Inc. 51 Franklin "
"Street,\n"
"Fifth Floor, Boston, MA 02110-1301 USA\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7496
#, no-wrap
msgid ""
"Everyone is permitted to copy and distribute verbatim copies of this "
"license\n"
"document, but changing it is not allowed.\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7501
msgid "PREAMBLE"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7508
msgid ""
"The purpose of this License is to make a manual, textbook, or other written "
"document \\(lqfree\\(rq in the sense of freedom: to assure everyone the "
"effective freedom to copy and redistribute it, with or without modifying it, "
"either commercially or noncommercially. Secondarily, this License preserves "
"for the author and publisher a way to get credit for their work, while not "
"being considered responsible for modifications made by others."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7512
msgid ""
"This License is a kind of \\(lqcopyleft\\(rq, which means that derivative "
"works of the document must themselves be free in the same sense. It "
"complements the GNU General Public License, which is a copyleft license "
"designed for free software."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7520
msgid ""
"We have designed this License in order to use it for manuals for free "
"software, because free software needs free documentation: a free program "
"should come with manuals providing the same freedoms that the software "
"does. But this License is not limited to software manuals; it can be used "
"for any textual work, regardless of subject matter or whether it is "
"published as a printed book. We recommend this License principally for works "
"whose purpose is instruction or reference."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7523
msgid "APPLICABILITY AND DEFINITIONS"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7528
msgid ""
"This License applies to any manual or other work that contains a notice "
"placed by the copyright holder saying it can be distributed under the terms "
"of this License. The \\(lqDocument\\(rq, below, refers to any such manual or "
"work. Any member of the public is a licensee, and is addressed as "
"\\(lqyou.\\(rq"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7532
msgid ""
"A \\(lqModified Version\\(rq of the Document means any work containing the "
"Document or a portion of it, either copied verbatim, or with modifications "
"and/or translated into another language."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7541
msgid ""
"A \\(lqSecondary Section\\(rq is a named appendix or a front-matter section "
"of the Document that deals exclusively with the relationship of the "
"publishers or authors of the Document to the Document's overall subject (or "
"to related matters)  and contains nothing that could fall directly within "
"that overall subject.  (For example, if the Document is in part a textbook "
"of mathematics, a Secondary Section may not explain any mathematics.) The "
"relationship could be a matter of historical connection with the subject or "
"with related matters, or of legal, commercial, philosophical, ethical or "
"political position regarding them."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7545
msgid ""
"The \\(lqInvariant Sections\\(rq are certain Secondary Sections whose titles "
"are designated, as being those of Invariant Sections, in the notice that "
"says that the Document is released under this License."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7549
msgid ""
"The \\(lqCover Texts\\(rq are certain short passages of text that are "
"listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says "
"that the Document is released under this License."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7560
msgid ""
"A \\(lqTransparent\\(rq copy of the Document means a machine-readable copy, "
"represented in a format whose specification is available to the general "
"public, whose contents can be viewed and edited directly and "
"straightforwardly with generic text editors or (for images composed of "
"pixels) generic paint programs or (for drawings) some widely available "
"drawing editor, and that is suitable for input to text formatters or for "
"automatic translation to a variety of formats suitable for input to text "
"formatters. A copy made in an otherwise Transparent file format whose markup "
"has been designed to thwart or discourage subsequent modification by readers "
"is not Transparent. A copy that is not \\(lqTransparent\\(rq is called "
"\\(lqOpaque.\\(rq"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7568
msgid ""
"Examples of suitable formats for Transparent copies include plain ASCII "
"without markup, Texinfo input format, LaTeX input format, SGML or XML using "
"a publicly available DTD, and standard-conforming simple HTML designed for "
"human modification.  Opaque formats include PostScript, PDF, proprietary "
"formats that can be read and edited only by proprietary word processors, "
"SGML or XML for which the DTD and/or processing tools are not generally "
"available, and the machine-generated HTML produced by some word processors "
"for output purposes only."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7575
msgid ""
"The \\(lqTitle Page\\(rq means, for a printed book, the title page itself, "
"plus such following pages as are needed to hold, legibly, the material this "
"License requires to appear in the title page. For works in formats which do "
"not have any title page as such, \\(lqTitle Page\\(rq means the text near "
"the most prominent appearance of the work's title, preceding the beginning "
"of the body of the text."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7578
msgid "VERBATIM COPYING"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7587
msgid ""
"You may copy and distribute the Document in any medium, either commercially "
"or noncommercially, provided that this License, the copyright notices, and "
"the license notice saying this License applies to the Document are "
"reproduced in all copies, and that you add no other conditions whatsoever to "
"those of this License. You may not use technical measures to obstruct or "
"control the reading or further copying of the copies you make or "
"distribute. However, you may accept compensation in exchange for copies. If "
"you distribute a large enough number of copies you must also follow the "
"conditions in section 3."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7590
msgid ""
"You may also lend copies, under the same conditions stated above, and you "
"may publicly display copies."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7593
msgid "COPYING IN QUANTITY"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7604
msgid ""
"If you publish printed copies of the Document numbering more than 100, and "
"the Document's license notice requires Cover Texts, you must enclose the "
"copies in covers that carry, clearly and legibly, all these Cover Texts: "
"Front-Cover Texts on the front cover, and Back-Cover Texts on the back "
"cover. Both covers must also clearly and legibly identify you as the "
"publisher of these copies.  The front cover must present the full title with "
"all words of the title equally prominent and visible. You may add other "
"material on the covers in addition.  Copying with changes limited to the "
"covers, as long as they preserve the title of the Document and satisfy these "
"conditions, can be treated as verbatim copying in other respects."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7608
msgid ""
"If the required texts for either cover are too voluminous to fit legibly, "
"you should put the first ones listed (as many as fit reasonably) on the "
"actual cover, and continue the rest onto adjacent pages."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7620
msgid ""
"If you publish or distribute Opaque copies of the Document numbering more "
"than 100, you must either include a machine-readable Transparent copy along "
"with each Opaque copy, or state in or with each Opaque copy a "
"publicly-accessible computer-network location containing a complete "
"Transparent copy of the Document, free of added material, which the general "
"network-using public has access to download anonymously at no charge using "
"public-standard network protocols.  If you use the latter option, you must "
"take reasonably prudent steps, when you begin distribution of Opaque copies "
"in quantity, to ensure that this Transparent copy will remain thus "
"accessible at the stated location until at least one year after the last "
"time you distribute an Opaque copy (directly or through your agents or "
"retailers) of that edition to the public."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7624
msgid ""
"It is requested, but not required, that you contact the authors of the "
"Document well before redistributing any large number of copies, to give them "
"a chance to provide you with an updated version of the Document."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7627
msgid "MODIFICATIONS"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7634
msgid ""
"You may copy and distribute a Modified Version of the Document under the "
"conditions of sections 2 and 3 above, provided that you release the Modified "
"Version under precisely this License, with the Modified Version filling the "
"role of the Document, thus licensing distribution and modification of the "
"Modified Version to whoever possesses a copy of it. In addition, you must do "
"these things in the Modified Version:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7671
msgid ""
"A. Use in the Title Page (and on the covers, if any) a title distinct from "
"that of the Document, and from those of previous versions (which should, if "
"there were any, be listed in the History section of the Document). You may "
"use the same title as a previous version if the original publisher of that "
"version gives permission.  B. List on the Title Page, as authors, one or "
"more persons or entities responsible for authorship of the modifications in "
"the Modified Version, together with at least five of the principal authors "
"of the Document (all of its principal authors, if it has less than five).  "
"C.  State on the Title page the name of the publisher of the Modified "
"Version, as the publisher.  D. Preserve all the copyright notices of the "
"Document.  E. Add an appropriate copyright notice for your modifications "
"adjacent to the other copyright notices.  F. Include, immediately after the "
"copyright notices, a license notice giving the public permission to use the "
"Modified Version under the terms of this License, in the form shown in the "
"Addendum below.  G. Preserve in that license notice the full lists of "
"Invariant Sections and required Cover Texts given in the Document's license "
"notice.  H. Include an unaltered copy of this License.  I. Preserve the "
"section entitled \\(lqHistory\\(rq, and its title, and add to it an item "
"stating at least the title, year, new authors, and publisher of the Modified "
"Version as given on the Title Page.  If there is no section entitled "
"\\(lqHistory\\(rq in the Document, create one stating the title, year, "
"authors, and publisher of the Document as given on its Title Page, then add "
"an item describing the Modified Version as stated in the previous sentence.  "
"J. Preserve the network location, if any, given in the Document for public "
"access to a Transparent copy of the Document, and likewise the network "
"locations given in the Document for previous versions it was based on. These "
"may be placed in the \\(lqHistory\\(rq section. You may omit a network "
"location for a work that was published at least four years before the "
"Document itself, or if the original publisher of the version it refers to "
"gives permission.  K. In any section entitled \\(lqAcknowledgements\\(rq or "
"\\(lqDedications\\(rq, preserve the section's title, and preserve in the "
"section all the substance and tone of each of the contributor "
"acknowledgements and/or dedications given therein.  L. Preserve all the "
"Invariant Sections of the Document, unaltered in their text and in their "
"titles. Section numbers or the equivalent are not considered part of the "
"section titles.  M. Delete any section entitled \\(lqEndorsements.\\(rq Such "
"a section may not be included in the Modified Version.  N. Do not retitle "
"any existing section as \\(lqEndorsements\\(rq or to conflict in title with "
"any Invariant Section."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7678
msgid ""
"If the Modified Version includes new front-matter sections or appendices "
"that qualify as Secondary Sections and contain no material copied from the "
"Document, you may at your option designate some or all of these sections as "
"invariant.  To do this, add their titles to the list of Invariant Sections "
"in the Modified Version's license notice. These titles must be distinct from "
"any other section titles."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7683
msgid ""
"You may add a section entitled \\(lqEndorsements\\(rq, provided it contains "
"nothing but endorsements of your Modified Version by various parties--for "
"example, statements of peer review or that the text has been approved by an "
"organization as the authoritative definition of a standard."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7692
msgid ""
"You may add a passage of up to five words as a Front-Cover Text, and a "
"passage of up to 25 words as a Back-Cover Text, to the end of the list of "
"Cover Texts in the Modified Version. Only one passage of Front-Cover Text "
"and one of Back-Cover Text may be added by (or through arrangements made by) "
"any one entity. If the Document already includes a cover text for the same "
"cover, previously added by you or by arrangement made by the same entity you "
"are acting on behalf of, you may not add another; but you may replace the "
"old one, on explicit permission from the previous publisher that added the "
"old one."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7696
msgid ""
"The author(s) and publisher(s) of the Document do not by this License give "
"permission to use their names for publicity for or to assert or imply "
"endorsement of any Modified Version."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7699
msgid "COMBINING DOCUMENTS"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7705
msgid ""
"You may combine the Document with other documents released under this "
"License, under the terms defined in section 4 above for modified versions, "
"provided that you include in the combination all of the Invariant Sections "
"of all of the original documents, unmodified, and list them all as Invariant "
"Sections of your combined work in its license notice."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7714
msgid ""
"The combined work need only contain one copy of this License, and multiple "
"identical Invariant Sections may be replaced with a single copy. If there "
"are multiple Invariant Sections with the same name but different contents, "
"make the title of each such section unique by adding at the end of it, in "
"parentheses, the name of the original author or publisher of that section if "
"known, or else a unique number. Make the same adjustment to the section "
"titles in the list of Invariant Sections in the license notice of the "
"combined work."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7719
msgid ""
"In the combination, you must combine any sections entitled \\(lqHistory\\(rq "
"in the various original documents, forming one section entitled "
"\\(lqHistory\\(rq; likewise combine any sections entitled "
"\\(lqAcknowledgements\\(rq, and any sections entitled \\(lqDedications.\\(rq "
"You must delete all sections entitled \\(lqEndorsements.\\(rq"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7722
msgid "COLLECTIONS OF DOCUMENTS"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7728
msgid ""
"You may make a collection consisting of the Document and other documents "
"released under this License, and replace the individual copies of this "
"License in the various documents with a single copy that is included in the "
"collection, provided that you follow the rules of this License for verbatim "
"copying of each of the documents in all other respects."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7733
msgid ""
"You may extract a single document from such a collection, and distribute it "
"individually under this License, provided you insert a copy of this License "
"into the extracted document, and follow this License in all other respects "
"regarding verbatim copying of that document."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7736
msgid "AGGREGATION WITH INDEPENDENT WORKS"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7744
msgid ""
"A compilation of the Document or its derivatives with other separate and "
"independent documents or works, in or on a volume of a storage or "
"distribution medium, does not as a whole count as a Modified Version of the "
"Document, provided no compilation copyright is claimed for the "
"compilation. Such a compilation is called an \\(lqaggregate\\(rq, and this "
"License does not apply to the other self-contained works thus compiled with "
"the Document, on account of their being thus compiled, if they are not "
"themselves derivative works of the Document."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7750
msgid ""
"If the Cover Text requirement of section 3 is applicable to these copies of "
"the Document, then if the Document is less than one quarter of the entire "
"aggregate, the Document's Cover Texts may be placed on covers that surround "
"only the Document within the aggregate. Otherwise they must appear on covers "
"around the whole aggregate."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7753
msgid "TRANSLATION"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7763
msgid ""
"Translation is considered a kind of modification, so you may distribute "
"translations of the Document under the terms of section 4. Replacing "
"Invariant Sections with translations requires special permission from their "
"copyright holders, but you may include translations of some or all Invariant "
"Sections in addition to the original versions of these Invariant "
"Sections. You may include a translation of this License provided that you "
"also include the original English version of this License. In case of a "
"disagreement between the translation and the original English version of "
"this License, the original English version will prevail."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7766
msgid "TERMINATION"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7773
msgid ""
"You may not copy, modify, sublicense, or distribute the Document except as "
"expressly provided for under this License. Any other attempt to copy, "
"modify, sublicense or distribute the Document is void, and will "
"automatically terminate your rights under this License. However, parties who "
"have received copies, or rights, from you under this License will not have "
"their licenses terminated so long as such parties remain in full compliance."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7776
msgid "FUTURE REVISIONS OF THIS LICENSE"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7781
msgid ""
"The Free Software Foundation may publish new, revised versions of the GNU "
"Free Documentation License from time to time. Such new versions will be "
"similar in spirit to the present version, but may differ in detail to "
"address new problems or concerns. See http://www.gnu.org/copyleft/."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7789
msgid ""
"Each version of the License is given a distinguishing version number. If the "
"Document specifies that a particular numbered version of this License "
"\\(lqor any later version\\(rq applies to it, you have the option of "
"following the terms and conditions either of that specified version or of "
"any later version that has been published (not as a draft) by the Free "
"Software Foundation. If the Document does not specify a version number of "
"this License, you may choose any version ever published (not as a draft) by "
"the Free Software Foundation."
msgstr ""

#. type: Ss
#: /usr/src/contrib/binutils/ld/ld.7:7791
#, no-wrap
msgid "ADDENDUM: How to use this License for your documents"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7795
msgid ""
"To use this License in a document you have written, include a copy of the "
"License in the document and put the following copyright and license notices "
"just after the title page:"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7806
#, no-wrap
msgid ""
"Copyright (C)  year  your name.\n"
"Permission is granted to copy, distribute and/or modify this document\n"
"under the terms of the GNU Free Documentation License, Version 1.1\n"
"or any later version published by the Free Software Foundation;\n"
"with the Invariant Sections being list their titles, with the\n"
"Front-Cover Texts being list, and with the Back-Cover Texts being list.\n"
"A copy of the license is included in the section entitled \"GNU\n"
"Free Documentation License.\"\n"
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7814
msgid ""
"If you have no Invariant Sections, write \\(lqwith no Invariant "
"Sections\\(rq instead of saying which ones are invariant. If you have no "
"Front-Cover Texts, write \\(lqno Front-Cover Texts\\(rq instead of "
"\\(lqFront-Cover Texts being E<.Va list> \\(rq; likewise for Back-Cover "
"Texts."
msgstr ""

#. type: Plain text
#: /usr/src/contrib/binutils/ld/ld.7:7818
msgid ""
"If your document contains nontrivial examples of program code, we recommend "
"releasing these examples in parallel under your choice of free software "
"license, such as the GNU General Public License, to permit their use in free "
"software."
msgstr ""

#. type: Sh
#: /usr/src/contrib/binutils/ld/ld.7:7819
#, no-wrap
msgid "LD Index"
msgstr ""
