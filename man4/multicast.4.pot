# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-05-18 14:28-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Dd
#: /usr/src/share/man/man4/multicast.4:28
#, no-wrap
msgid "May 27, 2009"
msgstr ""

#. type: Dt
#: /usr/src/share/man/man4/multicast.4:29
#, no-wrap
msgid "MULTICAST 4"
msgstr ""

#. type: Sh
#: /usr/src/share/man/man4/multicast.4:32
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:34
msgid "E<.Nm multicast>"
msgstr ""

#. type: Nd
#: /usr/src/share/man/man4/multicast.4:34
#, no-wrap
msgid "Multicast Routing"
msgstr ""

#. type: Sh
#: /usr/src/share/man/man4/multicast.4:36
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:38
msgid "E<.Cd \"options MROUTING\">"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:39
#, no-wrap
msgid "sys/types.h"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:40
#, no-wrap
msgid "sys/socket.h"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:41
#, no-wrap
msgid "netinet/in.h"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:42 /usr/src/share/man/man4/multicast.4:444
#, no-wrap
msgid "netinet/ip_mroute.h"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:43
#, no-wrap
msgid "netinet6/ip6_mroute.h"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:52
msgid ""
"E<.Ft int> E<.Fn getsockopt \"int s\" IPPROTO_IP MRT_INIT \"void *optval\" "
"\"socklen_t *optlen\"> E<.Ft int> E<.Fn setsockopt \"int s\" IPPROTO_IP "
"MRT_INIT \"const void *optval\" \"socklen_t optlen\"> E<.Ft int> E<.Fn "
"getsockopt \"int s\" IPPROTO_IPV6 MRT6_INIT \"void *optval\" \"socklen_t "
"*optlen\"> E<.Ft int> E<.Fn setsockopt \"int s\" IPPROTO_IPV6 MRT6_INIT "
"\"const void *optval\" \"socklen_t optlen\">"
msgstr ""

#. type: Sh
#: /usr/src/share/man/man4/multicast.4:52
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:61
msgid ""
"E<.Tn \"Multicast routing\"> is used to efficiently propagate data packets "
"to a set of multicast listeners in multipoint networks.  If unicast is used "
"to replicate the data to all listeners, then some of the network links may "
"carry multiple copies of the same data packets.  With multicast routing, the "
"overhead is reduced to one copy (at most) per network link."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:72
msgid ""
"All multicast-capable routers must run a common multicast routing protocol.  "
"It is recommended that either Protocol Independent Multicast - Sparse Mode "
"(PIM-SM), or Protocol Independent Multicast - Dense Mode (PIM-DM)  are used, "
"as these are now the generally accepted protocols in the Internet "
"community.  The E<.Sx HISTORY> section discusses previous multicast routing "
"protocols."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:84
msgid ""
"To start multicast routing, the user must enable multicast forwarding in the "
"kernel (see E<.Sx SYNOPSIS> about the kernel configuration options), and "
"must run a multicast routing capable user-level process.  From developer's "
"point of view, the programming guide described in the E<.Sx \"Programming "
"Guide\"> section should be used to control the multicast forwarding in the "
"kernel."
msgstr ""

#. type: Ss
#: /usr/src/share/man/man4/multicast.4:84
#, no-wrap
msgid "Programming Guide"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:91
msgid ""
"This section provides information about the basic multicast routing API.  "
"The so-called E<.Dq advanced multicast API> is described in the E<.Sx "
"\"Advanced Multicast API Programming Guide\"> section."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:97
msgid ""
"First, a multicast routing socket must be open.  That socket would be used "
"to control the multicast forwarding in the kernel.  Note that most "
"operations below require certain privilege (i.e., root privilege):"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:101
#, no-wrap
msgid ""
"/* IPv4 */\n"
"int mrouter_s4;\n"
"mrouter_s4 = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP);\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:105
#, no-wrap
msgid ""
"int mrouter_s6;\n"
"mrouter_s6 = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:127
msgid ""
"Note that if the router needs to open an IGMP or ICMPv6 socket (in case of "
"IPv4 and IPv6 respectively)  for sending or receiving of IGMP or MLD "
"multicast group membership messages, then the same E<.Va mrouter_s4> or "
"E<.Va mrouter_s6> sockets should be used for sending and receiving "
"respectively IGMP or MLD messages.  In case of E<.Bx Ns> -derived kernel, it "
"may be possible to open separate sockets for IGMP or MLD messages only.  "
"However, some other kernels (e.g., E<.Tn Linux>)  require that the multicast "
"routing socket must be used for sending and receiving of IGMP or MLD "
"messages.  Therefore, for portability reason the multicast routing socket "
"should be reused for IGMP and MLD messages as well."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:130
msgid ""
"After the multicast routing socket is open, it can be used to enable or "
"disable multicast forwarding in the kernel:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:134
#, no-wrap
msgid ""
"/* IPv4 */\n"
"int v = 1;        /* 1 to enable, or 0 to disable */\n"
"setsockopt(mrouter_s4, IPPROTO_IP, MRT_INIT, (void *)&v, sizeof(v));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:145
#, no-wrap
msgid ""
"/* IPv6 */\n"
"int v = 1;        /* 1 to enable, or 0 to disable */\n"
"setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_INIT, (void *)&v, sizeof(v));\n"
"\\&...\n"
"/* If necessary, filter all ICMPv6 messages */\n"
"struct icmp6_filter filter;\n"
"ICMP6_FILTER_SETBLOCKALL(&filter);\n"
"setsockopt(mrouter_s6, IPPROTO_ICMPV6, ICMP6_FILTER, (void *)&filter,\n"
"           sizeof(filter));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:152
msgid ""
"After multicast forwarding is enabled, the multicast routing socket can be "
"used to enable PIM processing in the kernel if we are running PIM-SM or "
"PIM-DM (see E<.Xr pim 4>)."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:156
msgid ""
"For each network interface (e.g., physical or a virtual tunnel)  that would "
"be used for multicast forwarding, a corresponding multicast interface must "
"be added to the kernel:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:168
#, no-wrap
msgid ""
"/* IPv4 */\n"
"struct vifctl vc;\n"
"memset(&vc, 0, sizeof(vc));\n"
"/* Assign all vifctl fields as appropriate */\n"
"vc.vifc_vifi = vif_index;\n"
"vc.vifc_flags = vif_flags;\n"
"vc.vifc_threshold = min_ttl_threshold;\n"
"vc.vifc_rate_limit = 0;\n"
"memcpy(&vc.vifc_lcl_addr, &vif_local_address, sizeof(vc.vifc_lcl_addr));\n"
"setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_VIF, (void *)&vc,\n"
"           sizeof(vc));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:178
msgid ""
"The E<.Va vif_index> must be unique per vif.  The E<.Va vif_flags> contains "
"the E<.Dv VIFF_*> flags as defined in"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:178
#, no-wrap
msgid "netinet/ip_mroute.h ."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:189
msgid ""
"The E<.Dv VIFF_TUNNEL> flag is no longer supported by E<.Fx>.  Users who "
"wish to forward multicast datagrams over a tunnel should consider "
"configuring a E<.Xr gif 4> or E<.Xr gre 4> tunnel and using it as a physical "
"interface."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:195
msgid ""
"The E<.Va min_ttl_threshold> contains the minimum TTL a multicast data "
"packet must have to be forwarded on that vif.  Typically, it would have "
"value of 1."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:205
msgid ""
"The E<.Va max_rate_limit> argument is no longer supported in E<.Fx> and "
"should be set to 0.  Users who wish to rate-limit multicast datagrams should "
"consider the use of E<.Xr dummynet 4> or E<.Xr altq 4>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:212
msgid ""
"The E<.Va vif_local_address> contains the local IP address of the "
"corresponding local interface.  The E<.Va vif_remote_address> contains the "
"remote IP address in case of DVMRP multicast tunnels."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:222
#, no-wrap
msgid ""
"/* IPv6 */\n"
"struct mif6ctl mc;\n"
"memset(&mc, 0, sizeof(mc));\n"
"/* Assign all mif6ctl fields as appropriate */\n"
"mc.mif6c_mifi = mif_index;\n"
"mc.mif6c_flags = mif_flags;\n"
"mc.mif6c_pifi = pif_index;\n"
"setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_ADD_MIF, (void *)&mc,\n"
"           sizeof(mc));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:232
msgid ""
"The E<.Va mif_index> must be unique per vif.  The E<.Va mif_flags> contains "
"the E<.Dv MIFF_*> flags as defined in"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:232
#, no-wrap
msgid "netinet6/ip6_mroute.h ."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:236
msgid ""
"The E<.Va pif_index> is the physical interface index of the corresponding "
"local interface."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:238
msgid "A multicast interface is deleted by:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:243
#, no-wrap
msgid ""
"/* IPv4 */\n"
"vifi_t vifi = vif_index;\n"
"setsockopt(mrouter_s4, IPPROTO_IP, MRT_DEL_VIF, (void *)&vifi,\n"
"           sizeof(vifi));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:249
#, no-wrap
msgid ""
"/* IPv6 */\n"
"mifi_t mifi = mif_index;\n"
"setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_DEL_MIF, (void *)&mifi,\n"
"           sizeof(mifi));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:262
msgid ""
"After the multicast forwarding is enabled, and the multicast virtual "
"interfaces are added, the kernel may deliver upcall messages (also called "
"signals later in this text) on the multicast routing socket that was open "
"earlier with E<.Dv MRT_INIT> or E<.Dv MRT6_INIT>.  The IPv4 upcalls have "
"E<.Vt \"struct igmpmsg\"> header (see"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:262
#, no-wrap
msgid "netinet/ip_mroute.h )"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:274
msgid ""
"with field E<.Va im_mbz> set to zero.  Note that this header follows the "
"structure of E<.Vt \"struct ip\"> with the protocol field E<.Va ip_p> set to "
"zero.  The IPv6 upcalls have E<.Vt \"struct mrt6msg\"> header (see"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:274
#, no-wrap
msgid "netinet6/ip6_mroute.h )"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:283
msgid ""
"with field E<.Va im6_mbz> set to zero.  Note that this header follows the "
"structure of E<.Vt \"struct ip6_hdr\"> with the next header field E<.Va "
"ip6_nxt> set to zero."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:295
msgid ""
"The upcall header contains field E<.Va im_msgtype> and E<.Va im6_msgtype> "
"with the type of the upcall E<.Dv IGMPMSG_*> and E<.Dv MRT6MSG_*> for IPv4 "
"and IPv6 respectively.  The values of the rest of the upcall header fields "
"and the body of the upcall message depend on the particular upcall type."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:305
msgid ""
"If the upcall message type is E<.Dv IGMPMSG_NOCACHE> or E<.Dv "
"MRT6MSG_NOCACHE>, this is an indication that a multicast packet has reached "
"the multicast router, but the router has no forwarding state for that "
"packet.  Typically, the upcall would be a signal for the multicast routing "
"user-level process to install the appropriate Multicast Forwarding Cache "
"(MFC) entry in the kernel."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:307
msgid "An MFC entry is added by:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:318
#, no-wrap
msgid ""
"/* IPv4 */\n"
"struct mfcctl mc;\n"
"memset(&mc, 0, sizeof(mc));\n"
"memcpy(&mc.mfcc_origin, &source_addr, sizeof(mc.mfcc_origin));\n"
"memcpy(&mc.mfcc_mcastgrp, &group_addr, sizeof(mc.mfcc_mcastgrp));\n"
"mc.mfcc_parent = iif_index;\n"
"for (i = 0; i E<lt> maxvifs; i++)\n"
"    mc.mfcc_ttls[i] = oifs_ttl[i];\n"
"setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_MFC,\n"
"           (void *)&mc, sizeof(mc));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:331
#, no-wrap
msgid ""
"/* IPv6 */\n"
"struct mf6cctl mc;\n"
"memset(&mc, 0, sizeof(mc));\n"
"memcpy(&mc.mf6cc_origin, &source_addr, sizeof(mc.mf6cc_origin));\n"
"memcpy(&mc.mf6cc_mcastgrp, &group_addr, sizeof(mf6cc_mcastgrp));\n"
"mc.mf6cc_parent = iif_index;\n"
"for (i = 0; i E<lt> maxvifs; i++)\n"
"    if (oifs_ttl[i] E<gt> 0)\n"
"        IF_SET(i, &mc.mf6cc_ifset);\n"
"setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_ADD_MFC,\n"
"           (void *)&mc, sizeof(mc));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:351
msgid ""
"The E<.Va source_addr> and E<.Va group_addr> are the source and group "
"address of the multicast packet (as set in the upcall message).  The E<.Va "
"iif_index> is the virtual interface index of the multicast interface the "
"multicast packets for this specific source and group address should be "
"received on.  The E<.Va oifs_ttl[]> array contains the minimum TTL (per "
"interface) a multicast packet should have to be forwarded on an outgoing "
"interface.  If the TTL value is zero, the corresponding interface is not "
"included in the set of outgoing interfaces.  Note that in case of IPv6 only "
"the set of outgoing interfaces can be specified."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:353
msgid "An MFC entry is deleted by:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:361
#, no-wrap
msgid ""
"/* IPv4 */\n"
"struct mfcctl mc;\n"
"memset(&mc, 0, sizeof(mc));\n"
"memcpy(&mc.mfcc_origin, &source_addr, sizeof(mc.mfcc_origin));\n"
"memcpy(&mc.mfcc_mcastgrp, &group_addr, sizeof(mc.mfcc_mcastgrp));\n"
"setsockopt(mrouter_s4, IPPROTO_IP, MRT_DEL_MFC,\n"
"           (void *)&mc, sizeof(mc));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:370
#, no-wrap
msgid ""
"/* IPv6 */\n"
"struct mf6cctl mc;\n"
"memset(&mc, 0, sizeof(mc));\n"
"memcpy(&mc.mf6cc_origin, &source_addr, sizeof(mc.mf6cc_origin));\n"
"memcpy(&mc.mf6cc_mcastgrp, &group_addr, sizeof(mf6cc_mcastgrp));\n"
"setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_DEL_MFC,\n"
"           (void *)&mc, sizeof(mc));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:375
msgid ""
"The following method can be used to get various statistics per installed MFC "
"entry in the kernel (e.g., the number of forwarded packets per source and "
"group address):"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:382
#, no-wrap
msgid ""
"/* IPv4 */\n"
"struct sioc_sg_req sgreq;\n"
"memset(&sgreq, 0, sizeof(sgreq));\n"
"memcpy(&sgreq.src, &source_addr, sizeof(sgreq.src));\n"
"memcpy(&sgreq.grp, &group_addr, sizeof(sgreq.grp));\n"
"ioctl(mrouter_s4, SIOCGETSGCNT, &sgreq);\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:390
#, no-wrap
msgid ""
"/* IPv6 */\n"
"struct sioc_sg_req6 sgreq;\n"
"memset(&sgreq, 0, sizeof(sgreq));\n"
"memcpy(&sgreq.src, &source_addr, sizeof(sgreq.src));\n"
"memcpy(&sgreq.grp, &group_addr, sizeof(sgreq.grp));\n"
"ioctl(mrouter_s6, SIOCGETSGCNT_IN6, &sgreq);\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:395
msgid ""
"The following method can be used to get various statistics per multicast "
"virtual interface in the kernel (e.g., the number of forwarded packets per "
"interface):"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:401
#, no-wrap
msgid ""
"/* IPv4 */\n"
"struct sioc_vif_req vreq;\n"
"memset(&vreq, 0, sizeof(vreq));\n"
"vreq.vifi = vif_index;\n"
"ioctl(mrouter_s4, SIOCGETVIFCNT, &vreq);\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:408
#, no-wrap
msgid ""
"/* IPv6 */\n"
"struct sioc_mif_req6 mreq;\n"
"memset(&mreq, 0, sizeof(mreq));\n"
"mreq.mifi = vif_index;\n"
"ioctl(mrouter_s6, SIOCGETMIFCNT_IN6, &mreq);\n"
msgstr ""

#. type: Ss
#: /usr/src/share/man/man4/multicast.4:409
#, no-wrap
msgid "Advanced Multicast API Programming Guide"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:414
msgid ""
"If we want to add new features in the kernel, it becomes difficult to "
"preserve backward compatibility (binary and API), and at the same time to "
"allow user-level processes to take advantage of the new features (if the "
"kernel supports them)."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:418
msgid ""
"One of the mechanisms that allows us to preserve the backward compatibility "
"is a sort of negotiation between the user-level process and the kernel:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:422
msgid ""
"The user-level process tries to enable in the kernel the set of new features "
"(and the corresponding API) it would like to use."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:425
msgid ""
"The kernel returns the (sub)set of features it knows about and is willing to "
"be enabled."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:428
msgid ""
"The user-level process uses only that set of features the kernel has agreed "
"on."
msgstr ""

#.  XXX: edit as appropriate after the advanced multicast API is
#.  supported under IPv6
#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:440
msgid ""
"To support backward compatibility, if the user-level process does not ask "
"for any new features, the kernel defaults to the basic multicast API (see "
"the E<.Sx \"Programming Guide\"> section).  Currently, the advanced "
"multicast API exists only for IPv4; in the future there will be IPv6 support "
"as well."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:444
msgid ""
"Below is a summary of the expandable API solution.  Note that all new "
"options and structures are defined in"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:446
msgid "and"
msgstr ""

#. type: In
#: /usr/src/share/man/man4/multicast.4:446
#, no-wrap
msgid "netinet6/ip6_mroute.h ,"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:448
msgid "unless stated otherwise."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:466
msgid ""
"The user-level process uses new E<.Fn getsockopt Ns / Ns Fn setsockopt> "
"options to perform the API features negotiation with the kernel.  This "
"negotiation must be performed right after the multicast routing socket is "
"open.  The set of desired/allowed features is stored in a bitset (currently, "
"in E<.Vt uint32_t>; i.e., maximum of 32 new features).  The new E<.Fn "
"getsockopt Ns / Ns Fn setsockopt> options are E<.Dv MRT_API_SUPPORT> and "
"E<.Dv MRT_API_CONFIG>.  Example:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:469
#, no-wrap
msgid ""
"uint32_t v;\n"
"getsockopt(sock, IPPROTO_IP, MRT_API_SUPPORT, (void *)&v, sizeof(v));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:489
msgid ""
"would set in E<.Va v> the pre-defined bits that the kernel API supports.  "
"The eight least significant bits in E<.Vt uint32_t> are same as the eight "
"possible flags E<.Dv MRT_MFC_FLAGS_*> that can be used in E<.Va mfcc_flags> "
"as part of the new definition of E<.Vt \"struct mfcctl\"> (see below about "
"those flags), which leaves 24 flags for other new features.  The value "
"returned by E<.Fn getsockopt MRT_API_SUPPORT> is read-only; in other words, "
"E<.Fn setsockopt MRT_API_SUPPORT> would fail."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:491
msgid "To modify the API, and to set some specific feature in the kernel, then:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:501
#, no-wrap
msgid ""
"uint32_t v = MRT_MFC_FLAGS_DISABLE_WRONGVIF;\n"
"if (setsockopt(sock, IPPROTO_IP, MRT_API_CONFIG, (void *)&v, sizeof(v))\n"
"    != 0) {\n"
"    return (ERROR);\n"
"}\n"
"if (v & MRT_MFC_FLAGS_DISABLE_WRONGVIF)\n"
"    return (OK);\t/* Success */\n"
"else\n"
"    return (ERROR);\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:512
msgid ""
"In other words, when E<.Fn setsockopt MRT_API_CONFIG> is called, the "
"argument to it specifies the desired set of features to be enabled in the "
"API and the kernel.  The return value in E<.Va v> is the actual (sub)set of "
"features that were enabled in the kernel.  To obtain later the same set of "
"features that were enabled, then:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:514
#, no-wrap
msgid "getsockopt(sock, IPPROTO_IP, MRT_API_CONFIG, (void *)&v, sizeof(v));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:521
msgid ""
"The set of enabled features is global.  In other words, E<.Fn setsockopt "
"MRT_API_CONFIG> should be called right after E<.Fn setsockopt MRT_INIT>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:523
msgid "Currently, the following set of new features is defined:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:528
#, no-wrap
msgid ""
"#define\tMRT_MFC_FLAGS_DISABLE_WRONGVIF (1 E<lt>E<lt> 0) /* disable WRONGVIF "
"signals */\n"
"#define\tMRT_MFC_FLAGS_BORDER_VIF   (1 E<lt>E<lt> 1)  /* border vif              "
"*/\n"
"#define MRT_MFC_RP                 (1 E<lt>E<lt> 8)  /* enable RP "
"address\t*/\n"
"#define MRT_MFC_BW_UPCALL          (1 E<lt>E<lt> 9)  /* enable bw "
"upcalls\t*/\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:553
msgid ""
"The advanced multicast API uses a newly defined E<.Vt \"struct mfcctl2\"> "
"instead of the traditional E<.Vt \"struct mfcctl\">.  The original E<.Vt "
"\"struct mfcctl\"> is kept as is.  The new E<.Vt \"struct mfcctl2\"> is:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:564
#, no-wrap
msgid ""
"/*\n"
" * The new argument structure for MRT_ADD_MFC and MRT_DEL_MFC overlays\n"
" * and extends the old struct mfcctl.\n"
" */\n"
"struct mfcctl2 {\n"
"        /* the mfcctl fields */\n"
"        struct in_addr  mfcc_origin;       /* ip origin of mcasts       */\n"
"        struct in_addr  mfcc_mcastgrp;     /* multicast group associated*/\n"
"        vifi_t          mfcc_parent;       /* incoming vif              */\n"
"        u_char          mfcc_ttls[MAXVIFS];/* forwarding ttls on vifs   */\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:569
#, no-wrap
msgid ""
"        /* extension fields */\n"
"        uint8_t         mfcc_flags[MAXVIFS];/* the MRT_MFC_FLAGS_* flags*/\n"
"        struct in_addr  mfcc_rp;            /* the RP address           */\n"
"};\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:576
msgid ""
"The new fields are E<.Va mfcc_flags[MAXVIFS]> and E<.Va mfcc_rp>.  Note that "
"for compatibility reasons they are added at the end."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:582
msgid ""
"The E<.Va mfcc_flags[MAXVIFS]> field is used to set various flags per "
"interface per (S,G) entry.  Currently, the defined flags are:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:585
#, no-wrap
msgid ""
"#define\tMRT_MFC_FLAGS_DISABLE_WRONGVIF (1 E<lt>E<lt> 0) /* disable WRONGVIF "
"signals */\n"
"#define\tMRT_MFC_FLAGS_BORDER_VIF       (1 E<lt>E<lt> 1) /* border vif          "
"*/\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:605
msgid ""
"The E<.Dv MRT_MFC_FLAGS_DISABLE_WRONGVIF> flag is used to explicitly disable "
"the E<.Dv IGMPMSG_WRONGVIF> kernel signal at the (S,G) granularity if a "
"multicast data packet arrives on the wrong interface.  Usually, this signal "
"is used to complete the shortest-path switch in case of PIM-SM multicast "
"routing, or to trigger a PIM assert message.  However, it should not be "
"delivered for interfaces that are not in the outgoing interface set, and "
"that are not expecting to become an incoming interface.  Hence, if the E<.Dv "
"MRT_MFC_FLAGS_DISABLE_WRONGVIF> flag is set for some of the interfaces, then "
"a data packet that arrives on that interface for that MFC entry will NOT "
"trigger a WRONGVIF signal.  If that flag is not set, then a signal is "
"triggered (the default action)."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:615
msgid ""
"The E<.Dv MRT_MFC_FLAGS_BORDER_VIF> flag is used to specify whether the "
"Border-bit in PIM Register messages should be set (in case when the Register "
"encapsulation is performed inside the kernel).  If it is set for the special "
"PIM Register kernel virtual interface (see E<.Xr pim 4>), the Border-bit in "
"the Register messages sent to the RP will be set."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:617
msgid "The remaining six bits are reserved for future usage."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:629
msgid ""
"The E<.Va mfcc_rp> field is used to specify the RP address (in case of "
"PIM-SM multicast routing)  for a multicast group G if we want to perform "
"kernel-level PIM Register encapsulation.  The E<.Va mfcc_rp> field is used "
"only if the E<.Dv MRT_MFC_RP> advanced API flag/capability has been "
"successfully set by E<.Fn setsockopt MRT_API_CONFIG>."
msgstr ""

#
#.  3. Kernel-level PIM Register encapsulation
#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:658
msgid ""
"If the E<.Dv MRT_MFC_RP> flag was successfully set by E<.Fn setsockopt "
"MRT_API_CONFIG>, then the kernel will attempt to perform the PIM Register "
"encapsulation itself instead of sending the multicast data packets to user "
"level (inside E<.Dv IGMPMSG_WHOLEPKT> upcalls) for user-level "
"encapsulation.  The RP address would be taken from the E<.Va mfcc_rp> field "
"inside the new E<.Vt \"struct mfcctl2\">.  However, even if the E<.Dv "
"MRT_MFC_RP> flag was successfully set, if the E<.Va mfcc_rp> field was set "
"to E<.Dv INADDR_ANY>, then the kernel will still deliver an E<.Dv "
"IGMPMSG_WHOLEPKT> upcall with the multicast data packet to the user-level "
"process."
msgstr ""

#
#.  Note that if this code is ported to IPv6, we may need the kernel to
#.  perform MTU discovery to the RP, and keep those discoveries inside
#.  the kernel so the encapsulating router may send back ICMP
#.  Fragmentation Required if the size of the multicast data packet is
#.  too large (see "Encapsulating data packets in the Register Tunnel"
#.  in Section 4.4.1 in the PIM-SM spec
#.  draft-ietf-pim-sm-v2-new-05.{txt,ps}).
#.  For IPv4 we may be able to get away without it, but for IPv6 we need
#.  that.
#
#.  4. Mechanism for "multicast bandwidth monitoring and upcalls".
#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:682
msgid ""
"In addition, if the multicast data packet is too large to fit within a "
"single IP packet after the PIM Register encapsulation (e.g., if its size was "
"on the order of 65500 bytes), the data packet will be fragmented, and then "
"each of the fragments will be encapsulated separately.  Note that typically "
"a multicast data packet can be that large only if it was originated locally "
"from the same hosts that performs the encapsulation; otherwise the "
"transmission of the multicast data packet over Ethernet for example would "
"have fragmented it into much smaller pieces."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:688
msgid ""
"Typically, a multicast routing user-level process would need to know the "
"forwarding bandwidth for some data flow.  For example, the multicast routing "
"process may want to timeout idle MFC entries, or in case of PIM-SM it can "
"initiate (S,G) shortest-path switch if the bandwidth rate is above a "
"threshold for example."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:697
msgid ""
"The original solution for measuring the bandwidth of a dataflow was that a "
"user-level process would periodically query the kernel about the number of "
"forwarded packets/bytes per (S,G), and then based on those numbers it would "
"estimate whether a source has been idle, or whether the source's "
"transmission bandwidth is above a threshold.  That solution is far from "
"being scalable, hence the need for a new mechanism for bandwidth monitoring."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:699
msgid "Below is a description of the bandwidth monitoring mechanism."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:704
msgid ""
"If the bandwidth of a data flow satisfies some pre-defined filter, the "
"kernel delivers an upcall on the multicast routing socket to the multicast "
"routing process that has installed that filter."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:708
msgid ""
"The bandwidth-upcall filters are installed per (S,G).  There can be more "
"than one filter per (S,G)."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:721
msgid ""
"Instead of supporting all possible comparison operations (i.e., E<lt> E<lt>= "
"== != E<gt> E<gt>= ), there is support only for the E<lt>= and E<gt>= "
"operations, because this makes the kernel-level implementation simpler, and "
"because practically we need only those two.  Further, the missing operations "
"can be simulated by secondary user-level filtering of those E<lt>= and "
"E<gt>= filters.  For example, to simulate !=, then we need to install filter "
"E<.Dq bw E<lt>= 0xffffffff>, and after an upcall is received, we need to "
"check whether E<.Dq measured_bw != expected_bw>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:727
msgid ""
"The bandwidth-upcall mechanism is enabled by E<.Fn setsockopt "
"MRT_API_CONFIG> for the E<.Dv MRT_MFC_BW_UPCALL> flag."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:735
msgid ""
"The bandwidth-upcall filters are added/deleted by the new E<.Fn setsockopt "
"MRT_ADD_BW_UPCALL> and E<.Fn setsockopt MRT_DEL_BW_UPCALL> respectively "
"(with the appropriate E<.Vt \"struct bw_upcall\"> argument of course)."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:739
msgid ""
"From application point of view, a developer needs to know about the "
"following:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:771
#, no-wrap
msgid ""
"/*\n"
" * Structure for installing or delivering an upcall if the\n"
" * measured bandwidth is above or below a threshold.\n"
" *\n"
" * User programs (e.g. daemons) may have a need to know when the\n"
" * bandwidth used by some data flow is above or below some threshold.\n"
" * This interface allows the userland to specify the threshold (in\n"
" * bytes and/or packets) and the measurement interval. Flows are\n"
" * all packet with the same source and destination IP address.\n"
" * At the moment the code is only used for multicast destinations\n"
" * but there is nothing that prevents its use for unicast.\n"
" *\n"
" * The measurement interval cannot be shorter than some Tmin (currently, "
"3s).\n"
" * The threshold is set in packets and/or bytes per_interval.\n"
" *\n"
" * Measurement works as follows:\n"
" *\n"
" * For E<gt>= measurements:\n"
" * The first packet marks the start of a measurement interval.\n"
" * During an interval we count packets and bytes, and when we\n"
" * pass the threshold we deliver an upcall and we are done.\n"
" * The first packet after the end of the interval resets the\n"
" * count and restarts the measurement.\n"
" *\n"
" * For E<lt>= measurement:\n"
" * We start a timer to fire at the end of the interval, and\n"
" * then for each incoming packet we count packets and bytes.\n"
" * When the timer fires, we compare the value with the threshold,\n"
" * schedule an upcall if we are below, and restart the measurement\n"
" * (reschedule timer and zero counters).\n"
" */\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:777
#, no-wrap
msgid ""
"struct bw_data {\n"
"        struct timeval  b_time;\n"
"        uint64_t        b_packets;\n"
"        uint64_t        b_bytes;\n"
"};\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:790
#, no-wrap
msgid ""
"struct bw_upcall {\n"
"        struct in_addr  bu_src;         /* source address            */\n"
"        struct in_addr  bu_dst;         /* destination address       */\n"
"        uint32_t        bu_flags;       /* misc flags (see below)    */\n"
"#define BW_UPCALL_UNIT_PACKETS (1 E<lt>E<lt> 0) /* threshold (in packets)    "
"*/\n"
"#define BW_UPCALL_UNIT_BYTES   (1 E<lt>E<lt> 1) /* threshold (in bytes)      "
"*/\n"
"#define BW_UPCALL_GEQ          (1 E<lt>E<lt> 2) /* upcall if bw E<gt>= "
"threshold */\n"
"#define BW_UPCALL_LEQ          (1 E<lt>E<lt> 3) /* upcall if bw E<lt>= "
"threshold */\n"
"#define BW_UPCALL_DELETE_ALL   (1 E<lt>E<lt> 4) /* delete all upcalls for "
"s,d*/\n"
"        struct bw_data  bu_threshold;   /* the bw threshold          */\n"
"        struct bw_data  bu_measured;    /* the measured bw           */\n"
"};\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:796
#, no-wrap
msgid ""
"/* max. number of upcalls to deliver together */\n"
"#define BW_UPCALLS_MAX\t\t\t\t128\n"
"/* min. threshold time interval for bandwidth measurement */\n"
"#define BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC\t3\n"
"#define BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC\t0\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:812
msgid ""
"The E<.Vt bw_upcall> structure is used as an argument to E<.Fn setsockopt "
"MRT_ADD_BW_UPCALL> and E<.Fn setsockopt MRT_DEL_BW_UPCALL>.  Each E<.Fn "
"setsockopt MRT_ADD_BW_UPCALL> installs a filter in the kernel for the source "
"and destination address in the E<.Vt bw_upcall> argument, and that filter "
"will trigger an upcall according to the following pseudo-algorithm:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:827
#, no-wrap
msgid ""
" if (bw_upcall_oper IS \"E<gt>=\") {\n"
"    if (((bw_upcall_unit & PACKETS == PACKETS) &&\n"
"         (measured_packets E<gt>= threshold_packets)) ||\n"
"        ((bw_upcall_unit & BYTES == BYTES) &&\n"
"         (measured_bytes E<gt>= threshold_bytes)))\n"
"       SEND_UPCALL(\"measured bandwidth is E<gt>= threshold\");\n"
"  }\n"
"  if (bw_upcall_oper IS \"E<lt>=\" && measured_interval E<gt>= "
"threshold_interval) {\n"
"    if (((bw_upcall_unit & PACKETS == PACKETS) &&\n"
"         (measured_packets E<lt>= threshold_packets)) ||\n"
"        ((bw_upcall_unit & BYTES == BYTES) &&\n"
"         (measured_bytes E<lt>= threshold_bytes)))\n"
"       SEND_UPCALL(\"measured bandwidth is E<lt>= threshold\");\n"
"  }\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:833
msgid ""
"In the same E<.Vt bw_upcall> the unit can be specified in both BYTES and "
"PACKETS.  However, the GEQ and LEQ flags are mutually exclusive."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:847
msgid ""
"Basically, an upcall is delivered if the measured bandwidth is E<gt>= or "
"E<lt>= the threshold bandwidth (within the specified measurement interval).  "
"For practical reasons, the smallest value for the measurement interval is 3 "
"seconds.  If smaller values are allowed, then the bandwidth estimation may "
"be less accurate, or the potentially very high frequency of the generated "
"upcalls may introduce too much overhead.  For the E<gt>= operation, the "
"answer may be known before the end of E<.Va threshold_interval>, therefore "
"the upcall may be delivered earlier.  For the E<lt>= operation however, we "
"must wait until the threshold interval has expired to know the answer."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:849
msgid "Example of usage:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:875
#, no-wrap
msgid ""
"struct bw_upcall bw_upcall;\n"
"/* Assign all bw_upcall fields as appropriate */\n"
"memset(&bw_upcall, 0, sizeof(bw_upcall));\n"
"memcpy(&bw_upcall.bu_src, &source, sizeof(bw_upcall.bu_src));\n"
"memcpy(&bw_upcall.bu_dst, &group, sizeof(bw_upcall.bu_dst));\n"
"bw_upcall.bu_threshold.b_data = threshold_interval;\n"
"bw_upcall.bu_threshold.b_packets = threshold_packets;\n"
"bw_upcall.bu_threshold.b_bytes = threshold_bytes;\n"
"if (is_threshold_in_packets)\n"
"    bw_upcall.bu_flags |= BW_UPCALL_UNIT_PACKETS;\n"
"if (is_threshold_in_bytes)\n"
"    bw_upcall.bu_flags |= BW_UPCALL_UNIT_BYTES;\n"
"do {\n"
"    if (is_geq_upcall) {\n"
"        bw_upcall.bu_flags |= BW_UPCALL_GEQ;\n"
"        break;\n"
"    }\n"
"    if (is_leq_upcall) {\n"
"        bw_upcall.bu_flags |= BW_UPCALL_LEQ;\n"
"        break;\n"
"    }\n"
"    return (ERROR);\n"
"} while (0);\n"
"setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_BW_UPCALL,\n"
"          (void *)&bw_upcall, sizeof(bw_upcall));\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:883
msgid ""
"To delete a single filter, then use E<.Dv MRT_DEL_BW_UPCALL>, and the fields "
"of bw_upcall must be set exactly same as when E<.Dv MRT_ADD_BW_UPCALL> was "
"called."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:895
msgid ""
"To delete all bandwidth filters for a given (S,G), then only the E<.Va "
"bu_src> and E<.Va bu_dst> fields in E<.Vt \"struct bw_upcall\"> need to be "
"set, and then just set only the E<.Dv BW_UPCALL_DELETE_ALL> flag inside "
"field E<.Va bw_upcall.bu_flags>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:898
msgid ""
"The bandwidth upcalls are received by aggregating them in the new upcall "
"message:"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:900
#, no-wrap
msgid "#define IGMPMSG_BW_UPCALL  4  /* BW monitoring upcall */\n"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:937
msgid ""
"This message is an array of E<.Vt \"struct bw_upcall\"> elements (up to "
"E<.Dv BW_UPCALLS_MAX> = 128).  The upcalls are delivered when there are 128 "
"pending upcalls, or when 1 second has expired since the previous upcall "
"(whichever comes first).  In an E<.Vt \"struct upcall\"> element, the E<.Va "
"bu_measured> field is filled-in to indicate the particular measured values.  "
"However, because of the way the particular intervals are measured, the user "
"should be careful how E<.Va bu_measured.b_time> is used.  For example, if "
"the filter is installed to trigger an upcall if the number of packets is "
"E<gt>= 1, then E<.Va bu_measured> may have a value of zero in the upcalls "
"after the first one, because the measured interval for E<gt>= filters is "
"E<.Dq clocked> by the forwarded packets.  Hence, this upcall mechanism "
"should not be used for measuring the exact value of the bandwidth of the "
"forwarded data.  To measure the exact bandwidth, the user would need to get "
"the forwarded packets statistics with the E<.Fn ioctl SIOCGETSGCNT> "
"mechanism (see the E<.Sx Programming Guide> section) ."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:947
msgid ""
"Note that the upcalls for a filter are delivered until the specific filter "
"is deleted, but no more frequently than once per E<.Va "
"bu_threshold.b_time>.  For example, if the filter is specified to deliver a "
"signal if bw E<gt>= 1 packet, the first packet will trigger a signal, but "
"the next upcall will be triggered no earlier than E<.Va bu_threshold.b_time> "
"after the previous upcall."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man4/multicast.4:947
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:968
msgid ""
"E<.Xr getsockopt 2>, E<.Xr recvfrom 2>, E<.Xr recvmsg 2>, E<.Xr setsockopt "
"2>, E<.Xr socket 2>, E<.Xr sourcefilter 3>, E<.Xr altq 4>, E<.Xr dummynet "
"4>, E<.Xr gif 4>, E<.Xr gre 4>, E<.Xr icmp6 4>, E<.Xr igmp 4>, E<.Xr inet "
"4>, E<.Xr inet6 4>, E<.Xr intro 4>, E<.Xr ip 4>, E<.Xr ip6 4>, E<.Xr mld 4>, "
"E<.Xr pim 4>"
msgstr ""

#. type: Sh
#: /usr/src/share/man/man4/multicast.4:968
#, no-wrap
msgid "HISTORY"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:980
msgid ""
"The Distance Vector Multicast Routing Protocol (DVMRP)  was the first "
"developed multicast routing protocol.  Later, other protocols such as "
"Multicast Extensions to OSPF (MOSPF)  and Core Based Trees (CBT), were "
"developed as well.  Routers at autonomous system boundaries may now exchange "
"multicast routes with peers via the Border Gateway Protocol (BGP).  Many "
"other routing protocols are able to redistribute multicast routes for use "
"with E<.Dv PIM-SM> and E<.Dv PIM-DM>."
msgstr ""

#. type: Sh
#: /usr/src/share/man/man4/multicast.4:980
#, no-wrap
msgid "AUTHORS"
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:1008
msgid ""
"E<.An -nosplit> The original multicast code was written by E<.An David "
"Waitzman> (BBN Labs), and later modified by the following individuals: E<.An "
"Steve Deering> (Stanford), E<.An Mark J. Steiglitz> (Stanford), E<.An Van "
"Jacobson> (LBL), E<.An Ajit Thyagarajan> (PARC), E<.An Bill Fenner> (PARC).  "
"The IPv6 multicast support was implemented by the KAME project E<.Pq Pa "
"http://www.kame.net>, and was based on the IPv4 multicast code.  The "
"advanced multicast API and the multicast bandwidth monitoring were "
"implemented by E<.An Pavlin Radoslavov> (ICSI)  in collaboration with E<.An "
"Chris Brown> (NextHop).  The IGMPv3 and MLDv2 multicast support was "
"implemented by E<.An Bruce Simpson>."
msgstr ""

#. type: Plain text
#: /usr/src/share/man/man4/multicast.4:1011
msgid "This manual page was written by E<.An Pavlin Radoslavov> (ICSI)."
msgstr ""
